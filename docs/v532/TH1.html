<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!--                                             -->
<!-- Author: ROOT team (rootdev@pcroot.cern.ch)  -->
<!--                                             -->
<!--   Date: Fri Dec  2 14:27:54 2011            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<title>TH1</title>
<meta name="rating" content="General" />
<meta name="objecttype" content="Manual" />
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers, cern" />
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis." />
<link rel="stylesheet" type="text/css" href="ROOT.css" id="ROOTstyle" />
<script type="text/javascript" src="ROOT.js"></script>
</head>
<body  onload="javascript:SetValuesFromCookie();"><div id="body_content">
<div id="root_header"><img src="http://root.cern.ch/drupal/sites/default/files/rootdrawing-logo.png" alt="ROOT logo"/></div>
<a name="TopOfPage"></a>
<script type="text/javascript">WriteFollowPageBox('class TH1','libHist','TH1.h');</script>
<div id="toplinks">
<div class="descrhead"><div class="descrheadcontent">
<span class="descrtitle">Quick Links:</span>
<a class="descrheadentry" href="http://root.cern.ch">ROOT Homepage</a>
<a class="descrheadentry" href="./ClassIndex.html">Class Index</a>
<a class="descrheadentry" href="./ClassHierarchy.html">Class Hierarchy</a></div>
<script type="text/javascript">
function onSearch() {
var s='http://www.google.com/search?q=%s+site%3A%u+-site%3A%u%2Fsrc%2F+-site%3A%u%2Fexamples%2F';
var ref=String(document.location.href).replace(/https?:\/\//,'').replace(/\/[^\/]*$/,'').replace(/\//g,'%2F');
window.location.href=s.replace(/%u/ig,ref).replace(/%s/ig,escape(document.searchform.t.value));
return false;}
</script>
<form id="searchform" name="searchform" onsubmit="return onSearch()" action="javascript:onSearch();" method="post">
<input name="t" size="30" value="Search documentation..." onfocus="if (document.searchform.t.value=='Search documentation...') document.searchform.t.value='';"></input>
<a id="searchlink"  title="www.google.com"  href="javascript:onSearch();" onclick="return onSearch()">Search</a></form>
</div>
<div class="descrhead"><div class="descrheadcontent">
<span class="descrtitle">Source:</span>
<a class="descrheadentry" href="src/TH1.h.html">header file</a>
<a class="descrheadentry" href="src/TH1.cxx.html">source file</a>
<a class="descrheadentry" href="http://root.cern.ch/viewcvs/trunk/hist/hist/inc/TH1.h?view=log">viewVC header</a> <a class="descrheadentry" href="http://root.cern.ch/viewcvs/trunk/hist/hist/src/TH1.cxx?view=log">viewVC source</a> 
</div></div>
<div class="descrhead"><div class="descrheadcontent">
<span class="descrtitle">Sections:</span>
<a class="descrheadentry" href="#TH1:description">class description</a> 
<a class="descrheadentry" href="#TH1:Function_Members">function members</a>
<a class="descrheadentry" href="#TH1:Data_Members">data members</a>
<a class="descrheadentry" href="#TH1:Class_Charts">class charts</a>
</div></div>
</div>
<div class="location">
<a class="locationlevel" href="index.html">ROOT</a>
 &#187; <a class="locationlevel" href="./HIST_Index.html">HIST</a>
 &#187; <a class="locationlevel" href="./HIST_HIST_Index.html">HIST</a>
 &#187; <a class="locationlevel" href="#TopOfPage">TH1</a>
</div>
<div class="dropshadow"><div class="withshadow"><h1><a name="TH1:description"></a>class TH1: public <a href="./TNamed.html">TNamed</a>, public <a href="./TAttLine.html">TAttLine</a>, public <a href="./TAttFill.html">TAttFill</a>, public <a href="./TAttMarker.html">TAttMarker</a></h1>
<div class="classdescr">
<pre>

</pre><!-- TDocHtmlDirective start --><center><h2>The Histogram classes</h2></center>
ROOT supports the following histogram types:
<ul>
  <li>1-D histograms:
   <ul>
         <li>TH1C : histograms with one byte per channel.   Maximum bin content = 127
         <li>TH1S : histograms with one short per channel.  Maximum bin content = 32767
         <li>TH1I : histograms with one int per channel.    Maximum bin content = 2147483647
         <li>TH1F : histograms with one float per channel.  Maximum precision 7 digits
         <li>TH1D : histograms with one double per channel. Maximum precision 14 digits
   </ul>
  <li>2-D histograms:
   <ul>
         <li>TH2C : histograms with one byte per channel.   Maximum bin content = 127
         <li>TH2S : histograms with one short per channel.  Maximum bin content = 32767
         <li>TH2I : histograms with one int per channel.    Maximum bin content = 2147483647
         <li>TH2F : histograms with one float per channel.  Maximum precision 7 digits
         <li>TH2D : histograms with one double per channel. Maximum precision 14 digits
   </ul>
  <li>3-D histograms:
   <ul>
         <li>TH3C : histograms with one byte per channel.   Maximum bin content = 127
         <li>TH3S : histograms with one short per channel.  Maximum bin content = 32767
         <li>TH3I : histograms with one int per channel.    Maximum bin content = 2147483647
         <li>TH3F : histograms with one float per channel.  Maximum precision 7 digits
         <li>TH3D : histograms with one double per channel. Maximum precision 14 digits
   </ul>
  <li>Profile histograms: See classes  TProfile, TProfile2D and TProfile3D.
      Profile histograms are used to display the mean value of Y and its RMS
      for each bin in X. Profile histograms are in many cases an elegant
      replacement of two-dimensional histograms : the inter-relation of two
      measured quantities X and Y can always be visualized by a two-dimensional
      histogram or scatter-plot; If Y is an unknown (but single-valued)
      approximate function of X, this function is displayed by a profile
      histogram with much better precision than by a scatter-plot.
</ul>
All histogram classes are derived from the base class TH1
<pre>
                                TH1
                                 ^
                                 |
                                 |
                                 |
         -----------------------------------------------------------
                |                |       |      |      |     |     |
                |                |      TH1C   TH1S   TH1I  TH1F  TH1D
                |                |                                 |
                |                |                                 |
                |               TH2                             TProfile
                |                |
                |                |
                |                ----------------------------------
                |                        |      |      |     |     |
                |                       TH2C   TH2S   TH2I  TH2F  TH2D
                |                                                  |
               TH3                                                 |
                |                                               TProfile2D
                |
                -------------------------------------
                        |      |      |      |      |
                       TH3C   TH3S   TH3I   TH3F   TH3D
                                                    |
                                                    |
                                                 TProfile3D
      The TH*C classes also inherit from the array class TArrayC.
      The TH*S classes also inherit from the array class TArrayS.
      The TH*I classes also inherit from the array class TArrayI.
      The TH*F classes also inherit from the array class TArrayF.
      The TH*D classes also inherit from the array class TArrayD.
</pre>
<h4>Creating histograms</h4>
<p>
     Histograms are created by invoking one of the constructors, e.g.
<pre>
       TH1F *h1 = new TH1F("h1", "h1 title", 100, 0, 4.4);
       TH2F *h2 = new TH2F("h2", "h2 title", 40, 0, 4, 30, -3, 3);
</pre>
<p>  Histograms may also be created by:
  <ul>
      <li> calling the Clone function, see below
      <li> making a projection from a 2-D or 3-D histogram, see below
      <li> reading an histogram from a file
   </ul>
<p>  When an histogram is created, a reference to it is automatically added
     to the list of in-memory objects for the current file or directory.
     This default behaviour can be changed by:
<pre>
       h->SetDirectory(0);          for the current histogram h
       TH1::AddDirectory(kFALSE);   sets a global switch disabling the reference
</pre>
     When the histogram is deleted, the reference to it is removed from
     the list of objects in memory.
     When a file is closed, all histograms in memory associated with this file
     are automatically deleted.
<h4>Fix or variable bin size</h4>
     All histogram types support either fix or variable bin sizes.
     2-D histograms may have fix size bins along X and variable size bins
     along Y or vice-versa. The functions to fill, manipulate, draw or access
     histograms are identical in both cases.
<p>     Each histogram always contains 3 objects TAxis: fXaxis, fYaxis and fZaxis
     To access the axis parameters, do:
<pre>
        TAxis *xaxis = h->GetXaxis(); etc.
        Double_t binCenter = xaxis->GetBinCenter(bin), etc.
</pre>
     See class TAxis for a description of all the access functions.
     The axis range is always stored internally in double precision.
<h4>Convention for numbering bins</h4>
      For all histogram types: nbins, xlow, xup
<pre>
        bin = 0;       underflow bin
        bin = 1;       first bin with low-edge xlow INCLUDED
        bin = nbins;   last bin with upper-edge xup EXCLUDED
        bin = nbins+1; overflow bin
</pre>
<p>      In case of 2-D or 3-D histograms, a "global bin" number is defined.
      For example, assuming a 3-D histogram with (binx, biny, binz), the function
<pre>
        Int_t gbin = h->GetBin(binx, biny, binz);
</pre>
      returns a global/linearized gbin number. This global gbin is useful
      to access the bin content/error information independently of the dimension.
      Note that to access the information other than bin content and errors
      one should use the TAxis object directly with e.g.:
<pre>
         Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);
</pre>
       returns the center along z of bin number 27 (not the global bin)
       in the 3-D histogram h3.
<h4>Alphanumeric Bin Labels</h4>
     By default, an histogram axis is drawn with its numeric bin labels.
     One can specify alphanumeric labels instead with:
<ul>
       <li> call TAxis::SetBinLabel(bin, label);
           This can always be done before or after filling.
           When the histogram is drawn, bin labels will be automatically drawn.
           See example in $ROOTSYS/tutorials/graphs/labels1.C, labels2.C
       <li> call to a Fill function with one of the arguments being a string, e.g.
<pre>
           hist1->Fill(somename, weigth);
           hist2->Fill(x, somename, weight);
           hist2->Fill(somename, y, weight);
           hist2->Fill(somenamex, somenamey, weight);
</pre>
           See example in $ROOTSYS/tutorials/hist/hlabels1.C, hlabels2.C
       <li> via TTree::Draw.
           see for example $ROOTSYS/tutorials/tree/cernstaff.C
<pre>
           tree.Draw("Nation::Division");
</pre>
           where "Nation" and "Division" are two branches of a Tree.
</ul>
<p>     When using the options 2 or 3 above, the labels are automatically
     added to the list (THashList) of labels for a given axis.
     By default, an axis is drawn with the order of bins corresponding
     to the filling sequence. It is possible to reorder the axis
<ul>
          <li>alphabetically
          <li>by increasing or decreasing values
</ul>
<p>     The reordering can be triggered via the TAxis context menu by selecting
     the menu item "LabelsOption" or by calling directly
        TH1::LabelsOption(option, axis) where
<ul>
          <li>axis may be "X", "Y" or "Z"
          <li>option may be:
           <ul>
             <li>"a" sort by alphabetic order
             <li>">" sort by decreasing values
             <li>"<" sort by increasing values
             <li>"h" draw labels horizontal
             <li>"v" draw labels vertical
             <li>"u" draw labels up (end of label right adjusted)
             <li>"d" draw labels down (start of label left adjusted)
           </ul>
</ul>
<p>     When using the option 2 above, new labels are added by doubling the current
     number of bins in case one label does not exist yet.
     When the Filling is terminated, it is possible to trim the number
     of bins to match the number of active labels by calling
<pre>
           TH1::LabelsDeflate(axis) with axis = "X", "Y" or "Z"
</pre>
     This operation is automatic when using TTree::Draw.
     Once bin labels have been created, they become persistent if the histogram
     is written to a file or when generating the C++ code via SavePrimitive.
<h4>Histograms with automatic bins</h4>
     When an histogram is created with an axis lower limit greater or equal
     to its upper limit, the SetBuffer is automatically called with an
     argument fBufferSize equal to fgBufferSize (default value=1000).
     fgBufferSize may be reset via the static function TH1::SetDefaultBufferSize.
     The axis limits will be automatically computed when the buffer will
     be full or when the function BufferEmpty is called.
<h4>Filling histograms</h4>
     An histogram is typically filled with statements like:
<pre>
       h1->Fill(x);
       h1->Fill(x, w); //fill with weight
       h2->Fill(x, y)
       h2->Fill(x, y, w)
       h3->Fill(x, y, z)
       h3->Fill(x, y, z, w)
</pre>
     or via one of the Fill functions accepting names described above.
     The Fill functions compute the bin number corresponding to the given
     x, y or z argument and increment this bin by the given weight.
     The Fill functions return the bin number for 1-D histograms or global
     bin number for 2-D and 3-D histograms.
<p>     If TH1::Sumw2 has been called before filling, the sum of squares of
     weights is also stored.
     One can also increment directly a bin number via TH1::AddBinContent
     or replace the existing content via TH1::SetBinContent.
     To access the bin content of a given bin, do:
<pre>
       Double_t binContent = h->GetBinContent(bin);
</pre>
<p>     By default, the bin number is computed using the current axis ranges.
     If the automatic binning option has been set via
<pre>
       h->SetBit(TH1::kCanRebin);
</pre>
     then, the Fill Function will automatically extend the axis range to
     accomodate the new value specified in the Fill argument. The method
     used is to double the bin size until the new value fits in the range,
     merging bins two by two. This automatic binning options is extensively
     used by the TTree::Draw function when histogramming Tree variables
     with an unknown range.
<p>     This automatic binning option is supported for 1-D, 2-D and 3-D histograms.
     During filling, some statistics parameters are incremented to compute
     the mean value and Root Mean Square with the maximum precision.
<p>     In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S
     a check is made that the bin contents do not exceed the maximum positive
     capacity (127 or 32767). Histograms of all types may have positive
     or/and negative bin contents.
<h4>Rebinning</h4>
     At any time, an histogram can be rebinned via TH1::Rebin. This function
     returns a new histogram with the rebinned contents.
     If bin errors were stored, they are recomputed during the rebinning.
<h4>Associated errors</h4>
     By default, for each bin, the sum of weights is computed at fill time.
     One can also call TH1::Sumw2 to force the storage and computation
     of the sum of the square of weights per bin.
     If Sumw2 has been called, the error per bin is computed as the
     sqrt(sum of squares of weights), otherwise the error is set equal
     to the sqrt(bin content).
     To return the error for a given bin number, do:
<pre>
        Double_t error = h->GetBinError(bin);
</pre>
<h4>Associated functions</h4>
     One or more object (typically a TF1*) can be added to the list
     of functions (fFunctions) associated to each histogram.
     When TH1::Fit is invoked, the fitted function is added to this list.
     Given an histogram h, one can retrieve an associated function
     with:
<pre>
        TF1 *myfunc = h->GetFunction("myfunc");
</pre>
<h4>Operations on histograms</h4>
     Many types of operations are supported on histograms or between histograms
<ul>
     <li> Addition of an histogram to the current histogram.
     <li> Additions of two histograms with coefficients and storage into the current
       histogram.
     <li> Multiplications and Divisions are supported in the same way as additions.
     <li> The Add, Divide and Multiply functions also exist to add, divide or multiply
       an histogram by a function.
</ul>
     If an histogram has associated error bars (TH1::Sumw2 has been called),
     the resulting error bars are also computed assuming independent histograms.
     In case of divisions, Binomial errors are also supported.
     One can mark a histogram to be an "average" histogram by setting its bit kIsAverage via
       myhist.SetBit(TH1::kIsAverage);
     When adding (see TH1::Add) average histograms, the histograms are averaged and not summed.
<h4>Fitting histograms</h4>
     Histograms (1-D, 2-D, 3-D and Profiles) can be fitted with a user
     specified function via TH1::Fit. When an histogram is fitted, the
     resulting function with its parameters is added to the list of functions
     of this histogram. If the histogram is made persistent, the list of
     associated functions is also persistent. Given a pointer (see above)
     to an associated function myfunc, one can retrieve the function/fit
     parameters with calls such as:
<pre>
       Double_t chi2 = myfunc->GetChisquare();
       Double_t par0 = myfunc->GetParameter(0); value of 1st parameter
       Double_t err0 = myfunc->GetParError(0);  error on first parameter
</pre>
<h4>Projections of histograms</h4>
<p>     One can:
<ul>
      <li> make a 1-D projection of a 2-D histogram or Profile
        see functions TH2::ProjectionX,Y, TH2::ProfileX,Y, TProfile::ProjectionX
      <li> make a 1-D, 2-D or profile out of a 3-D histogram
        see functions TH3::ProjectionZ, TH3::Project3D.
</ul>
<p>     One can fit these projections via:
<pre>
      TH2::FitSlicesX,Y, TH3::FitSlicesZ.
</pre>
<h4>Random Numbers and histograms</h4>
     TH1::FillRandom can be used to randomly fill an histogram using
                    the contents of an existing TF1 function or another
                    TH1 histogram (for all dimensions).
<p>     For example the following two statements create and fill an histogram
     10000 times with a default gaussian distribution of mean 0 and sigma 1:
<pre>
       TH1F h1("h1", "histo from a gaussian", 100, -3, 3);
       h1.FillRandom("gaus", 10000);
</pre>
     TH1::GetRandom can be used to return a random number distributed
                    according the contents of an histogram.
<h4>Making a copy of an histogram</h4>
     Like for any other ROOT object derived from TObject, one can use
     the Clone() function. This makes an identical copy of the original
     histogram including all associated errors and functions, e.g.:
<pre>
       TH1F *hnew = (TH1F*)h->Clone("hnew");
</pre>
<h4>Normalizing histograms</h4>
     One can scale an histogram such that the bins integral is equal to
     the normalization parameter via TH1::Scale(Double_t norm), where norm
     is the desired normalization divided by the integral of the histogram.
<h4>Drawing histograms</h4>
     Histograms are drawn via the THistPainter class. Each histogram has
     a pointer to its own painter (to be usable in a multithreaded program).
     Many drawing options are supported.
     See THistPainter::Paint() for more details.
<p>
    The same histogram can be drawn with different options in different pads.
     When an histogram drawn in a pad is deleted, the histogram is
     automatically removed from the pad or pads where it was drawn.
     If an histogram is drawn in a pad, then filled again, the new status
     of the histogram will be automatically shown in the pad next time
     the pad is updated. One does not need to redraw the histogram.
     To draw the current version of an histogram in a pad, one can use
<pre>
        h->DrawCopy();
</pre>
     This makes a clone (see Clone below) of the histogram. Once the clone
     is drawn, the original histogram may be modified or deleted without
     affecting the aspect of the clone.
<p>
     One can use TH1::SetMaximum() and TH1::SetMinimum() to force a particular
     value for the maximum or the minimum scale on the plot. (For 1-D
     histograms this means the y-axis, while for 2-D histograms these
     functions affect the z-axis).
<p>
     TH1::UseCurrentStyle() can be used to change all histogram graphics
     attributes to correspond to the current selected style.
     This function must be called for each histogram.
     In case one reads and draws many histograms from a file, one can force
     the histograms to inherit automatically the current graphics style
     by calling before gROOT->ForceStyle().
<h4>Setting Drawing histogram contour levels (2-D hists only)</h4>
     By default contours are automatically generated at equidistant
     intervals. A default value of 20 levels is used. This can be modified
     via TH1::SetContour() or TH1::SetContourLevel().
     the contours level info is used by the drawing options "cont", "surf",
     and "lego".
<h4>Setting histogram graphics attributes</h4>
     The histogram classes inherit from the attribute classes:
       TAttLine, TAttFill, and TAttMarker.
     See the member functions of these classes for the list of options.
<h4>Giving titles to the X, Y and Z axis</h4>
<pre>
       h->GetXaxis()->SetTitle("X axis title");
       h->GetYaxis()->SetTitle("Y axis title");
</pre>
     The histogram title and the axis titles can be any TLatex string.
     The titles are part of the persistent histogram.
     It is also possible to specify the histogram title and the axis
     titles at creation time. These titles can be given in the "title"
     parameter. They must be separated by ";":
<pre>
        TH1F* h=new TH1F("h", "Histogram title;X Axis;Y Axis;Z Axis", 100, 0, 1);
</pre>
     Any title can be omitted:
<pre>
        TH1F* h=new TH1F("h", "Histogram title;;Y Axis", 100, 0, 1);
        TH1F* h=new TH1F("h", ";;Y Axis", 100, 0, 1);
</pre>
     The method SetTitle has the same syntax:
<pre>
</pre>
        h->SetTitle("Histogram title;Another X title Axis");
<h4>Saving/Reading histograms to/from a ROOT file</h4>
     The following statements create a ROOT file and store an histogram
     on the file. Because TH1 derives from TNamed, the key identifier on
     the file is the histogram name:
<pre>
        TFile f("histos.root", "new");
        TH1F h1("hgaus", "histo from a gaussian", 100, -3, 3);
        h1.FillRandom("gaus", 10000);
        h1->Write();
</pre>
     To read this histogram in another Root session, do:
<pre>
        TFile f("histos.root");
        TH1F *h = (TH1F*)f.Get("hgaus");
</pre>
     One can save all histograms in memory to the file by:
<pre>
        file->Write();
</pre>
<h4>Miscelaneous operations</h4>
<pre>
        TH1::KolmogorovTest(): statistical test of compatibility in shape
                             between two histograms
        TH1::Smooth() smooths the bin contents of a 1-d histogram
        TH1::Integral() returns the integral of bin contents in a given bin range
        TH1::GetMean(int axis) returns the mean value along axis
        TH1::GetRMS(int axis)  returns the sigma distribution along axis
        TH1::GetEntries() returns the number of entries
        TH1::Reset() resets the bin contents and errors of an histogram
</pre>
<!-- TDocHtmlDirective end --><pre> 
</pre></div>
</div></div>

<div id="functions">
<h2><a id="TH1:Function_Members"></a>Function Members (Methods)</h2>
<div class="access" id="funcpubl"><b>public:</b>
<table class="func" id="tabfuncpubl" cellspacing="0">
<tr class="func"><td class="funcret"></td><td class="funcname"><a class="funcname" href="#TH1:TH1%4">TH1</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>&amp;)</td></tr>
<tr class="func"><td class="funcret"> virtual</td><td class="funcname"><a class="funcname" href="#TH1:_TH1">~TH1</a>()</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:AbstractMethod"><span class="baseclass">TObject::</span>AbstractMethod</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Add%1">Add</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h1, <a href="./ListOfTypes.html#Double_t">Double_t</a> c1 = 1)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Add">Add</a>(<a href="./TF1.html">TF1</a>* h1, <a href="./ListOfTypes.html#Double_t">Double_t</a> c1 = 1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Add%2">Add</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h, <span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h2, <a href="./ListOfTypes.html#Double_t">Double_t</a> c1 = 1, <a href="./ListOfTypes.html#Double_t">Double_t</a> c2 = 1)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:AddBinContent">AddBinContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:AddBinContent%1">AddBinContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin, <a href="./ListOfTypes.html#Double_t">Double_t</a> w)</td></tr>
<tr class="func"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:AddDirectory">AddDirectory</a>(<a href="./ListOfTypes.html#Bool_t">Bool_t</a> add = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</td></tr>
<tr class="func"><td class="funcret">static <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TH1:AddDirectoryStatus">AddDirectoryStatus</a>()</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:AppendPad"><span class="baseclass">TObject::</span>AppendPad</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Browse">Browse</a>(<a href="./TBrowser.html">TBrowser</a>* b)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:BufferEmpty">BufferEmpty</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> action = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:Chi2Test">Chi2Test</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h2, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">"UU"</span>, <a href="./ListOfTypes.html#Double_t">Double_t</a>* res = 0) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:Chi2TestX">Chi2TestX</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h2, <a href="./ListOfTypes.html#Double_t">Double_t</a>&amp; chi2, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; ndf, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; igood, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">"UU"</span>, <a href="./ListOfTypes.html#Double_t">Double_t</a>* res = 0) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">static <a href="./TClass.html">TClass</a>*</td><td class="funcname"><a class="funcname" href="#TH1:Class">Class</a>()</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">const</span> <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:ClassName"><span class="baseclass">TObject::</span>ClassName</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:Clear"><span class="baseclass">TNamed::</span>Clear</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./TObject.html">TObject</a>*</td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:Clone"><span class="baseclass">TNamed::</span>Clone</a>(<span class="keyword">const</span> <span class="keyword">char</span>* newname = <span class="string">""</span>) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:Compare"><span class="baseclass">TNamed::</span>Compare</a>(<span class="keyword">const</span> <a href="./TObject.html">TObject</a>* obj) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:ComputeIntegral">ComputeIntegral</a>()</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Delete"><span class="baseclass">TObject::</span>Delete</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:DirectoryAutoAdd">DirectoryAutoAdd</a>(<a href="./TDirectory.html">TDirectory</a>*)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:DistancetoLine"><span class="baseclass">TAttLine::</span>DistancetoLine</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> px, <a href="./ListOfTypes.html#Int_t">Int_t</a> py, <a href="./ListOfTypes.html#Double_t">Double_t</a> xp1, <a href="./ListOfTypes.html#Double_t">Double_t</a> yp1, <a href="./ListOfTypes.html#Double_t">Double_t</a> xp2, <a href="./ListOfTypes.html#Double_t">Double_t</a> yp2)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:DistancetoPrimitive">DistancetoPrimitive</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> px, <a href="./ListOfTypes.html#Int_t">Int_t</a> py)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Divide%1">Divide</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h1)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Divide">Divide</a>(<a href="./TF1.html">TF1</a>* f1, <a href="./ListOfTypes.html#Double_t">Double_t</a> c1 = 1)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Divide%2">Divide</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h1, <span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h2, <a href="./ListOfTypes.html#Double_t">Double_t</a> c1 = 1, <a href="./ListOfTypes.html#Double_t">Double_t</a> c2 = 1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Draw">Draw</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:DrawClass"><span class="baseclass">TObject::</span>DrawClass</a>() <span class="keyword">const</span><span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./TObject.html">TObject</a>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:DrawClone"><span class="baseclass">TObject::</span>DrawClone</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) <span class="keyword">const</span><span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TH1.html">TH1</a>*</td><td class="funcname"><a class="funcname" href="#TH1:DrawCopy">DrawCopy</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TH1.html">TH1</a>*</td><td class="funcname"><a class="funcname" href="#TH1:DrawNormalized">DrawNormalized</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Double_t">Double_t</a> norm = 1) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:DrawPanel">DrawPanel</a>()<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Dump"><span class="baseclass">TObject::</span>Dump</a>() <span class="keyword">const</span><span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Error"><span class="baseclass">TObject::</span>Error</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* msgfmt) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Eval">Eval</a>(<a href="./TF1.html">TF1</a>* f1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Execute"><span class="baseclass">TObject::</span>Execute</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* params, <a href="./ListOfTypes.html#Int_t">Int_t</a>* error = 0)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Execute%1"><span class="baseclass">TObject::</span>Execute</a>(<a href="./TMethod.html">TMethod</a>* method, <a href="./TObjArray.html">TObjArray</a>* params, <a href="./ListOfTypes.html#Int_t">Int_t</a>* error = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:ExecuteEvent">ExecuteEvent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> event, <a href="./ListOfTypes.html#Int_t">Int_t</a> px, <a href="./ListOfTypes.html#Int_t">Int_t</a> py)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Fatal"><span class="baseclass">TObject::</span>Fatal</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* msgfmt) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TH1.html">TH1</a>*</td><td class="funcname"><a class="funcname" href="#TH1:FFT">FFT</a>(<a href="./TH1.html">TH1</a>* h_output, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:Fill">Fill</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> x)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:Fill%1">Fill</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> x, <a href="./ListOfTypes.html#Double_t">Double_t</a> w)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:Fill%2">Fill</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <a href="./ListOfTypes.html#Double_t">Double_t</a> w)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:FillBuffer"><span class="baseclass">TNamed::</span>FillBuffer</a>(<span class="keyword">char</span>*&amp; buffer)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:FillN">FillN</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> ntimes, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* x, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* w, <a href="./ListOfTypes.html#Int_t">Int_t</a> stride = 1)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:FillN%1">FillN</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a>, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>*, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>*, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>*, <a href="./ListOfTypes.html#Int_t">Int_t</a>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:FillRandom">FillRandom</a>(<span class="keyword">const</span> <span class="keyword">char</span>* fname, <a href="./ListOfTypes.html#Int_t">Int_t</a> ntimes = 5000)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:FillRandom%1">FillRandom</a>(<a href="./TH1.html">TH1</a>* h, <a href="./ListOfTypes.html#Int_t">Int_t</a> ntimes = 5000)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:FindBin">FindBin</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> x, <a href="./ListOfTypes.html#Double_t">Double_t</a> y = 0, <a href="./ListOfTypes.html#Double_t">Double_t</a> z = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:FindFirstBinAbove">FindFirstBinAbove</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> threshold = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> axis = 1) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:FindFixBin">FindFixBin</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> x, <a href="./ListOfTypes.html#Double_t">Double_t</a> y = 0, <a href="./ListOfTypes.html#Double_t">Double_t</a> z = 0) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:FindLastBinAbove">FindLastBinAbove</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> threshold = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> axis = 1) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TObject.html">TObject</a>*</td><td class="funcname"><a class="funcname" href="#TH1:FindObject">FindObject</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TObject.html">TObject</a>*</td><td class="funcname"><a class="funcname" href="#TH1:FindObject%1">FindObject</a>(<span class="keyword">const</span> <a href="./TObject.html">TObject</a>* obj) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TFitResultPtr.html">TFitResultPtr</a></td><td class="funcname"><a class="funcname" href="#TH1:Fit">Fit</a>(<span class="keyword">const</span> <span class="keyword">char</span>* formula, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* goption = <span class="string">""</span>, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmin = 0, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmax = 0)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TFitResultPtr.html">TFitResultPtr</a></td><td class="funcname"><a class="funcname" href="#TH1:Fit%1">Fit</a>(<a href="./TF1.html">TF1</a>* f1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* goption = <span class="string">""</span>, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmin = 0, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmax = 0)</td></tr>
<tr class="func"><td class="funcret">static <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:FitOptionsMake">FitOptionsMake</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option, <a href="./Foption_t.html">Foption_t</a>&amp; Foption)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:FitPanel">FitPanel</a>()<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret"><a href="./TH1.html">TH1</a>*</td><td class="funcname"><a class="funcname" href="#TH1:GetAsymmetry">GetAsymmetry</a>(<a href="./TH1.html">TH1</a>* h2, <a href="./ListOfTypes.html#Double_t">Double_t</a> c2 = 1, <a href="./ListOfTypes.html#Double_t">Double_t</a> dc2 = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Color_t">Color_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetAxisColor">GetAxisColor</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Float_t">Float_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetBarOffset">GetBarOffset</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Float_t">Float_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetBarWidth">GetBarWidth</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetBin">GetBin</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> binz = 0) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetBinCenter">GetBinCenter</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetBinContent">GetBinContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetBinContent%1">GetBinContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetBinContent%2">GetBinContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny, <a href="./ListOfTypes.html#Int_t">Int_t</a> binz) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetBinError">GetBinError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetBinError%1">GetBinError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetBinError%2">GetBinError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny, <a href="./ListOfTypes.html#Int_t">Int_t</a> binz) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetBinLowEdge">GetBinLowEdge</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetBinWidth">GetBinWidth</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetBinWithContent">GetBinWithContent</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> c, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> firstx = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> lastx = 0, <a href="./ListOfTypes.html#Double_t">Double_t</a> maxdiff = 0) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:GetBinXYZ">GetBinXYZ</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binglobal, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; binx, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; biny, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; binz) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>*</td><td class="funcname"><a class="funcname" href="#TH1:GetBuffer">GetBuffer</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetBufferLength">GetBufferLength</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetBufferSize">GetBufferSize</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetCellContent">GetCellContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetCellError">GetCellError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:GetCenter">GetCenter</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a>* center) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetContour">GetContour</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a>* levels = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetContourLevel">GetContourLevel</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> level) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetContourLevelPad">GetContourLevelPad</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> level) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">static <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetDefaultBufferSize">GetDefaultBufferSize</a>()</td></tr>
<tr class="func"><td class="funcret">static <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetDefaultSumw2">GetDefaultSumw2</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetDimension">GetDimension</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./TDirectory.html">TDirectory</a>*</td><td class="funcname"><a class="funcname" href="#TH1:GetDirectory">GetDirectory</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Option_t">Option_t</a>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:GetDrawOption"><span class="baseclass">TObject::</span>GetDrawOption</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">static <a href="./ListOfTypes.html#Long_t">Long_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:GetDtorOnly"><span class="baseclass">TObject::</span>GetDtorOnly</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetEffectiveEntries">GetEffectiveEntries</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetEntries">GetEntries</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Color_t">Color_t</a></td><td class="funcname"><a class="funcname" href="./TAttFill.html#TAttFill:GetFillColor"><span class="baseclass">TAttFill::</span>GetFillColor</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Style_t">Style_t</a></td><td class="funcname"><a class="funcname" href="./TAttFill.html#TAttFill:GetFillStyle"><span class="baseclass">TAttFill::</span>GetFillStyle</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TF1.html">TF1</a>*</td><td class="funcname"><a class="funcname" href="#TH1:GetFunction">GetFunction</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">const</span> <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:GetIconName"><span class="baseclass">TObject::</span>GetIconName</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a>*</td><td class="funcname"><a class="funcname" href="#TH1:GetIntegral">GetIntegral</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetKurtosis">GetKurtosis</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> axis = 1) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Color_t">Color_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetLabelColor">GetLabelColor</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Style_t">Style_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetLabelFont">GetLabelFont</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Float_t">Float_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetLabelOffset">GetLabelOffset</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Float_t">Float_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetLabelSize">GetLabelSize</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Color_t">Color_t</a></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:GetLineColor"><span class="baseclass">TAttLine::</span>GetLineColor</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Style_t">Style_t</a></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:GetLineStyle"><span class="baseclass">TAttLine::</span>GetLineStyle</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Width_t">Width_t</a></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:GetLineWidth"><span class="baseclass">TAttLine::</span>GetLineWidth</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./TList.html">TList</a>*</td><td class="funcname"><a class="funcname" href="#TH1:GetListOfFunctions">GetListOfFunctions</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:GetLowEdge">GetLowEdge</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a>* edge) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Color_t">Color_t</a></td><td class="funcname"><a class="funcname" href="./TAttMarker.html#TAttMarker:GetMarkerColor"><span class="baseclass">TAttMarker::</span>GetMarkerColor</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Size_t">Size_t</a></td><td class="funcname"><a class="funcname" href="./TAttMarker.html#TAttMarker:GetMarkerSize"><span class="baseclass">TAttMarker::</span>GetMarkerSize</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Style_t">Style_t</a></td><td class="funcname"><a class="funcname" href="./TAttMarker.html#TAttMarker:GetMarkerStyle"><span class="baseclass">TAttMarker::</span>GetMarkerStyle</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetMaximum">GetMaximum</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> maxval = FLT_MAX) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetMaximumBin">GetMaximumBin</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetMaximumBin%1">GetMaximumBin</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; locmax, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; locmay, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; locmaz) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetMaximumStored">GetMaximumStored</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetMean">GetMean</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> axis = 1) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetMeanError">GetMeanError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> axis = 1) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetMinimum">GetMinimum</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> minval = -FLT_MAX) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetMinimumBin">GetMinimumBin</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetMinimumBin%1">GetMinimumBin</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; locmix, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; locmiy, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; locmiz) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetMinimumStored">GetMinimumStored</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">const</span> <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:GetName"><span class="baseclass">TNamed::</span>GetName</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetNbinsX">GetNbinsX</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetNbinsY">GetNbinsY</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetNbinsZ">GetNbinsZ</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetNdivisions">GetNdivisions</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetNormFactor">GetNormFactor</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="#TH1:GetObjectInfo">GetObjectInfo</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> px, <a href="./ListOfTypes.html#Int_t">Int_t</a> py) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">static <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:GetObjectStat"><span class="baseclass">TObject::</span>GetObjectStat</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Option_t">Option_t</a>*</td><td class="funcname"><a class="funcname" href="#TH1:GetOption">GetOption</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./TVirtualHistPainter.html">TVirtualHistPainter</a>*</td><td class="funcname"><a class="funcname" href="#TH1:GetPainter">GetPainter</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetQuantiles">GetQuantiles</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nprobSum, <a href="./ListOfTypes.html#Double_t">Double_t</a>* q, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* probSum = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetRandom">GetRandom</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetRMS">GetRMS</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> axis = 1) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetRMSError">GetRMSError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> axis = 1) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetSkewness">GetSkewness</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> axis = 1) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:GetStats">GetStats</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a>* stats) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetSumOfWeights">GetSumOfWeights</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TArrayD.html">TArrayD</a>*</td><td class="funcname"><a class="funcname" href="#TH1:GetSumw2">GetSumw2</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">const</span> <a href="./TArrayD.html">TArrayD</a>*</td><td class="funcname"><a class="funcname" href="#TH1:GetSumw2%1">GetSumw2</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetSumw2N">GetSumw2N</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Float_t">Float_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetTickLength">GetTickLength</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">const</span> <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:GetTitle"><span class="baseclass">TNamed::</span>GetTitle</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Style_t">Style_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetTitleFont">GetTitleFont</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Float_t">Float_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetTitleOffset">GetTitleOffset</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Float_t">Float_t</a></td><td class="funcname"><a class="funcname" href="#TH1:GetTitleSize">GetTitleSize</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#UInt_t">UInt_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:GetUniqueID"><span class="baseclass">TObject::</span>GetUniqueID</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./TAxis.html">TAxis</a>*</td><td class="funcname"><a class="funcname" href="#TH1:GetXaxis">GetXaxis</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./TAxis.html">TAxis</a>*</td><td class="funcname"><a class="funcname" href="#TH1:GetYaxis">GetYaxis</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./TAxis.html">TAxis</a>*</td><td class="funcname"><a class="funcname" href="#TH1:GetZaxis">GetZaxis</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:HandleTimer"><span class="baseclass">TObject::</span>HandleTimer</a>(<a href="./TTimer.html">TTimer</a>* timer)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#ULong_t">ULong_t</a></td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:Hash"><span class="baseclass">TNamed::</span>Hash</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Info"><span class="baseclass">TObject::</span>Info</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* msgfmt) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:InheritsFrom"><span class="baseclass">TObject::</span>InheritsFrom</a>(<span class="keyword">const</span> <span class="keyword">char</span>* classname) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:InheritsFrom%1"><span class="baseclass">TObject::</span>InheritsFrom</a>(<span class="keyword">const</span> <a href="./TClass.html">TClass</a>* cl) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Inspect"><span class="baseclass">TObject::</span>Inspect</a>() <span class="keyword">const</span><span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:Integral">Integral</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:Integral%1">Integral</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx1, <a href="./ListOfTypes.html#Int_t">Int_t</a> binx2, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:IntegralAndError">IntegralAndError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx1, <a href="./ListOfTypes.html#Int_t">Int_t</a> binx2, <a href="./ListOfTypes.html#Double_t">Double_t</a>&amp; err, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:Interpolate">Interpolate</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> x)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:Interpolate%1">Interpolate</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> x, <a href="./ListOfTypes.html#Double_t">Double_t</a> y)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:Interpolate%2">Interpolate</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> x, <a href="./ListOfTypes.html#Double_t">Double_t</a> y, <a href="./ListOfTypes.html#Double_t">Double_t</a> z)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:InvertBit"><span class="baseclass">TObject::</span>InvertBit</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> f)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TClass.html">TClass</a>*</td><td class="funcname"><a class="funcname" href="#TH1:IsA">IsA</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TH1:IsBinOverflow">IsBinOverflow</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TH1:IsBinUnderflow">IsBinUnderflow</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:IsEqual"><span class="baseclass">TObject::</span>IsEqual</a>(<span class="keyword">const</span> <a href="./TObject.html">TObject</a>* obj) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:IsFolder"><span class="baseclass">TObject::</span>IsFolder</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:IsOnHeap"><span class="baseclass">TObject::</span>IsOnHeap</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:IsSortable"><span class="baseclass">TNamed::</span>IsSortable</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TAttFill.html#TAttFill:IsTransparent"><span class="baseclass">TAttFill::</span>IsTransparent</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:IsZombie"><span class="baseclass">TObject::</span>IsZombie</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:KolmogorovTest">KolmogorovTest</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h2, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:LabelsDeflate">LabelsDeflate</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:LabelsInflate">LabelsInflate</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:LabelsOption">LabelsOption</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">"h"</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:ls"><span class="baseclass">TNamed::</span>ls</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:MayNotUse"><span class="baseclass">TObject::</span>MayNotUse</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TH1:Merge">Merge</a>(<a href="./TCollection.html">TCollection</a>* list)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:Modify"><span class="baseclass">TAttLine::</span>Modify</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Multiply%1">Multiply</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h1)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Multiply">Multiply</a>(<a href="./TF1.html">TF1</a>* h1, <a href="./ListOfTypes.html#Double_t">Double_t</a> c1 = 1)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Multiply%2">Multiply</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h1, <span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h2, <a href="./ListOfTypes.html#Double_t">Double_t</a> c1 = 1, <a href="./ListOfTypes.html#Double_t">Double_t</a> c2 = 1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Notify"><span class="baseclass">TObject::</span>Notify</a>()</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Obsolete"><span class="baseclass">TObject::</span>Obsolete</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* asOfVers, <span class="keyword">const</span> <span class="keyword">char</span>* removedFromVers) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:operator_delete"><span class="baseclass">TObject::</span>operator delete</a>(<span class="keyword">void</span>* ptr)</td></tr>
<tr class="funcinh"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:operator_delete%1"><span class="baseclass">TObject::</span>operator delete</a>(<span class="keyword">void</span>* ptr, <span class="keyword">void</span>* vp)</td></tr>
<tr class="funcinh"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:operator_delete[]"><span class="baseclass">TObject::</span>operator delete[]</a>(<span class="keyword">void</span>* ptr)</td></tr>
<tr class="funcinh"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:operator_delete[]%1"><span class="baseclass">TObject::</span>operator delete[]</a>(<span class="keyword">void</span>* ptr, <span class="keyword">void</span>* vp)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:operator_new"><span class="baseclass">TObject::</span>operator new</a>(<a href="./ListOfTypes.html#size_t">size_t</a> sz)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:operator_new%1"><span class="baseclass">TObject::</span>operator new</a>(<a href="./ListOfTypes.html#size_t">size_t</a> sz, <span class="keyword">void</span>* vp)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:operator_new[]"><span class="baseclass">TObject::</span>operator new[]</a>(<a href="./ListOfTypes.html#size_t">size_t</a> sz)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:operator_new[]%1"><span class="baseclass">TObject::</span>operator new[]</a>(<a href="./ListOfTypes.html#size_t">size_t</a> sz, <span class="keyword">void</span>* vp)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Paint">Paint</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Pop"><span class="baseclass">TObject::</span>Pop</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Print">Print</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:PutStats">PutStats</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a>* stats)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Read"><span class="baseclass">TObject::</span>Read</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TH1.html">TH1</a>*</td><td class="funcname"><a class="funcname" href="#TH1:Rebin">Rebin</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> ngroup = 2, <span class="keyword">const</span> <span class="keyword">char</span>* newname = <span class="string">""</span>, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* xbins = 0)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:RebinAxis">RebinAxis</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> x, <a href="./TAxis.html">TAxis</a>* axis)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Rebuild">Rebuild</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:RecursiveRemove">RecursiveRemove</a>(<a href="./TObject.html">TObject</a>* obj)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Reset">Reset</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttFill.html#TAttFill:ResetAttFill"><span class="baseclass">TAttFill::</span>ResetAttFill</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:ResetAttLine"><span class="baseclass">TAttLine::</span>ResetAttLine</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttMarker.html#TAttMarker:ResetAttMarker"><span class="baseclass">TAttMarker::</span>ResetAttMarker</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* toption = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:ResetBit"><span class="baseclass">TObject::</span>ResetBit</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> f)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:ResetStats">ResetStats</a>()</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:SaveAs"><span class="baseclass">TObject::</span>SaveAs</a>(<span class="keyword">const</span> <span class="keyword">char</span>* filename = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) <span class="keyword">const</span><span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttFill.html#TAttFill:SaveFillAttributes"><span class="baseclass">TAttFill::</span>SaveFillAttributes</a>(<a href="./ListOfTypes.html#ostream">ostream</a>&amp; out, <span class="keyword">const</span> <span class="keyword">char</span>* name, <a href="./ListOfTypes.html#Int_t">Int_t</a> coldef = 1, <a href="./ListOfTypes.html#Int_t">Int_t</a> stydef = 1001)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:SaveLineAttributes"><span class="baseclass">TAttLine::</span>SaveLineAttributes</a>(<a href="./ListOfTypes.html#ostream">ostream</a>&amp; out, <span class="keyword">const</span> <span class="keyword">char</span>* name, <a href="./ListOfTypes.html#Int_t">Int_t</a> coldef = 1, <a href="./ListOfTypes.html#Int_t">Int_t</a> stydef = 1, <a href="./ListOfTypes.html#Int_t">Int_t</a> widdef = 1)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttMarker.html#TAttMarker:SaveMarkerAttributes"><span class="baseclass">TAttMarker::</span>SaveMarkerAttributes</a>(<a href="./ListOfTypes.html#ostream">ostream</a>&amp; out, <span class="keyword">const</span> <span class="keyword">char</span>* name, <a href="./ListOfTypes.html#Int_t">Int_t</a> coldef = 1, <a href="./ListOfTypes.html#Int_t">Int_t</a> stydef = 1, <a href="./ListOfTypes.html#Int_t">Int_t</a> sizdef = 1)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SavePrimitive">SavePrimitive</a>(<a href="./ListOfTypes.html#ostream">ostream</a>&amp; out, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Scale">Scale</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> c1 = 1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetAxisColor">SetAxisColor</a>(<a href="./ListOfTypes.html#Color_t">Color_t</a> color = 1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetAxisRange">SetAxisRange</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> xmin, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmax, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetBarOffset">SetBarOffset</a>(<a href="./ListOfTypes.html#Float_t">Float_t</a> offset = 0.25)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetBarWidth">SetBarWidth</a>(<a href="./ListOfTypes.html#Float_t">Float_t</a> width = 0.5)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetBinContent">SetBinContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin, <a href="./ListOfTypes.html#Double_t">Double_t</a> content)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetBinContent%1">SetBinContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny, <a href="./ListOfTypes.html#Double_t">Double_t</a> content)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetBinContent%2">SetBinContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny, <a href="./ListOfTypes.html#Int_t">Int_t</a> binz, <a href="./ListOfTypes.html#Double_t">Double_t</a> content)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetBinError">SetBinError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin, <a href="./ListOfTypes.html#Double_t">Double_t</a> error)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetBinError%1">SetBinError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny, <a href="./ListOfTypes.html#Double_t">Double_t</a> error)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetBinError%2">SetBinError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny, <a href="./ListOfTypes.html#Int_t">Int_t</a> binz, <a href="./ListOfTypes.html#Double_t">Double_t</a> error)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetBins%1">SetBins</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nx, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* xBins)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetBins">SetBins</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nx, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmin, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmax)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetBins%3">SetBins</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nx, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* xBins, <a href="./ListOfTypes.html#Int_t">Int_t</a> ny, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* yBins)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetBins%2">SetBins</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nx, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmin, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmax, <a href="./ListOfTypes.html#Int_t">Int_t</a> ny, <a href="./ListOfTypes.html#Double_t">Double_t</a> ymin, <a href="./ListOfTypes.html#Double_t">Double_t</a> ymax)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetBins%5">SetBins</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nx, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* xBins, <a href="./ListOfTypes.html#Int_t">Int_t</a> ny, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* yBins, <a href="./ListOfTypes.html#Int_t">Int_t</a> nz, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* zBins)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetBins%4">SetBins</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nx, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmin, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmax, <a href="./ListOfTypes.html#Int_t">Int_t</a> ny, <a href="./ListOfTypes.html#Double_t">Double_t</a> ymin, <a href="./ListOfTypes.html#Double_t">Double_t</a> ymax, <a href="./ListOfTypes.html#Int_t">Int_t</a> nz, <a href="./ListOfTypes.html#Double_t">Double_t</a> zmin, <a href="./ListOfTypes.html#Double_t">Double_t</a> zmax)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetBinsLength">SetBinsLength</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> = -1)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:SetBit%1"><span class="baseclass">TObject::</span>SetBit</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> f)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:SetBit"><span class="baseclass">TObject::</span>SetBit</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> f, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> set)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetBuffer">SetBuffer</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> buffersize, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetCellContent">SetCellContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny, <a href="./ListOfTypes.html#Double_t">Double_t</a> content)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetCellError">SetCellError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny, <a href="./ListOfTypes.html#Double_t">Double_t</a> content)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetContent">SetContent</a>(<span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* content)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetContour">SetContour</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nlevels, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* levels = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetContourLevel">SetContourLevel</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> level, <a href="./ListOfTypes.html#Double_t">Double_t</a> value)</td></tr>
<tr class="func"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetDefaultBufferSize">SetDefaultBufferSize</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> buffersize = 1000)</td></tr>
<tr class="func"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetDefaultSumw2">SetDefaultSumw2</a>(<a href="./ListOfTypes.html#Bool_t">Bool_t</a> sumw2 = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetDirectory">SetDirectory</a>(<a href="./TDirectory.html">TDirectory</a>* dir)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:SetDrawOption"><span class="baseclass">TObject::</span>SetDrawOption</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:SetDtorOnly"><span class="baseclass">TObject::</span>SetDtorOnly</a>(<span class="keyword">void</span>* obj)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetEntries">SetEntries</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> n)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetError">SetError</a>(<span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* error)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttFill.html#TAttFill:SetFillAttributes"><span class="baseclass">TAttFill::</span>SetFillAttributes</a>()<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttFill.html#TAttFill:SetFillColor"><span class="baseclass">TAttFill::</span>SetFillColor</a>(<a href="./ListOfTypes.html#Color_t">Color_t</a> fcolor)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttFill.html#TAttFill:SetFillStyle"><span class="baseclass">TAttFill::</span>SetFillStyle</a>(<a href="./ListOfTypes.html#Style_t">Style_t</a> fstyle)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetLabelColor">SetLabelColor</a>(<a href="./ListOfTypes.html#Color_t">Color_t</a> color = 1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetLabelFont">SetLabelFont</a>(<a href="./ListOfTypes.html#Style_t">Style_t</a> font = 62, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetLabelOffset">SetLabelOffset</a>(<a href="./ListOfTypes.html#Float_t">Float_t</a> offset = 0.005, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetLabelSize">SetLabelSize</a>(<a href="./ListOfTypes.html#Float_t">Float_t</a> size = 0.02, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:SetLineAttributes"><span class="baseclass">TAttLine::</span>SetLineAttributes</a>()<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:SetLineColor"><span class="baseclass">TAttLine::</span>SetLineColor</a>(<a href="./ListOfTypes.html#Color_t">Color_t</a> lcolor)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:SetLineStyle"><span class="baseclass">TAttLine::</span>SetLineStyle</a>(<a href="./ListOfTypes.html#Style_t">Style_t</a> lstyle)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:SetLineWidth"><span class="baseclass">TAttLine::</span>SetLineWidth</a>(<a href="./ListOfTypes.html#Width_t">Width_t</a> lwidth)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttMarker.html#TAttMarker:SetMarkerAttributes"><span class="baseclass">TAttMarker::</span>SetMarkerAttributes</a>()<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttMarker.html#TAttMarker:SetMarkerColor"><span class="baseclass">TAttMarker::</span>SetMarkerColor</a>(<a href="./ListOfTypes.html#Color_t">Color_t</a> tcolor = 1)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttMarker.html#TAttMarker:SetMarkerSize"><span class="baseclass">TAttMarker::</span>SetMarkerSize</a>(<a href="./ListOfTypes.html#Size_t">Size_t</a> msize = 1)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttMarker.html#TAttMarker:SetMarkerStyle"><span class="baseclass">TAttMarker::</span>SetMarkerStyle</a>(<a href="./ListOfTypes.html#Style_t">Style_t</a> mstyle = 1)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetMaximum">SetMaximum</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> maximum = -1111)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetMinimum">SetMinimum</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> minimum = -1111)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetName">SetName</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetNameTitle">SetNameTitle</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* title)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetNdivisions">SetNdivisions</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> n = 510, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetNormFactor">SetNormFactor</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> factor = 1)</td></tr>
<tr class="funcinh"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:SetObjectStat"><span class="baseclass">TObject::</span>SetObjectStat</a>(<a href="./ListOfTypes.html#Bool_t">Bool_t</a> stat)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetOption">SetOption</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">" "</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetStats">SetStats</a>(<a href="./ListOfTypes.html#Bool_t">Bool_t</a> stats = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetTickLength">SetTickLength</a>(<a href="./ListOfTypes.html#Float_t">Float_t</a> length = 0.02, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetTitle">SetTitle</a>(<span class="keyword">const</span> <span class="keyword">char</span>* title)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetTitleFont">SetTitleFont</a>(<a href="./ListOfTypes.html#Style_t">Style_t</a> font = 62, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetTitleOffset">SetTitleOffset</a>(<a href="./ListOfTypes.html#Float_t">Float_t</a> offset = 1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetTitleSize">SetTitleSize</a>(<a href="./ListOfTypes.html#Float_t">Float_t</a> size = 0.02, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:SetUniqueID"><span class="baseclass">TObject::</span>SetUniqueID</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> uid)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetXTitle">SetXTitle</a>(<span class="keyword">const</span> <span class="keyword">char</span>* title)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetYTitle">SetYTitle</a>(<span class="keyword">const</span> <span class="keyword">char</span>* title)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SetZTitle">SetZTitle</a>(<span class="keyword">const</span> <span class="keyword">char</span>* title)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TH1.html">TH1</a>*</td><td class="funcname"><a class="funcname" href="#TH1:ShowBackground">ShowBackground</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> niter = 20, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">"same"</span>)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:ShowMembers">ShowMembers</a>(<a href="./TMemberInspector.html">TMemberInspector</a>&amp; insp)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:ShowPeaks">ShowPeaks</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> sigma = 2, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Double_t">Double_t</a> threshold = 0.05)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:Sizeof"><span class="baseclass">TNamed::</span>Sizeof</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Smooth">Smooth</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> ntimes = 1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SmoothArray">SmoothArray</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> NN, <a href="./ListOfTypes.html#Double_t">Double_t</a>* XX, <a href="./ListOfTypes.html#Int_t">Int_t</a> ntimes = 1)</td></tr>
<tr class="func"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:StatOverflows">StatOverflows</a>(<a href="./ListOfTypes.html#Bool_t">Bool_t</a> flag = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Streamer">Streamer</a>(<a href="./TBuffer.html">TBuffer</a>&amp; b)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:StreamerNVirtual">StreamerNVirtual</a>(<a href="./TBuffer.html">TBuffer</a>&amp; b)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Sumw2">Sumw2</a>()</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:SysError"><span class="baseclass">TObject::</span>SysError</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* msgfmt) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:TestBit"><span class="baseclass">TObject::</span>TestBit</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> f) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:TestBits"><span class="baseclass">TObject::</span>TestBits</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> f) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">static <a href="./TH1.html">TH1</a>*</td><td class="funcname"><a class="funcname" href="#TH1:TransformHisto">TransformHisto</a>(<a href="./TVirtualFFT.html">TVirtualFFT</a>* fft, <a href="./TH1.html">TH1</a>* h_output, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:UseCurrentStyle">UseCurrentStyle</a>()</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Warning"><span class="baseclass">TObject::</span>Warning</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* msgfmt) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Write"><span class="baseclass">TObject::</span>Write</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> option = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 0)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Write%1"><span class="baseclass">TObject::</span>Write</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> option = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 0) <span class="keyword">const</span></td></tr>

</table></div>
<div class="access" id="funcprot"><b>protected:</b>
<table class="func" id="tabfuncprot" cellspacing="0">
<tr class="func"><td class="funcret"></td><td class="funcname"><a class="funcname" href="#TH1:TH1">TH1</a>()</td></tr>
<tr class="func"><td class="funcret"></td><td class="funcname"><a class="funcname" href="#TH1:TH1%2">TH1</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* title, <a href="./ListOfTypes.html#Int_t">Int_t</a> nbinsx, <span class="keyword">const</span> <a href="./ListOfTypes.html#Float_t">Float_t</a>* xbins)</td></tr>
<tr class="func"><td class="funcret"></td><td class="funcname"><a class="funcname" href="#TH1:TH1%3">TH1</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* title, <a href="./ListOfTypes.html#Int_t">Int_t</a> nbinsx, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* xbins)</td></tr>
<tr class="func"><td class="funcret"></td><td class="funcname"><a class="funcname" href="#TH1:TH1%1">TH1</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* title, <a href="./ListOfTypes.html#Int_t">Int_t</a> nbinsx, <a href="./ListOfTypes.html#Double_t">Double_t</a> xlow, <a href="./ListOfTypes.html#Double_t">Double_t</a> xup)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:BufferFill">BufferFill</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> x, <a href="./ListOfTypes.html#Double_t">Double_t</a> w)</td></tr>
<tr class="func"><td class="funcret">static <span class="keyword">bool</span></td><td class="funcname"><a class="funcname" href="#TH1:CheckAxisLimits">CheckAxisLimits</a>(<span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>* a1, <span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>* a2)</td></tr>
<tr class="func"><td class="funcret">static <span class="keyword">bool</span></td><td class="funcname"><a class="funcname" href="#TH1:CheckBinLimits">CheckBinLimits</a>(<span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>* a1, <span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>* a2)</td></tr>
<tr class="func"><td class="funcret">static <span class="keyword">bool</span></td><td class="funcname"><a class="funcname" href="#TH1:CheckConsistency">CheckConsistency</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h1, <span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h2)</td></tr>
<tr class="func"><td class="funcret">static <span class="keyword">bool</span></td><td class="funcname"><a class="funcname" href="#TH1:CheckConsistentSubAxes">CheckConsistentSubAxes</a>(<span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>* a1, <a href="./ListOfTypes.html#Int_t">Int_t</a> firstBin1, <a href="./ListOfTypes.html#Int_t">Int_t</a> lastBin1, <span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>* a2, <a href="./ListOfTypes.html#Int_t">Int_t</a> firstBin2 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> lastBin2 = 0)</td></tr>
<tr class="func"><td class="funcret">static <span class="keyword">bool</span></td><td class="funcname"><a class="funcname" href="#TH1:CheckEqualAxes">CheckEqualAxes</a>(<span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>* a1, <span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>* a2)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Copy">Copy</a>(<a href="./TObject.html">TObject</a>&amp; hnew) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:DoError"><span class="baseclass">TObject::</span>DoError</a>(<span class="keyword">int</span> level, <span class="keyword">const</span> <span class="keyword">char</span>* location, <span class="keyword">const</span> <span class="keyword">char</span>* fmt, va_list va) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TH1:DoIntegral">DoIntegral</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> ix1, <a href="./ListOfTypes.html#Int_t">Int_t</a> ix2, <a href="./ListOfTypes.html#Int_t">Int_t</a> iy1, <a href="./ListOfTypes.html#Int_t">Int_t</a> iy2, <a href="./ListOfTypes.html#Int_t">Int_t</a> iz1, <a href="./ListOfTypes.html#Int_t">Int_t</a> iz2, <a href="./ListOfTypes.html#Double_t">Double_t</a>&amp; err, <a href="./ListOfTypes.html#Option_t">Option_t</a>* opt, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> doerr = <a href="./ListOfTypes.html#Bool_t">kFALSE</a>) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TH1:FindNewAxisLimits">FindNewAxisLimits</a>(<span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>* axis, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a> point, <a href="./ListOfTypes.html#Double_t">Double_t</a>&amp; newMin, <a href="./ListOfTypes.html#Double_t">Double_t</a>&amp; newMax)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:MakeZombie"><span class="baseclass">TObject::</span>MakeZombie</a>()</td></tr>
<tr class="func"><td class="funcret">static <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TH1:RecomputeAxisLimits">RecomputeAxisLimits</a>(<a href="./TAxis.html">TAxis</a>&amp; destAxis, <span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>&amp; anAxis)</td></tr>
<tr class="func"><td class="funcret">static <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TH1:SameLimitsAndNBins">SameLimitsAndNBins</a>(<span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>&amp; axis1, <span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>&amp; axis2)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:SavePrimitiveHelp">SavePrimitiveHelp</a>(<a href="./ListOfTypes.html#ostream">ostream</a>&amp; out, <span class="keyword">const</span> <span class="keyword">char</span>* hname, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>

</table></div>
<div class="access" id="funcpriv"><b>private:</b>
<table class="func" id="tabfuncpriv" cellspacing="0">
<tr class="func"><td class="funcret"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TH1:AxisChoice">AxisChoice</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TH1:Build">Build</a>()</td></tr>
<tr class="func"><td class="funcret"><a href="./TH1.html">TH1</a>&amp;</td><td class="funcname"><a class="funcname" href="#TH1:operator_">operator=</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>&amp;)</td></tr>

</table></div>
</div>

<div id="datamembers">
<h2><a name="TH1:Data_Members"></a>Data Members</h2>
<div class="access" id="enumpubl"><b>public:</b>
<table class="data" id="tabenumpubl" cellspacing="0">
<tr class="data"><td class="datatype">enum  { </td><td class="dataname"><a name="TH1:kNoStats"></a>kNoStats</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TH1:kUserContour"></a>kUserContour</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TH1:kCanRebin"></a>kCanRebin</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TH1:kLogX"></a>kLogX</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TH1:kIsZoomed"></a>kIsZoomed</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TH1:kNoTitle"></a>kNoTitle</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TH1:kIsAverage"></a>kIsAverage</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TH1:kNstat"></a>kNstat</td><td></td></tr>
<tr class="data"><td class="datatype">};</td><td></td><td></td></tr>
<tr class="datainh"><td class="datatype">enum <span class="baseclass">TObject::</span>EStatusBits { </td><td class="dataname"><a href="./TObject.html#TObject:kCanDelete">kCanDelete</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kMustCleanup">kMustCleanup</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kObjInCanvas">kObjInCanvas</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kIsReferenced">kIsReferenced</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kHasUUID">kHasUUID</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kCannotPick">kCannotPick</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kNoContextMenu">kNoContextMenu</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kInvalidObject">kInvalidObject</a></td><td></td></tr>
<tr class="datainh"><td class="datatype">};</td><td></td><td></td></tr>
<tr class="datainh"><td class="datatype">enum <span class="baseclass">TObject::</span><i>[unnamed]</i> { </td><td class="dataname"><a href="./TObject.html#TObject:kIsOnHeap">kIsOnHeap</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kNotDeleted">kNotDeleted</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kZombie">kZombie</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kBitMask">kBitMask</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kSingleKey">kSingleKey</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kOverwrite">kOverwrite</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kWriteDelete">kWriteDelete</a></td><td></td></tr>
<tr class="datainh"><td class="datatype">};</td><td></td><td></td></tr>

</table></div>
<div class="access" id="dataprot"><b>protected:</b>
<table class="data" id="tabdataprot" cellspacing="0">
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Short_t">Short_t</a></td><td class="dataname"><a name="TH1:fBarOffset"></a>fBarOffset</td><td class="datadesc">(1000*offset) for bar charts or legos</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Short_t">Short_t</a></td><td class="dataname"><a name="TH1:fBarWidth"></a>fBarWidth</td><td class="datadesc">(1000*width) for bar charts or legos</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Double_t">Double_t</a>*</td><td class="dataname"><a name="TH1:fBuffer"></a>fBuffer</td><td class="datadesc">[fBufferSize] entry buffer</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="dataname"><a name="TH1:fBufferSize"></a>fBufferSize</td><td class="datadesc">fBuffer size</td></tr>
<tr class="data"><td class="datatype"><a href="./TArrayD.html">TArrayD</a></td><td class="dataname"><a name="TH1:fContour"></a>fContour</td><td class="datadesc">Array to display contour levels</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="dataname"><a name="TH1:fDimension"></a>fDimension</td><td class="datadesc">!Histogram dimension (1, 2 or 3 dim)</td></tr>
<tr class="data"><td class="datatype"><a href="./TDirectory.html">TDirectory</a>*</td><td class="dataname"><a name="TH1:fDirectory"></a>fDirectory</td><td class="datadesc">!Pointer to directory holding this histogram</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="dataname"><a name="TH1:fEntries"></a>fEntries</td><td class="datadesc">Number of entries</td></tr>
<tr class="datainh"><td class="datatype"><a href="./ListOfTypes.html#Color_t">Color_t</a></td><td class="dataname"><a href="./TAttFill.html#TAttFill:fFillColor"><span class="baseclass">TAttFill::</span>fFillColor</a></td><td class="datadesc">fill area color</td></tr>
<tr class="datainh"><td class="datatype"><a href="./ListOfTypes.html#Style_t">Style_t</a></td><td class="dataname"><a href="./TAttFill.html#TAttFill:fFillStyle"><span class="baseclass">TAttFill::</span>fFillStyle</a></td><td class="datadesc">fill area style</td></tr>
<tr class="data"><td class="datatype"><a href="./TList.html">TList</a>*</td><td class="dataname"><a name="TH1:fFunctions"></a>fFunctions</td><td class="datadesc">-&gt;Pointer to list of functions (fits and user)</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Double_t">Double_t</a>*</td><td class="dataname"><a name="TH1:fIntegral"></a>fIntegral</td><td class="datadesc">!Integral of bins used by GetRandom</td></tr>
<tr class="datainh"><td class="datatype"><a href="./ListOfTypes.html#Color_t">Color_t</a></td><td class="dataname"><a href="./TAttLine.html#TAttLine:fLineColor"><span class="baseclass">TAttLine::</span>fLineColor</a></td><td class="datadesc">line color</td></tr>
<tr class="datainh"><td class="datatype"><a href="./ListOfTypes.html#Style_t">Style_t</a></td><td class="dataname"><a href="./TAttLine.html#TAttLine:fLineStyle"><span class="baseclass">TAttLine::</span>fLineStyle</a></td><td class="datadesc">line style</td></tr>
<tr class="datainh"><td class="datatype"><a href="./ListOfTypes.html#Width_t">Width_t</a></td><td class="dataname"><a href="./TAttLine.html#TAttLine:fLineWidth"><span class="baseclass">TAttLine::</span>fLineWidth</a></td><td class="datadesc">line width</td></tr>
<tr class="datainh"><td class="datatype"><a href="./ListOfTypes.html#Color_t">Color_t</a></td><td class="dataname"><a href="./TAttMarker.html#TAttMarker:fMarkerColor"><span class="baseclass">TAttMarker::</span>fMarkerColor</a></td><td class="datadesc">Marker color index</td></tr>
<tr class="datainh"><td class="datatype"><a href="./ListOfTypes.html#Size_t">Size_t</a></td><td class="dataname"><a href="./TAttMarker.html#TAttMarker:fMarkerSize"><span class="baseclass">TAttMarker::</span>fMarkerSize</a></td><td class="datadesc">Marker size</td></tr>
<tr class="datainh"><td class="datatype"><a href="./ListOfTypes.html#Style_t">Style_t</a></td><td class="dataname"><a href="./TAttMarker.html#TAttMarker:fMarkerStyle"><span class="baseclass">TAttMarker::</span>fMarkerStyle</a></td><td class="datadesc">Marker style</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="dataname"><a name="TH1:fMaximum"></a>fMaximum</td><td class="datadesc">Maximum value for plotting</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="dataname"><a name="TH1:fMinimum"></a>fMinimum</td><td class="datadesc">Minimum value for plotting</td></tr>
<tr class="datainh"><td class="datatype"><a href="./TString.html">TString</a></td><td class="dataname"><a href="./TNamed.html#TNamed:fName"><span class="baseclass">TNamed::</span>fName</a></td><td class="datadesc">object identifier</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="dataname"><a name="TH1:fNcells"></a>fNcells</td><td class="datadesc">number of bins(1D), cells (2D) +U/Overflows</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="dataname"><a name="TH1:fNormFactor"></a>fNormFactor</td><td class="datadesc">Normalization factor</td></tr>
<tr class="data"><td class="datatype"><a href="./TString.html">TString</a></td><td class="dataname"><a name="TH1:fOption"></a>fOption</td><td class="datadesc">histogram options</td></tr>
<tr class="data"><td class="datatype"><a href="./TVirtualHistPainter.html">TVirtualHistPainter</a>*</td><td class="dataname"><a name="TH1:fPainter"></a>fPainter</td><td class="datadesc">!pointer to histogram painter</td></tr>
<tr class="data"><td class="datatype"><a href="./TArrayD.html">TArrayD</a></td><td class="dataname"><a name="TH1:fSumw2"></a>fSumw2</td><td class="datadesc">Array of sum of squares of weights</td></tr>
<tr class="datainh"><td class="datatype"><a href="./TString.html">TString</a></td><td class="dataname"><a href="./TNamed.html#TNamed:fTitle"><span class="baseclass">TNamed::</span>fTitle</a></td><td class="datadesc">object title</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="dataname"><a name="TH1:fTsumw"></a>fTsumw</td><td class="datadesc">Total Sum of weights</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="dataname"><a name="TH1:fTsumw2"></a>fTsumw2</td><td class="datadesc">Total Sum of squares of weights</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="dataname"><a name="TH1:fTsumwx"></a>fTsumwx</td><td class="datadesc">Total Sum of weight*X</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="dataname"><a name="TH1:fTsumwx2"></a>fTsumwx2</td><td class="datadesc">Total Sum of weight*X*X</td></tr>
<tr class="data"><td class="datatype"><a href="./TAxis.html">TAxis</a></td><td class="dataname"><a name="TH1:fXaxis"></a>fXaxis</td><td class="datadesc">X axis descriptor</td></tr>
<tr class="data"><td class="datatype"><a href="./TAxis.html">TAxis</a></td><td class="dataname"><a name="TH1:fYaxis"></a>fYaxis</td><td class="datadesc">Y axis descriptor</td></tr>
<tr class="data"><td class="datatype"><a href="./TAxis.html">TAxis</a></td><td class="dataname"><a name="TH1:fZaxis"></a>fZaxis</td><td class="datadesc">Z axis descriptor</td></tr>
<tr class="data"><td class="datatype">static <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="dataname"><a name="TH1:fgAddDirectory"></a>fgAddDirectory</td><td class="datadesc">!flag to add histograms to the directory</td></tr>
<tr class="data"><td class="datatype">static <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="dataname"><a name="TH1:fgBufferSize"></a>fgBufferSize</td><td class="datadesc">!default buffer size for automatic histograms</td></tr>
<tr class="data"><td class="datatype">static <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="dataname"><a name="TH1:fgDefaultSumw2"></a>fgDefaultSumw2</td><td class="datadesc">!flag to call TH1::Sumw2 automatically at histogram creation time</td></tr>
<tr class="data"><td class="datatype">static <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="dataname"><a name="TH1:fgStatOverflows"></a>fgStatOverflows</td><td class="datadesc">!flag to use under/overflows in statistics</td></tr>

</table></div>
</div>
<h2><a id="TH1:Class_Charts"></a>Class Charts</h2>
<map name="MapTH1_Inh" id="MapTH1_Inh">
<area shape="rect" href="./TNamed.html" title="TNamed" alt="" coords="147,80,197,94"/>
<area shape="rect" href="./TAttLine.html" title="TAttLine" alt="" coords="148,96,196,110"/>
<area shape="rect" href="./TAttFill.html" title="TAttFill" alt="" coords="153,112,192,126"/>
<area shape="rect" href="./TAttMarker.html" title="TAttMarker" alt="" coords="140,129,204,143"/>
<area shape="rect" href="./TObject.html" title="TObject" alt="" coords="21,80,67,94"/>
<area shape="rect" href="./TH3.html" title="TH3" alt="" coords="417,39,441,53"/>
<area shape="rect" href="./TH1C.html" title="TH1C" alt="" coords="413,63,445,77"/>
<area shape="rect" href="./TH1D.html" title="TH1D" alt="" coords="413,80,445,94"/>
<area shape="rect" href="./TH1F.html" title="TH1F" alt="" coords="414,96,444,110"/>
<area shape="rect" href="./TH1I.html" title="TH1I" alt="" coords="415,112,443,126"/>
<area shape="rect" href="./TH1K.html" title="TH1K" alt="" coords="413,129,445,143"/>
<area shape="rect" href="./TH1S.html" title="TH1S" alt="" coords="413,145,444,159"/>
<area shape="rect" href="./TH2.html" title="TH2" alt="" coords="417,161,441,175"/>
<area shape="rect" href="./TH3C.html" title="TH3C" alt="" coords="541,2,573,16"/>
<area shape="rect" href="./TH2C.html" title="TH2C" alt="" coords="541,120,573,134"/>
<area shape="rect" href="./TH2D.html" title="TH2D" alt="" coords="541,137,573,151"/>
<area shape="rect" href="./TH2F.html" title="TH2F" alt="" coords="542,153,572,167"/>
<area shape="rect" href="./TH2I.html" title="TH2I" alt="" coords="543,169,571,183"/>
<area shape="rect" href="./TH2Poly.html" title="TH2Poly" alt="" coords="533,186,581,200"/>
<area shape="rect" href="./TH2S.html" title="TH2S" alt="" coords="542,202,573,216"/>
<area shape="rect" href="./TH3D.html" title="TH3D" alt="" coords="541,19,573,33"/>
<area shape="rect" href="./TH3F.html" title="TH3F" alt="" coords="542,35,572,49"/>
<area shape="rect" href="./TH3I.html" title="TH3I" alt="" coords="543,51,571,65"/>
<area shape="rect" href="./TH3S.html" title="TH3S" alt="" coords="542,68,573,82"/>
<area shape="rect" href="./TProfile.html" title="TProfile" alt="" coords="535,84,579,98"/>
<area shape="rect" href="./TGLTH3Composition.html" title="TGLTH3Composition" alt="" coords="645,2,764,16"/>
<area shape="rect" href="./TProfile2D.html" title="TProfile2D" alt="" coords="674,137,735,151"/>
<area shape="rect" href="./TProfile3D.html" title="TProfile3D" alt="" coords="674,19,735,33"/>
</map>
<map name="MapTH1_InhMem" id="MapTH1_InhMem">
<area shape="rect" href="./TNamed.html" alt="" coords="344,60,629,109"/>
<area shape="rect" href="./TNamed.html" alt="" coords="541,120,629,297"/>
<area shape="rect" href="./TNamed.html" alt="" coords="443,120,531,297"/>
<area shape="rect" href="./TNamed.html" alt="" coords="344,120,432,297"/>
<area shape="rect" href="./TNamed.html" title="TNamed" alt="" coords="333,16,640,308"/>
<area shape="rect" href="./TAttLine.html" alt="" coords="541,376,629,440"/>
<area shape="rect" href="./TAttLine.html" alt="" coords="443,376,531,440"/>
<area shape="rect" href="./TAttLine.html" alt="" coords="376,376,400,411"/>
<area shape="rect" href="./TAttLine.html" alt="" coords="541,451,629,613"/>
<area shape="rect" href="./TAttLine.html" alt="" coords="443,451,531,613"/>
<area shape="rect" href="./TAttLine.html" alt="" coords="344,451,432,613"/>
<area shape="rect" href="./TAttLine.html" title="TAttLine" alt="" coords="333,332,640,624"/>
<area shape="rect" href="./TAttFill.html" alt="" coords="344,704,629,753"/>
<area shape="rect" href="./TAttFill.html" alt="" coords="541,764,629,897"/>
<area shape="rect" href="./TAttFill.html" alt="" coords="443,764,531,927"/>
<area shape="rect" href="./TAttFill.html" alt="" coords="344,764,432,927"/>
<area shape="rect" href="./TAttFill.html" title="TAttFill" alt="" coords="333,660,640,937"/>
<area shape="rect" href="./TAttMarker.html" alt="" coords="541,1044,629,1108"/>
<area shape="rect" href="./TAttMarker.html" alt="" coords="443,1044,531,1108"/>
<area shape="rect" href="./TAttMarker.html" alt="" coords="376,1044,400,1079"/>
<area shape="rect" href="./TAttMarker.html" alt="" coords="541,1119,629,1267"/>
<area shape="rect" href="./TAttMarker.html" alt="" coords="443,1119,531,1281"/>
<area shape="rect" href="./TAttMarker.html" alt="" coords="344,1119,432,1281"/>
<area shape="rect" href="./TAttMarker.html" title="TAttMarker" alt="" coords="333,1000,640,1292"/>
<area shape="rect" href="./TObject.html" alt="" coords="224,60,312,183"/>
<area shape="rect" href="./TObject.html" alt="" coords="125,60,213,197"/>
<area shape="rect" href="./TObject.html" alt="" coords="27,60,115,197"/>
<area shape="rect" href="./TObject.html" alt="" coords="256,193,280,228"/>
<area shape="rect" href="./TObject.html" alt="" coords="224,239,312,665"/>
<area shape="rect" href="./TObject.html" alt="" coords="125,224,213,665"/>
<area shape="rect" href="./TObject.html" alt="" coords="27,224,115,665"/>
<area shape="rect" href="./TObject.html" title="TObject" alt="" coords="16,16,323,676"/>
</map>
<map name="MapTH1_Lib" id="MapTH1_Lib">
<area shape="rect" href="LibraryDependencies.html" title="All Libraries" alt="" coords="433,121,561,169"/>
</map>
<div class="tabs">
<a id="imgTH1_Inh" class="tabsel" href="inh/TH1_Inh.png" onclick="javascript:return SetImg('Charts','inh/TH1_Inh.png');">Inheritance</a>
<a id="imgTH1_InhMem" class="tab" href="inhmem/TH1_InhMem.png" onclick="javascript:return SetImg('Charts','inhmem/TH1_InhMem.png');">Inherited Members</a>
<a id="imgTH1_Incl" class="tab" href="incl/TH1_Incl.png" onclick="javascript:return SetImg('Charts','incl/TH1_Incl.png');">Includes</a>
<a id="imgTH1_Lib" class="tab" href="lib/TH1_Lib.png" onclick="javascript:return SetImg('Charts','lib/TH1_Lib.png');">Libraries</a><br/>
</div><div class="classcharts"><div class="classchartswidth"></div>
<img id="Charts" alt="Class Charts" class="classcharts" usemap="#MapTH1_Inh" src="inh/TH1_Inh.png"/></div>
<h2>Function documentation</h2>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="TH1:TH1" href="src/TH1.cxx.html#JiD2B">TH1</a>()</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*-*-*Histogram default constructor*-*-*-*-*-*-*-*-*-*-*-*-*

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="TH1:_TH1" href="src/TH1.cxx.html#URsg.D">~TH1</a>()</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*-*-*Histogram default destructor*-*-*-*-*-*-*-*-*-*-*-*-*-*

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="TH1:TH1%1" href="src/TH1.cxx.html#MI_3yC">TH1</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* title, <a href="./ListOfTypes.html#Int_t">Int_t</a> nbinsx, <a href="./ListOfTypes.html#Double_t">Double_t</a> xlow, <a href="./ListOfTypes.html#Double_t">Double_t</a> xup)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*Normal constructor for fix bin size histograms*-*-*-*-*-*-*


     Creates the main histogram structure:
        name   : name of histogram (avoid blanks)
        title  : histogram title
                 if title is of the form <span class="string">"stringt;stringx;stringy;stringz"</span>
                 the histogram title is set to stringt,
                 the x axis title to stringy, the y axis title to stringy, etc.
        nbins  : number of bins
        xlow   : low edge of first bin
        xup    : upper edge of last bin (not included in last bin)

      When an histogram is created, it is automatically added to the list
      of special objects in the current directory.
      To find the pointer to this histogram in the current directory
      by its name, do:
      <a href="./TH1F.html">TH1F</a> *h1 = (<a href="./TH1F.html">TH1F</a>*)gDirectory-&gt;<a href="./TH1.html#TH1:FindObject" title="TObject* TH1::FindObject(const char* name) or overloads">FindObject</a>(name);

   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="TH1:TH1%2" href="src/TH1.cxx.html#liNmOB">TH1</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* title, <a href="./ListOfTypes.html#Int_t">Int_t</a> nbinsx, <span class="keyword">const</span> <a href="./ListOfTypes.html#Float_t">Float_t</a>* xbins)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*


  Creates the main histogram structure:
     name   : name of histogram (avoid blanks)
     title  : histogram title
              if title is of the form <span class="string">"stringt;stringx;stringy;stringz"</span>
              the histogram title is set to stringt,
              the x axis title to stringx, the y axis title to stringy, etc.
     nbins  : number of bins
     xbins  : array of low-edges for each bin
              This is an array of size nbins+1

   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="TH1:TH1%3" href="src/TH1.cxx.html#un4TiD">TH1</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* title, <a href="./ListOfTypes.html#Int_t">Int_t</a> nbinsx, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* xbins)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*


  Creates the main histogram structure:
     name   : name of histogram (avoid blanks)
     title  : histogram title
              if title is of the form <span class="string">"stringt;stringx;stringy;stringz"</span>
              the histogram title is set to stringt,
              the x axis title to stringx, the y axis title to stringy, etc.
     nbins  : number of bins
     xbins  : array of low-edges for each bin
              This is an array of size nbins+1

   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="TH1:TH1%4" href="src/TH1.cxx.html#Wi6g_">TH1</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>&amp; )</span><br />
<div class="funccomm"><pre> <a href="./TH1.html#TH1:Copy" title="void TH1::Copy(TObject&amp; hnew)">Copy</a> constructor.
 The list of functions is not copied. (Use <a href="./TNamed.html#TNamed:Clone" title="TObject* TNamed::Clone(const char* newname=&quot;&quot;)">Clone</a> if needed)
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Bool_t">Bool_t</a> <a class="funcname" name="TH1:AddDirectoryStatus" href="src/TH1.cxx.html#kaD.hD">AddDirectoryStatus</a>()</span><br />
<div class="funccomm"><pre>static function: cannot be inlined on Windows/NT
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Browse" href="src/TH1.cxx.html#pASpwC">Browse</a>(<a href="./TBrowser.html">TBrowser</a>* b)</span><br />
<div class="funccomm"><pre> Browe the Histogram object.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Build" href="src/TH1.cxx.html#zm.A1E">Build</a>()</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*-*Creates histogram basic data structure*-*-*-*-*-*-*-*-*-*

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Add" href="src/TH1.cxx.html#jfGfKB">Add</a>(<a href="./TF1.html">TF1</a>* h1, <a href="./ListOfTypes.html#Double_t">Double_t</a> c1 = 1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre> Performs the operation: this = this + c1*f1
 if errors are defined (see <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>), errors are also recalculated.

 By default, the function is computed at the centre of the bin.
 if option <span class="string">"I"</span> is specified (1-d histogram only), the integral of the
 function in each bin is used instead of the value of the function at
 the centre of the bin.
 Only bins inside the function range are recomputed.
 IMPORTANT NOTE: If you intend to use the errors of this histogram later
 you should call <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> before making this operation.
 This is particularly important if you fit the histogram after <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Add" title="void TH1::Add(TF1* h1,Double_t c1=1,Option_t* option=&quot;&quot;) or overloads">Add</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Add%1" href="src/TH1.cxx.html#PdNVo">Add</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h1, <a href="./ListOfTypes.html#Double_t">Double_t</a> c1 = 1)</span><br />
<div class="funccomm"><pre> Performs the operation: this = this + c1*h1
 if errors are defined (see <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>), errors are also recalculated.
 Note that if h1 has <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> set, <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> is automatically called for this
 if not already set.

 SPECIAL CASE (Average/Efficiency histograms)
 For histograms representing averages or efficiencies, one should compute the average
 of the two histograms and not the sum. One can mark a histogram to be an average
 histogram by setting its bit <a href="./TH1.html#TH1:kIsAverage" title="const enum TH1:: TH1::kIsAverage">kIsAverage</a> with
    myhist.<a href="./TObject.html#TObject:SetBit" title="void TObject::SetBit(UInt_t f,Bool_t set) or overloads">SetBit</a>(<a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:kIsAverage" title="const enum TH1:: TH1::kIsAverage">kIsAverage</a>);
 Note that the two histograms must have their <a href="./TH1.html#TH1:kIsAverage" title="const enum TH1:: TH1::kIsAverage">kIsAverage</a> bit set

 IMPORTANT NOTE1: If you intend to use the errors of this histogram later
 you should call <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> before making this operation.
 This is particularly important if you fit the histogram after <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Add" title="void TH1::Add(TF1* h1,Double_t c1=1,Option_t* option=&quot;&quot;) or overloads">Add</a>

 IMPORTANT NOTE2: if h1 has a normalisation factor, the normalisation factor
 is used , ie  this = this + c1*factor*h1
 Use the other <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Add" title="void TH1::Add(TF1* h1,Double_t c1=1,Option_t* option=&quot;&quot;) or overloads">Add</a> function if you do not want this feature
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Add%2" href="src/TH1.cxx.html#SW3VSB">Add</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h, <span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h2, <a href="./ListOfTypes.html#Double_t">Double_t</a> c1 = 1, <a href="./ListOfTypes.html#Double_t">Double_t</a> c2 = 1)</span><br />
<div class="funccomm"><pre>   -*-*-*Replace contents of this histogram by the addition of h1 and h2*-*-*


   this = c1*h1 + c2*h2
   if errors are defined (see <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>), errors are also recalculated
   Note that if h1 or h2 have <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> set, <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> is automatically called for this
   if not already set.

 SPECIAL CASE (Average/Efficiency histograms)
 For histograms representing averages or efficiencies, one should compute the average
 of the two histograms and not the sum. One can mark a histogram to be an average
 histogram by setting its bit <a href="./TH1.html#TH1:kIsAverage" title="const enum TH1:: TH1::kIsAverage">kIsAverage</a> with
    myhist.<a href="./TObject.html#TObject:SetBit" title="void TObject::SetBit(UInt_t f,Bool_t set) or overloads">SetBit</a>(<a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:kIsAverage" title="const enum TH1:: TH1::kIsAverage">kIsAverage</a>);
 Note that the two histograms must have their <a href="./TH1.html#TH1:kIsAverage" title="const enum TH1:: TH1::kIsAverage">kIsAverage</a> bit set

 IMPORTANT NOTE: If you intend to use the errors of this histogram later
 you should call <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> before making this operation.
 This is particularly important if you fit the histogram after <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Add" title="void TH1::Add(TF1* h1,Double_t c1=1,Option_t* option=&quot;&quot;) or overloads">Add</a>

ANOTHER SPECIAL CASE : h1 = h2 and c2 &lt; 0
 do a scaling   this = c1 * h1 / (bin Volume)

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:AddBinContent" href="src/TH1.cxx.html#L1xAQC">AddBinContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*-*Increment bin content by 1*-*-*-*-*-*-*-*-*-*-*-*-*-*

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:AddBinContent%1" href="src/TH1.cxx.html#c8mX5">AddBinContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin, <a href="./ListOfTypes.html#Double_t">Double_t</a> w)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*-*Increment bin content by a weight w*-*-*-*-*-*-*-*-*-*-*

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:AddDirectory" href="src/TH1.cxx.html#h67gkC">AddDirectory</a>(<a href="./ListOfTypes.html#Bool_t">Bool_t</a> add = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</span><br />
<div class="funccomm"><pre> Sets the flag controlling the automatic add of histograms in memory

 By default (fAddDirectory = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>), histograms are automatically added
 to the list of objects in memory.
 Note that one histogram can be removed from its support directory
 by calling h-&gt;<a href="./TH1.html#TH1:SetDirectory" title="void TH1::SetDirectory(TDirectory* dir)">SetDirectory</a>(0) or h-&gt;<a href="./TH1.html#TH1:SetDirectory" title="void TH1::SetDirectory(TDirectory* dir)">SetDirectory</a>(dir) to add it
 to the list of objects in the directory dir.

  NOTE that this is a static function. To call it, use;
     <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:AddDirectory" title="void TH1::AddDirectory(Bool_t add=kTRUE)">AddDirectory</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:BufferEmpty" href="src/TH1.cxx.html#b88dOB">BufferEmpty</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> action = 0)</span><br />
<div class="funccomm"><pre> <a href="./TH1.html#TH1:Fill" title="Int_t TH1::Fill(Double_t x) or overloads">Fill</a> histogram with all entries in the buffer.
 action = -1 histogram is reset and refilled from the buffer (called by <a href="./THistPainter.html">THistPainter</a>::<a href="./THistPainter.html#THistPainter:Paint" title="void THistPainter::Paint(Option_t* option=&quot;&quot;)">Paint</a>)
 action =  0 histogram is reset and filled from the buffer. When the histogram is filled from the
             buffer the value <a href="./TH1.html#TH1:fBuffer" title="Double_t* TH1::fBuffer">fBuffer</a>[0] is set to a negative number (= - number of entries)
             When calling with action == 0 the histogram is NOT refilled when <a href="./TH1.html#TH1:fBuffer" title="Double_t* TH1::fBuffer">fBuffer</a>[0] is &lt; 0
             While when calling with action = -1 the histogram is reset and ALWAYS refilled independently if
             the histogram was filled before. This is needed when drawing the histogram

 action =  1 histogram is filled and buffer is deleted
             The buffer is automatically deleted when filling the histogram and the entries is
             larger than the buffer size

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:BufferFill" href="src/TH1.cxx.html#oJ3M0D">BufferFill</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> x, <a href="./ListOfTypes.html#Double_t">Double_t</a> w)</span><br />
<div class="funccomm"><pre> accumulate arguments in buffer. When buffer is full, empty the buffer
 <a href="./TH1.html#TH1:fBuffer" title="Double_t* TH1::fBuffer">fBuffer</a>[0] = number of entries in buffer
 <a href="./TH1.html#TH1:fBuffer" title="Double_t* TH1::fBuffer">fBuffer</a>[1] = w of first entry
 <a href="./TH1.html#TH1:fBuffer" title="Double_t* TH1::fBuffer">fBuffer</a>[2] = x of first entry
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">bool</span> <a class="funcname" name="TH1:CheckBinLimits" href="src/TH1.cxx.html#mXJTPB">CheckBinLimits</a>(<span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>* a1, <span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>* a2)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">bool</span> <a class="funcname" name="TH1:CheckAxisLimits" href="src/TH1.cxx.html#IZm08B">CheckAxisLimits</a>(<span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>* a1, <span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>* a2)</span><br />
<div class="funccomm"><pre> Check that the axis limits of the histograms are the same
 if a first and last bin is passed the axis is compared between the given range
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">bool</span> <a class="funcname" name="TH1:CheckEqualAxes" href="src/TH1.cxx.html#wai_HB">CheckEqualAxes</a>(<span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>* a1, <span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>* a2)</span><br />
<div class="funccomm"><pre> Check that the axis are the same
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">bool</span> <a class="funcname" name="TH1:CheckConsistentSubAxes" href="src/TH1.cxx.html#wta8QD">CheckConsistentSubAxes</a>(<span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>* a1, <a href="./ListOfTypes.html#Int_t">Int_t</a> firstBin1, <a href="./ListOfTypes.html#Int_t">Int_t</a> lastBin1, <span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>* a2, <a href="./ListOfTypes.html#Int_t">Int_t</a> firstBin2 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> lastBin2 = 0)</span><br />
<div class="funccomm"><pre> Check that two sub axis are the same
 the limits are defined by first bin and last bin
 N.B. no check is done in this case for variable bins
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">bool</span> <a class="funcname" name="TH1:CheckConsistency" href="src/TH1.cxx.html#lNC6hE">CheckConsistency</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h1, <span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h2)</span><br />
<div class="funccomm"><pre> Check histogram compatibility
 returns <a href="./ListOfTypes.html#Bool_t">kTRUE</a> if number of bins and bin limits are identical
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:Chi2Test" href="src/TH1.cxx.html#QKf7UB">Chi2Test</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h2, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">"UU"</span>, <a href="./ListOfTypes.html#Double_t">Double_t</a>* res = 0) const</span><br />
<div class="funccomm"><pre> <span class="latex"><img class="latex" alt="#chi^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_0_chi.gif" /></span> test for comparing weighted and unweighted histograms

 Function: Returns p-value. Other return values are specified by the 3rd parameter &lt;br&gt;

 Parameters:

    - h2: the second histogram
    - option:
       o <span class="string">"UU"</span> = experiment experiment comparison (unweighted-unweighted)
       o <span class="string">"UW"</span> = experiment MC comparison (unweighted-weighted). Note that
          the first histogram should be unweighted
       o <span class="string">"WW"</span> = MC MC comparison (weighted-weighted)
       o <span class="string">"NORM"</span> = to be used when one or both of the histograms is scaled
                  but the histogram originally was unweighted
       o by default underflows and overlows are not included:
          * <span class="string">"OF"</span> = overflows included
          * <span class="string">"UF"</span> = underflows included
       o <span class="string">"P"</span> = print chi2, ndf, p_value, igood
       o <span class="string">"CHI2"</span> = returns chi2 instead of p-value
       o <span class="string">"CHI2/NDF"</span> = returns <span class="latex"><img class="latex" alt="#chi^{2}/ndf" title="LATEX" src="LATEX_TH1_Chi2Test_1_1_chindf.gif" /></span>
    - res: not empty - computes normalized residuals and returns them in
      this array

 The current implementation is based on the papers <span class="latex"><img class="latex" alt="#chi^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_2_chi.gif" /></span> test for comparison
 of weighted and unweighted histograms<span class="string">" in Proceedings of PHYSTAT05 and</span>
 <span class="string">"Comparison weighted and unweighted histograms"</span>, arXiv:physics/0605123
 by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006.

 Introduction:

   A frequently used technique in data analysis is the comparison of
   histograms. First suggested by Pearson [1] the <span class="latex"><img class="latex" alt="#chi^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_3_chi.gif" /></span> test of
   homogeneity is used widely for comparing usual (unweighted) histograms.
   This paper describes the implementation modified <span class="latex"><img class="latex" alt="#chi^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_4_chi.gif" /></span> tests
   for comparison of weighted and unweighted  histograms and two weighted
   histograms [2] as well as usual Pearson's <span class="latex"><img class="latex" alt="#chi^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_5_chi.gif" /></span> test for
   comparison two usual (unweighted) histograms.

 Overview:

   Comparison of two histograms expect hypotheses that two histograms
   represent identical distributions. To make a decision p-value should
   be calculated. The hypotheses of identity is rejected if the p-value is
   lower then some significance level. Traditionally significance levels
   0.1, 0.05 and 0.01 are used. The comparison procedure should include an
   analysis of the residuals which is often helpful in identifying the
   bins of histograms responsible for a significant overall <span class="latex"><img class="latex" alt="#chi^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_6_chi.gif" /></span> value.
   Residuals are the difference between bin contents and expected bin
   contents. Most convenient for analysis are the normalized residuals. If
   hypotheses of identity are valid then normalized residuals are
   approximately independent and identically distributed random variables
   having N(0,1) distribution. Analysis of residuals expect test of above
   mentioned properties of residuals. Notice that indirectly the analysis
   of residuals increase the power of <span class="latex"><img class="latex" alt="#chi^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_7_chi.gif" /></span> test.

 Methods of comparison:

  <span class="latex"><img class="latex" alt="#chi^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_8_chi.gif" /></span> test for comparison two (unweighted) histograms:
   Let us consider two  histograms with the  same binning and the  number
   of bins equal to r. Let us denote the number of events in the ith bin
   in the first histogram as ni and as mi in the second one. The total
   number of events in the first histogram is equal to:

<span class="latex"><img class="latex" alt="N = #sum_{i=1}^{r} n_{i}" title="LATEX" src="LATEX_TH1_Chi2Test_1_9_Nsum_irn_i.gif" /></span>
   and

<span class="latex"><img class="latex" alt="M = #sum_{i=1}^{r} m_{i}" title="LATEX" src="LATEX_TH1_Chi2Test_1_10_Msum_irm_i.gif" /></span>
   in the second histogram. The hypothesis of identity (homogeneity) [3]
   is that the two histograms represent random values with identical
   distributions. It is equivalent that there exist r constants p1,...,pr,
   such that

<span class="latex"><img class="latex" alt="#sum_{i=1}^{r} p_{i}=1" title="LATEX" src="LATEX_TH1_Chi2Test_1_11_sum_irp_i.gif" /></span>
    and the probability of belonging to the ith bin for some measured value
    in both experiments is equal to pi. The number of events in the ith
    bin is a random variable with a distribution approximated by a Poisson
    probability distribution

<span class="latex"><img class="latex" alt="#frac{e^{-Np_{i}}(Np_{i})^{n_{i}}}{n_{i}!}" title="LATEX" src="LATEX_TH1_Chi2Test_1_12_fraceNp_iNp_in_in_i.gif" /></span>
   for the first histogram and with distribution

<span class="latex"><img class="latex" alt="#frac{e^{-Mp_{i}}(Mp_{i})^{m_{i}}}{m_{i}!}" title="LATEX" src="LATEX_TH1_Chi2Test_1_13_fraceMp_iMp_im_im_i.gif" /></span>
   for the second histogram. If the hypothesis of homogeneity is valid,
   then the  maximum likelihood estimator of pi, i=1,...,r, is

<span class="latex"><img class="latex" alt="#hat{p}_{i}= #frac{n_{i}+m_{i}}{N+M}" title="LATEX" src="LATEX_TH1_Chi2Test_1_14_hatp_ifracn_im_iNM.gif" /></span>
   and then

<span class="latex"><img class="latex" alt="X^{2} = #sum_{i=1}^{r}#frac{(n_{i}-N#hat{p}_{i})^{2}}{N#hat{p}_{i}} + #sum_{i=1}^{r}#frac{(m_{i}-M#hat{p}_{i})^{2}}{M#hat{p}_{i}} = #frac{1}{MN} #sum_{i=1}^{r}#frac{(Mn_{i}-Nm_{i})^{2}}{n_{i}+m_{i}}" title="LATEX" src="LATEX_TH1_Chi2Test_1_15_Xsum_irfracn_iNhatp_iNhatp_isum_irfracm_iMhatp_iMhatp_ifracMNsum_irfracMn_iNm_in_im_i.gif" /></span>
   has approximately a <span class="latex"><img class="latex" alt="#chi^{2}_{(r-1)}" title="LATEX" src="LATEX_TH1_Chi2Test_1_16_chi_r.gif" /></span> distribution [3].
   The comparison procedure can include an analysis of the residuals which
   is often helpful in identifying the bins of histograms responsible for
   a significant overall <span class="latex"><img class="latex" alt="#chi^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_17_chi.gif" /></span>value. Most convenient for
   analysis are the adjusted (normalized) residuals [4]

<span class="latex"><img class="latex" alt="r_{i} = #frac{n_{i}-N#hat{p}_{i}}{#sqrt{N#hat{p}_{i}}#sqrt{(1-N/(N+M))(1-(n_{i}+m_{i})/(N+M))}}" title="LATEX" src="LATEX_TH1_Chi2Test_1_18_r_ifracn_iNhatp_isqrtNhatp_isqrtNNMn_im_iNM.gif" /></span>
   If hypotheses of  homogeneity are valid then residuals ri are
   approximately independent and identically distributed random variables
   having N(0,1) distribution. The application of the <span class="latex"><img class="latex" alt="#chi^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_19_chi.gif" /></span> test has
   restrictions related to the value of the expected frequencies Npi,
   Mpi, i=1,...,r. A conservative rule formulated in [5] is that all the
   expectations must be 1 or greater for both histograms. In practical
   cases when expected frequencies are not known the estimated expected
   frequencies <span class="latex"><img class="latex" alt="M#hat{p}_{i}, N#hat{p}_{i}, i=1,...,r" title="LATEX" src="LATEX_TH1_Chi2Test_1_20_Mhatp_iNhatp_iir.gif" /></span>  can be used.

  Unweighted and weighted histograms comparison:

   A simple modification of the ideas described above can be used for the
   comparison of the usual (unweighted) and weighted histograms. Let us
   denote the number of events in the ith bin in the unweighted
   histogram as ni and the common weight of events in the ith bin of the
   weighted histogram as wi. The total number of events in the
   unweighted histogram is equal to

<span class="latex"><img class="latex" alt="N = #sum_{i=1}^{r} n_{i}" title="LATEX" src="LATEX_TH1_Chi2Test_1_21_Nsum_irn_i.gif" /></span>
   and the total weight of events in the weighted histogram is equal to

<span class="latex"><img class="latex" alt="W = #sum_{i=1}^{r} w_{i}" title="LATEX" src="LATEX_TH1_Chi2Test_1_22_Wsum_irw_i.gif" /></span>
   Let us formulate the hypothesis of identity of an unweighted histogram
   to a weighted histogram so that there exist r constants p1,...,pr, such
   that

<span class="latex"><img class="latex" alt="#sum_{i=1}^{r} p_{i} = 1" title="LATEX" src="LATEX_TH1_Chi2Test_1_23_sum_irp_i.gif" /></span>
   for the unweighted histogram. The weight wi is a random variable with a
   distribution approximated by the normal probability distribution
   <span class="latex"><img class="latex" alt="N(Wp_{i},#sigma_{i}^{2})" title="LATEX" src="LATEX_TH1_Chi2Test_1_24_NWp_isigma_i.gif" /></span> where <span class="latex"><img class="latex" alt="#sigma_{i}^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_25_sigma_i.gif" /></span> is the variance of the weight wi.
   If we replace the variance <span class="latex"><img class="latex" alt="#sigma_{i}^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_26_sigma_i.gif" /></span>
   with estimate <span class="latex"><img class="latex" alt="s_{i}^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_27_s_i.gif" /></span> (sum of squares of weights of
   events in the ith bin) and the hypothesis of identity is valid, then the
   maximum likelihood estimator of  pi,i=1,...,r, is

<span class="latex"><img class="latex" alt="#hat{p}_{i} = #frac{Ww_{i}-Ns_{i}^{2}+#sqrt{(Ww_{i}-Ns_{i}^{2})^{2}+4W^{2}s_{i}^{2}n_{i}}}{2W^{2}}" title="LATEX" src="LATEX_TH1_Chi2Test_1_28_hatp_ifracWw_iNs_isqrtWw_iNs_iWs_in_iW.gif" /></span>
   We may then use the test statistic

<span class="latex"><img class="latex" alt="X^{2} = #sum_{i=1}^{r} #frac{(n_{i}-N#hat{p}_{i})^{2}}{N#hat{p}_{i}} + #sum_{i=1}^{r} #frac{(w_{i}-W#hat{p}_{i})^{2}}{s_{i}^{2}}" title="LATEX" src="LATEX_TH1_Chi2Test_1_29_Xsum_irfracn_iNhatp_iNhatp_isum_irfracw_iWhatp_is_i.gif" /></span>
   and it has approximately a <span class="latex"><img class="latex" alt="#chi^{2}_{(r-1)}" title="LATEX" src="LATEX_TH1_Chi2Test_1_30_chi_r.gif" /></span> distribution [2]. This test, as well
   as the original one [3], has a restriction on the expected frequencies. The
   expected frequencies recommended for the weighted histogram is more than 25.
   The value of the minimal expected frequency can be decreased down to 10 for
   the case when the weights of the events are close to constant. In the case
   of a weighted histogram if the number of events is unknown, then we can
   apply this recommendation for the equivalent number of events as

<span class="latex"><img class="latex" alt="n_{i}^{equiv} = #frac{ w_{i}^{2} }{ s_{i}^{2} }" title="LATEX" src="LATEX_TH1_Chi2Test_1_31_n_iequivfracw_is_i.gif" /></span>
   The minimal expected frequency for an unweighted histogram must be 1. Notice
   that any usual (unweighted) histogram can be considered as a weighted
   histogram with events that have constant weights equal to 1.
   The variance <span class="latex"><img class="latex" alt="z_{i}^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_32_z_i.gif" /></span> of the difference between the weight wi
   and the estimated expectation value of the weight is approximately equal to:

<span class="latex"><img class="latex" alt="z_{i}^{2} = Var(w_{i}-W#hat{p}_{i}) = N#hat{p}_{i}(1-N#hat{p}_{i})#left(#frac{Ws_{i}^{2}}{#sqrt{(Ns_{i}^{2}-w_{i}W)^{2}+4W^{2}s_{i}^{2}n_{i}}}#right)^{2}+#frac{s_{i}^{2}}{4}#left(1+#frac{Ns_{i}^{2}-w_{i}W}{#sqrt{(Ns_{i}^{2}-w_{i}W)^{2}+4W^{2}s_{i}^{2}n_{i}}}#right)^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_33_z_iVarw_iWhatp_iNhatp_iNhatp_ileftfracWs_isqrtNs_iw_iWWs_in_irightfracs_ileftfracNs_iw_iWsqrtNs_iw_iWWs_in_iright.gif" /></span>
   The  residuals

<span class="latex"><img class="latex" alt="r_{i} = #frac{w_{i}-W#hat{p}_{i}}{z_{i}}" title="LATEX" src="LATEX_TH1_Chi2Test_1_34_r_ifracw_iWhatp_iz_i.gif" /></span>
   have approximately a normal distribution with mean equal to 0 and standard
   deviation  equal to 1.

  Two weighted histograms comparison:

   Let us denote the common  weight of events of the ith bin in the first
   histogram as w1i and as w2i in the second one. The total weight of events
   in the first histogram is equal to

<span class="latex"><img class="latex" alt="W_{1} = #sum_{i=1}^{r} w_{1i}" title="LATEX" src="LATEX_TH1_Chi2Test_1_35_W_sum_irw_i.gif" /></span>
   and

<span class="latex"><img class="latex" alt="W_{2} = #sum_{i=1}^{r} w_{2i}" title="LATEX" src="LATEX_TH1_Chi2Test_1_36_W_sum_irw_i.gif" /></span>
   in the second histogram. Let us formulate the hypothesis of identity of
   weighted histograms so that there exist r constants p1,...,pr, such that

<span class="latex"><img class="latex" alt="#sum_{i=1}^{r} p_{i} = 1" title="LATEX" src="LATEX_TH1_Chi2Test_1_37_sum_irp_i.gif" /></span>
   and also expectation value of weight w1i equal to W1pi and expectation value
   of weight w2i equal to W2pi. Weights in both the histograms are random
   variables with distributions which can be approximated by a normal
   probability distribution <span class="latex"><img class="latex" alt="N(W_{1}p_{i},#sigma_{1i}^{2})" title="LATEX" src="LATEX_TH1_Chi2Test_1_38_NW_p_isigma_i.gif" /></span> for the first histogram
   and by a distribution <span class="latex"><img class="latex" alt="N(W_{2}p_{i},#sigma_{2i}^{2})" title="LATEX" src="LATEX_TH1_Chi2Test_1_39_NW_p_isigma_i.gif" /></span> for the second.
   Here <span class="latex"><img class="latex" alt="#sigma_{1i}^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_40_sigma_i.gif" /></span> and <span class="latex"><img class="latex" alt="#sigma_{2i}^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_41_sigma_i.gif" /></span> are the variances
   of w1i and w2i with estimators <span class="latex"><img class="latex" alt="s_{1i}^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_42_s_i.gif" /></span> and <span class="latex"><img class="latex" alt="s_{2i}^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_43_s_i.gif" /></span> respectively.
   If the hypothesis of identity is valid, then the maximum likelihood and
   Least Square Method estimator of pi,i=1,...,r, is

<span class="latex"><img class="latex" alt="#hat{p}_{i} = #frac{w_{1i}W_{1}/s_{1i}^{2}+w_{2i}W_{2} /s_{2i}^{2}}{W_{1}^{2}/s_{1i}^{2}+W_{2}^{2}/s_{2i}^{2}}" title="LATEX" src="LATEX_TH1_Chi2Test_1_44_hatp_ifracw_iW_s_iw_iW_s_iW_s_iW_s_i.gif" /></span>
   We may then use the test statistic

<span class="latex"><img class="latex" alt="X^{2} = #sum_{i=1}^{r} #frac{(w_{1i}-W_{1}#hat{p}_{i})^{2}}{s_{1i}^{2}} + #sum_{i=1}^{r} #frac{(w_{2i}-W_{2}#hat{p}_{i})^{2}}{s_{2i}^{2}} = #sum_{i=1}^{r} #frac{(W_{1}w_{2i}-W_{2}w_{1i})^{2}}{W_{1}^{2}s_{2i}^{2}+W_{2}^{2}s_{1i}^{2}}" title="LATEX" src="LATEX_TH1_Chi2Test_1_45_Xsum_irfracw_iW_hatp_is_isum_irfracw_iW_hatp_is_isum_irfracW_w_iW_w_iW_s_iW_s_i.gif" /></span>
   and it has approximately a <span class="latex"><img class="latex" alt="#chi^{2}_{(r-1)}" title="LATEX" src="LATEX_TH1_Chi2Test_1_46_chi_r.gif" /></span> distribution [2].
   The normalized or studentised residuals [6]

<span class="latex"><img class="latex" alt="r_{i} = #frac{w_{1i}-W_{1}#hat{p}_{i}}{s_{1i}#sqrt{1 - #frac{1}{(1+W_{2}^{2}s_{1i}^{2}/W_{1}^{2}s_{2i}^{2})}}}" title="LATEX" src="LATEX_TH1_Chi2Test_1_47_r_ifracw_iW_hatp_is_isqrtfracW_s_iW_s_i.gif" /></span>
   have approximately a normal distribution with mean equal to 0 and standard
   deviation 1. A recommended minimal expected frequency is equal to 10 for
   the proposed test.

 Numerical examples:

   The method described herein is now illustrated with an example.
   We take a distribution

<span class="latex"><img class="latex" alt="#phi(x) = #frac{2}{(x-10)^{2}+1} + #frac{1}{(x-14)^{2}+1}       (1)" title="LATEX" src="LATEX_TH1_Chi2Test_1_48_phixfracxfracx.gif" /></span>
   defined on the interval [4,16]. Events distributed according to the formula
   (1) are simulated to create the unweighted histogram. Uniformly distributed
   events are simulated for the weighted histogram with weights calculated by
   formula (1). Each histogram has the same number of bins: 20. Fig.1 shows
   the result of comparison of the unweighted histogram with 200 events
   (minimal expected frequency equal to one) and the weighted histogram with
   500 events (minimal expected frequency equal to 25)

<span class="macro"><img class="macro" alt="output of MACRO_TH1_Chi2Test_1_49_c1" title="MACRO" src="MACRO_TH1_Chi2Test_1_49_c1.gif" /></span>
   Fig 1. An example of comparison of the unweighted histogram with 200 events
   and the weighted histogram with 500 events:
      a) unweighted histogram;
      b) weighted histogram;
      c) normalized residuals plot;
      d) normal Q-Q plot of residuals.

   The value of the test statistic <span class="latex"><img class="latex" alt="#chi^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_50_chi.gif" /></span> is equal to
   21.09 with p-value equal to 0.33, therefore the hypothesis of identity of
   the two histograms can be accepted for 0.05 significant level. The behavior
   of the normalized residuals plot (see Fig. 1c) and the normal Q-Q plot
   (see Fig. 1d) of residuals are regular and we cannot identify the outliers
   or bins with a big influence on <span class="latex"><img class="latex" alt="#chi^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_51_chi.gif" /></span>.

   The second example presents the same two histograms but 17 events was added
   to content of bin number 15 in unweighted histogram. Fig.2 shows the result
   of comparison of the unweighted histogram with 217 events (minimal expected
   frequency equal to one) and the weighted histogram with 500 events (minimal
   expected frequency equal to 25)

<span class="macro"><img class="macro" alt="output of MACRO_TH1_Chi2Test_1_52_c1" title="MACRO" src="MACRO_TH1_Chi2Test_1_52_c1.gif" /></span>
   Fig 2. An example of comparison of the unweighted histogram with 217 events
   and the weighted histogram with 500 events:
      a) unweighted histogram;
      b) weighted histogram;
      c) normalized residuals plot;
      d) normal Q-Q plot of residuals.

   The value of the test statistic <span class="latex"><img class="latex" alt="#chi^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_53_chi.gif" /></span> is equal to
   32.33 with p-value equal to 0.029, therefore the hypothesis of identity of
   the two histograms is rejected for 0.05 significant level. The behavior of
   the normalized residuals plot (see Fig. 2c) and the normal Q-Q plot (see
   Fig. 2d) of residuals are not regular and we can identify the outlier or
   bin with a big influence on <span class="latex"><img class="latex" alt="#chi^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_54_chi.gif" /></span>.

 References:

 [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to
     Association and Normal Correlation. Drapers' Co. Memoirs, Biometric
     Series No. 1, London.
 [2] Gagunashvili, N., 2006. <span class="latex"><img class="latex" alt="#chi^{2}" title="LATEX" src="LATEX_TH1_Chi2Test_1_55_chi.gif" /></span> test for comparison
     of weighted and unweighted histograms. Statistical Problems in Particle
     Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,
     Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.
     Gagunashvili,N., Comparison of weighted and unweighted histograms,
     arXiv:physics/0605123, 2006.
 [3] Cramer, H., 1946. Mathematical methods of statistics.
     Princeton University Press, Princeton.
 [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.
     Biometrics 29, 205-220.
 [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity
     test in 2xN tables. Biometrics 21, 19-33.
 [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.
     John Wiley &amp; Sons Inc., New York.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:Chi2TestX" href="src/TH1.cxx.html#ImYxrE">Chi2TestX</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h2, <a href="./ListOfTypes.html#Double_t">Double_t</a>&amp; chi2, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; ndf, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; igood, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">"UU"</span>, <a href="./ListOfTypes.html#Double_t">Double_t</a>* res = 0) const</span><br />
<div class="funccomm"><pre> The computation routine of the Chisquare test. For the method description,
 see <a href="./TH1.html#TH1:Chi2Test" title="Double_t TH1::Chi2Test(const TH1* h2,Option_t* option=&quot;UU&quot;,Double_t* res=0)">Chi2Test</a>() function.
 Returns p-value
 parameters:
  - h2-second histogram
  - option:
     <span class="string">"UU"</span> = experiment experiment comparison (unweighted-unweighted)
     <span class="string">"UW"</span> = experiment MC comparison (unweighted-weighted). Note that the first
           histogram should be unweighted
     <span class="string">"WW"</span> = MC MC comparison (weighted-weighted)

     <span class="string">"NORM"</span> = if one or both histograms is scaled

     <span class="string">"OF"</span> = overflows included
     <span class="string">"UF"</span> = underflows included
         by default underflows and overflows are not included

  - igood:
       igood=0 - no problems
        For unweighted unweighted  comparison
       igood=1'There is a bin in the 1st histogram with less than 1 event'
       igood=2'There is a bin in the 2nd histogram with less than 1 event'
       igood=3'when the conditions for igood=1 and igood=2 are satisfied'
        For  unweighted weighted  comparison
       igood=1'There is a bin in the 1st histogram with less then 1 event'
       igood=2'There is a bin in the 2nd histogram with less then 10 effective number of events'
       igood=3'when the conditions for igood=1 and igood=2 are satisfied'
        For  weighted weighted  comparison
       igood=1'There is a bin in the 1st  histogram with less then 10 effective
        number of events'
       igood=2'There is a bin in the 2nd  histogram with less then 10 effective
               number of events'
       igood=3'when the conditions for igood=1 and igood=2 are satisfied'

  - chi2 - chisquare of the test
  - ndf  - number of degrees of freedom (important, when both histograms have the same
         empty bins)
  - res -  normalized residuals for further analysis
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:ComputeIntegral" href="src/TH1.cxx.html#FqXIvD">ComputeIntegral</a>()</span><br />
<div class="funccomm"><pre>  Compute integral (cumulative sum of bins)
  The result stored in <a href="./TH1.html#TH1:fIntegral" title="Double_t* TH1::fIntegral">fIntegral</a> is used by the <a href="./TH1.html#TH1:GetRandom" title="Double_t TH1::GetRandom()">GetRandom</a> functions.
  This function is automatically called by <a href="./TH1.html#TH1:GetRandom" title="Double_t TH1::GetRandom()">GetRandom</a> when the <a href="./TH1.html#TH1:fIntegral" title="Double_t* TH1::fIntegral">fIntegral</a>
  array does not exist or when the number of entries in the histogram
  has changed since the previous call to <a href="./TH1.html#TH1:GetRandom" title="Double_t TH1::GetRandom()">GetRandom</a>.
  The resulting integral is normalized to 1
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> * <a class="funcname" name="TH1:GetIntegral" href="src/TH1.cxx.html#WzyIOB">GetIntegral</a>()</span><br />
<div class="funccomm"><pre>  Return a pointer to the array of bins integral.
  if the pointer <a href="./TH1.html#TH1:fIntegral" title="Double_t* TH1::fIntegral">fIntegral</a> is null, <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:ComputeIntegral" title="Double_t TH1::ComputeIntegral()">ComputeIntegral</a> is called
 The array dimension is the number of bins in the histograms
 including underflow and overflow (fNCells)
 the last value integral[fNCells] is set to the number of entries of
 the histogram
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Copy" href="src/TH1.cxx.html#vVvUXE">Copy</a>(<a href="./TObject.html">TObject</a>&amp; hnew) const</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*<a href="./TH1.html#TH1:Copy" title="void TH1::Copy(TObject&amp; hnew)">Copy</a> this histogram structure to newth1*-*-*-*-*-*-*-*-*-*-*-*


 Note that this function does not copy the list of associated functions.
 Use <a href="./TObject.html">TObject</a>::<a href="./TObject.html#TObject:Clone" title="TObject* TObject::Clone(const char* newname=&quot;&quot;)">Clone</a> to make a full copy of an histogram.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:DirectoryAutoAdd" href="src/TH1.cxx.html#aTFhBB">DirectoryAutoAdd</a>(<a href="./TDirectory.html">TDirectory</a>* )</span><br />
<div class="funccomm"><pre> Perform the automatic addition of the histogram to the given directory

 Note this function is called in place when the semantic requires
 this object to be added to a directory (I.e. when being read from
 a <a href="./TKey.html">TKey</a> or being Cloned)

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:DistancetoPrimitive" href="src/TH1.cxx.html#xdVb0C">DistancetoPrimitive</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> px, <a href="./ListOfTypes.html#Int_t">Int_t</a> py)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*-*-*Compute distance from point px,py to a line*-*-*-*-*-*

     Compute the closest distance of approach from point px,py to elements
     of an histogram.
     The distance is computed in pixels units.

     Algorithm:
     Currently, this simple model computes the distance from the mouse
     to the histogram contour only.

   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Divide" href="src/TH1.cxx.html#GF0lfC">Divide</a>(<a href="./TF1.html">TF1</a>* f1, <a href="./ListOfTypes.html#Double_t">Double_t</a> c1 = 1)</span><br />
<div class="funccomm"><pre> Performs the operation: this = this/(c1*f1)
 if errors are defined (see <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>), errors are also recalculated.

 Only bins inside the function range are recomputed.
 IMPORTANT NOTE: If you intend to use the errors of this histogram later
 you should call <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> before making this operation.
 This is particularly important if you fit the histogram after <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Divide" title="void TH1::Divide(TF1* f1,Double_t c1=1) or overloads">Divide</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Divide%1" href="src/TH1.cxx.html#eN3GjD">Divide</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h1)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*-*-*<a href="./TH1.html#TH1:Divide" title="void TH1::Divide(TF1* f1,Double_t c1=1) or overloads">Divide</a> this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*


   this = this/h1
   if errors are defined (see <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>), errors are also recalculated.
   Note that if h1 has <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> set, <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> is automatically called for this
   if not already set.
   The resulting errors are calculated assuming uncorrelated histograms.
   See the other <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Divide" title="void TH1::Divide(TF1* f1,Double_t c1=1) or overloads">Divide</a> that gives the possibility to optionally
   compute binomial errors.

 IMPORTANT NOTE: If you intend to use the errors of this histogram later
 you should call <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> before making this operation.
 This is particularly important if you fit the histogram after <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Scale" title="void TH1::Scale(Double_t c1=1,Option_t* option=&quot;&quot;)">Scale</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Divide%2" href="src/TH1.cxx.html#hh46dE">Divide</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h1, <span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h2, <a href="./ListOfTypes.html#Double_t">Double_t</a> c1 = 1, <a href="./ListOfTypes.html#Double_t">Double_t</a> c2 = 1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre>   -*-*-*Replace contents of this histogram by the division of h1 by h2*-*-*


   this = c1*h1/(c2*h2)

   if errors are defined (see <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>), errors are also recalculated
   Note that if h1 or h2 have <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> set, <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> is automatically called for this
   if not already set.
   The resulting errors are calculated assuming uncorrelated histograms.
   However, if option =<span class="string">"B"</span> is specified, Binomial errors are computed.
   In this case c1 and c2 do not make real sense and they are ignored.

 IMPORTANT NOTE: If you intend to use the errors of this histogram later
 you should call <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> before making this operation.
 This is particularly important if you fit the histogram after <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Divide" title="void TH1::Divide(TF1* f1,Double_t c1=1) or overloads">Divide</a>

  Please note also that in the binomial case errors are calculated using standard
  binomial statistics, which means when b1 = b2, the error is zero.
  If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must
  use the function <a href="./TGraphAsymmErrors.html">TGraphAsymmErrors</a>::<a href="./TGraphAsymmErrors.html#TGraphAsymmErrors:BayesDivide" title="void TGraphAsymmErrors::BayesDivide(const TH1* pass,const TH1* total,Option_t* opt=&quot;&quot;)">BayesDivide</a>, which will return an asymmetric and non-zero lower
  error for the case b1=b2.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Draw" href="src/TH1.cxx.html#mB16VE">Draw</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*-*-*<a href="./TH1.html#TH1:Draw" title="void TH1::Draw(Option_t* option=&quot;&quot;)">Draw</a> this histogram with options*-*-*-*-*-*-*-*-*-*-*-*


     Histograms are drawn via the <a href="./THistPainter.html">THistPainter</a> class. Each histogram has
     a pointer to its own painter (to be usable in a multithreaded program).
     The same histogram can be drawn with different options in different pads.
     When an histogram drawn in a pad is deleted, the histogram is
     automatically removed from the pad or pads where it was drawn.
     If an histogram is drawn in a pad, then filled again, the new status
     of the histogram will be automatically shown in the pad next time
     the pad is updated. One does not need to redraw the histogram.
     To draw the current version of an histogram in a pad, one can use
        h-&gt;<a href="./TH1.html#TH1:DrawCopy" title="TH1* TH1::DrawCopy(Option_t* option=&quot;&quot;)">DrawCopy</a>();
     This makes a clone of the histogram. Once the clone is drawn, the original
     histogram may be modified or deleted without affecting the aspect of the
     clone.
     By default, <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Draw" title="void TH1::Draw(Option_t* option=&quot;&quot;)">Draw</a> clears the current pad.

     One can use <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:SetMaximum" title="void TH1::SetMaximum(Double_t maximum=-1111)">SetMaximum</a> and <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:SetMinimum" title="void TH1::SetMinimum(Double_t minimum=-1111)">SetMinimum</a> to force a particular
     value for the maximum or the minimum scale on the plot.

     <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:UseCurrentStyle" title="void TH1::UseCurrentStyle()">UseCurrentStyle</a> can be used to change all histogram graphics
     attributes to correspond to the current selected style.
     This function must be called for each histogram.
     In case one reads and draws many histograms from a file, one can force
     the histograms to inherit automatically the current graphics style
     by calling before <a href="./TROOT.html">gROOT</a>-><a href="./TROOT.html#TROOT:ForceStyle" title="void TROOT::ForceStyle(Bool_t force=kTRUE)">ForceStyle</a>();

     See <a href="./THistPainter.html">THistPainter</a>::<a href="./THistPainter.html#THistPainter:Paint" title="void THistPainter::Paint(Option_t* option=&quot;&quot;)">Paint</a> for a description of all the drawing options


   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TH1.html">TH1</a> * <a class="funcname" name="TH1:DrawCopy" href="src/TH1.cxx.html#EbepL">DrawCopy</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) const</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*<a href="./TH1.html#TH1:Copy" title="void TH1::Copy(TObject&amp; hnew)">Copy</a> this histogram and <a href="./TH1.html#TH1:Draw" title="void TH1::Draw(Option_t* option=&quot;&quot;)">Draw</a> in the current pad*-*-*-*-*-*-*-*


     Once the histogram is drawn into the pad, any further modification
     using graphics input will be made on the copy of the histogram,
     and not to the original object.

     See <a href="./TH1.html#TH1:Draw" title="void TH1::Draw(Option_t* option=&quot;&quot;)">Draw</a> for the list of options

   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TH1.html">TH1</a> * <a class="funcname" name="TH1:DrawNormalized" href="src/TH1.cxx.html#nVJE7E">DrawNormalized</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Double_t">Double_t</a> norm = 1) const</span><br />
<div class="funccomm"><pre>  <a href="./TH1.html#TH1:Draw" title="void TH1::Draw(Option_t* option=&quot;&quot;)">Draw</a> a normalized copy of this histogram.

  A clone of this histogram is normalized to norm and drawn with option.
  A pointer to the normalized histogram is returned.
  The contents of the histogram copy are scaled such that the new
  sum of weights (excluding under and overflow) is equal to norm.
  Note that the returned normalized histogram is not added to the list
  of histograms in the current directory in memory.
  It is the user's responsability to delete this histogram.
  The kCanDelete bit is set for the returned object. If a pad containing
  this copy is cleared, the histogram will be automatically deleted.
  See also remark about calling <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> before scaling a histogram to get
  a correct computation of the error bars.

     See <a href="./TH1.html#TH1:Draw" title="void TH1::Draw(Option_t* option=&quot;&quot;)">Draw</a> for the list of options

   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:DrawPanel" href="src/TH1.cxx.html#RFuurD">DrawPanel</a>()</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*Display a panel with all histogram drawing options*-*-*-*-*-*


      See class TDrawPanelHist for example
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Eval" href="src/TH1.cxx.html#ahaHxD">Eval</a>(<a href="./TF1.html">TF1</a>* f1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre>   -*-*-*Evaluate function f1 at the center of bins of this histogram-*-*-*-*


     If option <span class="string">"R"</span> is specified, the function is evaluated only
     for the bins included in the function range.
     If option <span class="string">"A"</span> is specified, the value of the function is added to the
     existing bin contents
     If option <span class="string">"S"</span> is specified, the value of the function is used to
     generate a value, distributed according to the Poisson
     distribution, with f1 as the mean.

   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:ExecuteEvent" href="src/TH1.cxx.html#wavGD">ExecuteEvent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> event, <a href="./ListOfTypes.html#Int_t">Int_t</a> px, <a href="./ListOfTypes.html#Int_t">Int_t</a> py)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*-*-*<a href="./TObject.html#TObject:Execute" title="void TObject::Execute(const char* method,const char* params,Int_t* error=0) or overloads">Execute</a> action corresponding to one event*-*-*-*

     This member function is called when a histogram is clicked with the locator

     If Left button clicked on the bin top value, then the content of this bin
     is modified according to the new position of the mouse when it is released.

   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TH1.html">TH1</a>* <a class="funcname" name="TH1:FFT" href="src/TH1.cxx.html#C_mUuE">FFT</a>(<a href="./TH1.html">TH1</a>* h_output, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option)</span><br />
<div class="funccomm"><pre> This function allows to do discrete Fourier transforms of <a href="./TH1.html">TH1</a> and <a href="./TH2.html">TH2</a>.
 Available transform types and flags are described below.

 To extract more information about the transform, use the function
  <a href="./TVirtualFFT.html">TVirtualFFT</a>::<a href="./TVirtualFFT.html#TVirtualFFT:GetCurrentTransform" title="TVirtualFFT* TVirtualFFT::GetCurrentTransform()">GetCurrentTransform</a>() to get a pointer to the current
  transform object.

 Parameters:
  1st - histogram for the output. If a null pointer is passed, a new histogram is created
  and returned, otherwise, the provided histogram is used and should be big enough

  Options: option parameters consists of 3 parts:
    - option on what to return
   <span class="string">"RE"</span> - returns a histogram of the real part of the output
   <span class="string">"IM"</span> - returns a histogram of the imaginary part of the output
   <span class="string">"MAG"</span>- returns a histogram of the magnitude of the output
   <span class="string">"PH"</span> - returns a histogram of the phase of the output

    - option of transform type
   <span class="string">"R2C"</span>  - real to complex transforms - default
   <span class="string">"R2HC"</span> - real to halfcomplex (special format of storing output data,
          results the same as for R2C)
   <span class="string">"DHT"</span> - discrete Hartley transform
         real to real transforms (sine and cosine):
   <span class="string">"R2R_0"</span>, <span class="string">"R2R_1"</span>, <span class="string">"R2R_2"</span>, <span class="string">"R2R_3"</span> - discrete cosine transforms of types I-IV
   <span class="string">"R2R_4"</span>, <span class="string">"R2R_5"</span>, <span class="string">"R2R_6"</span>, <span class="string">"R2R_7"</span> - discrete sine transforms of types I-IV
    To specify the type of each dimension of a 2-dimensional real to real
    transform, use options of form <span class="string">"R2R_XX"</span>, for example, <span class="string">"R2R_02"</span> for a transform,
    which is of type <span class="string">"R2R_0"</span> in 1st dimension and  <span class="string">"R2R_2"</span> in the 2nd.

    - option of transform flag
    <span class="string">"ES"</span> (from <span class="string">"estimate"</span>) - no time in preparing the transform, but probably sub-optimal
       performance
    <span class="string">"M"</span> (from <span class="string">"measure"</span>)   - some time spend in finding the optimal way to do the transform
    <span class="string">"P"</span> (from <span class="string">"patient"</span>)   - more time spend in finding the optimal way to do the transform
    <span class="string">"EX"</span> (from <span class="string">"exhaustive"</span>) - the most optimal way is found
     This option should be chosen depending on how many transforms of the same size and
     type are going to be done. Planning is only done once, for the first transform of this
     size and type. Default is <span class="string">"ES"</span>.
   Examples of valid options: <span class="string">"Mag R2C M"</span> <span class="string">"Re R2R_11"</span> <span class="string">"Im R2C ES"</span> <span class="string">"PH R2HC EX"</span>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:Fill" href="src/TH1.cxx.html#VDA6OC">Fill</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> x)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*-*Increment bin with abscissa X by 1*-*-*-*-*-*-*-*-*-*-*


    if x is less than the low-edge of the first bin, the Underflow bin is incremented
    if x is greater than the upper edge of last bin, the Overflow bin is incremented

    If the storage of the sum of squares of weights has been triggered,
    via the function <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>, then the sum of the squares of weights is incremented
    by 1 in the bin corresponding to x.

   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:Fill%1" href="src/TH1.cxx.html#aPW.l">Fill</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> x, <a href="./ListOfTypes.html#Double_t">Double_t</a> w)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*Increment bin with abscissa X with a weight w*-*-*-*-*-*-*-*


    if x is less than the low-edge of the first bin, the Underflow bin is incremented
    if x is greater than the upper edge of last bin, the Overflow bin is incremented

    If the storage of the sum of squares of weights has been triggered,
    via the function <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>, then the sum of the squares of weights is incremented
    by w^2 in the bin corresponding to x.

   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:Fill%2" href="src/TH1.cxx.html#iMdYSD">Fill</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <a href="./ListOfTypes.html#Double_t">Double_t</a> w)</span><br />
<div class="funccomm"><pre> Increment bin with namex with a weight w

 if x is less than the low-edge of the first bin, the Underflow bin is incremented
 if x is greater than the upper edge of last bin, the Overflow bin is incremented

 If the storage of the sum of squares of weights has been triggered,
 via the function <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>, then the sum of the squares of weights is incremented
 by w^2 in the bin corresponding to x.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:FillN" href="src/TH1.cxx.html#fPKQoC">FillN</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> ntimes, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* x, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* w, <a href="./ListOfTypes.html#Int_t">Int_t</a> stride = 1)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*<a href="./TH1.html#TH1:Fill" title="Int_t TH1::Fill(Double_t x) or overloads">Fill</a> this histogram with an array x and weights w*-*-*-*-*


    ntimes:  number of entries in arrays x and w (array size must be ntimes*stride)
    x:       array of values to be histogrammed
    w:       array of weighs
    stride:  step size through arrays x and w

    If the storage of the sum of squares of weights has been triggered,
    via the function <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>, then the sum of the squares of weights is incremented
    by w[i]^2 in the bin corresponding to x[i].
    if w is NULL each entry is assumed a weight=1

   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:FillRandom" href="src/TH1.cxx.html#W64bZ">FillRandom</a>(<span class="keyword">const</span> <span class="keyword">char</span>* fname, <a href="./ListOfTypes.html#Int_t">Int_t</a> ntimes = 5000)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*<a href="./TH1.html#TH1:Fill" title="Int_t TH1::Fill(Double_t x) or overloads">Fill</a> histogram following distribution in function fname*-*-*-*


      The distribution contained in the function fname (<a href="./TF1.html">TF1</a>) is integrated
      over the channel contents for the bin range of this histogram.
      It is normalized to 1.
      Getting one random number implies:
        - Generating a random number between 0 and 1 (say r1)
        - Look in which bin in the normalized integral r1 corresponds to
        - <a href="./TH1.html#TH1:Fill" title="Int_t TH1::Fill(Double_t x) or overloads">Fill</a> histogram channel
      ntimes random numbers are generated

     One can also call <a href="./TF1.html">TF1</a>::<a href="./TF1.html#TF1:GetRandom" title="Double_t TF1::GetRandom() or overloads">GetRandom</a> to get a random variate from a function.

   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**-*-*-*-*-*-*-*
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:FillRandom%1" href="src/TH1.cxx.html#pR4KwC">FillRandom</a>(<a href="./TH1.html">TH1</a>* h, <a href="./ListOfTypes.html#Int_t">Int_t</a> ntimes = 5000)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*<a href="./TH1.html#TH1:Fill" title="Int_t TH1::Fill(Double_t x) or overloads">Fill</a> histogram following distribution in histogram h*-*-*-*


      The distribution contained in the histogram h (<a href="./TH1.html">TH1</a>) is integrated
      over the channel contents for the bin range of this histogram.
      It is normalized to 1.
      Getting one random number implies:
        - Generating a random number between 0 and 1 (say r1)
        - Look in which bin in the normalized integral r1 corresponds to
        - <a href="./TH1.html#TH1:Fill" title="Int_t TH1::Fill(Double_t x) or overloads">Fill</a> histogram channel
      ntimes random numbers are generated

    SPECIAL CASE when the target histogram has the same binning as the source.
   in this case we simply use a poisson distribution where
   the mean value per bin = bincontent/integral.

   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**-*-*-*-*-*-*-*
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:FindBin" href="src/TH1.cxx.html#QhEZED">FindBin</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> x, <a href="./ListOfTypes.html#Double_t">Double_t</a> y = 0, <a href="./ListOfTypes.html#Double_t">Double_t</a> z = 0)</span><br />
<div class="funccomm"><pre>   Return Global bin number corresponding to x,y,z


      2-D and 3-D histograms are represented with a one dimensional
      structure. This function tries to rebin the axis if the given point
      belongs to an under-/overflow bin.
      This has the advantage that all existing functions, such as
        <a href="./TH1.html#TH1:GetBinContent" title="Double_t TH1::GetBinContent(Int_t bin) or overloads">GetBinContent</a>, <a href="./TH1.html#TH1:GetBinError" title="Double_t TH1::GetBinError(Int_t bin) or overloads">GetBinError</a>, GetBinFunction work for all dimensions.
     See also <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:GetBin" title="Int_t TH1::GetBin(Int_t binx,Int_t biny=0,Int_t binz=0)">GetBin</a>, <a href="./TAxis.html">TAxis</a>::<a href="./TAxis.html#TAxis:FindBin" title="Int_t TAxis::FindBin(Double_t x) or overloads">FindBin</a> and <a href="./TAxis.html">TAxis</a>::<a href="./TAxis.html#TAxis:FindFixBin" title="Int_t TAxis::FindFixBin(Double_t x)">FindFixBin</a>
   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:FindFixBin" href="src/TH1.cxx.html#z5fYoB">FindFixBin</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> x, <a href="./ListOfTypes.html#Double_t">Double_t</a> y = 0, <a href="./ListOfTypes.html#Double_t">Double_t</a> z = 0) const</span><br />
<div class="funccomm"><pre>   Return Global bin number corresponding to x,y,z


      2-D and 3-D histograms are represented with a one dimensional
      structure. This function DOES not try to rebin the axis if the given
      point belongs to an under-/overflow bin.
      This has the advantage that all existing functions, such as
        <a href="./TH1.html#TH1:GetBinContent" title="Double_t TH1::GetBinContent(Int_t bin) or overloads">GetBinContent</a>, <a href="./TH1.html#TH1:GetBinError" title="Double_t TH1::GetBinError(Int_t bin) or overloads">GetBinError</a>, GetBinFunction work for all dimensions.
     See also <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:GetBin" title="Int_t TH1::GetBin(Int_t binx,Int_t biny=0,Int_t binz=0)">GetBin</a>, <a href="./TAxis.html">TAxis</a>::<a href="./TAxis.html#TAxis:FindBin" title="Int_t TAxis::FindBin(Double_t x) or overloads">FindBin</a> and <a href="./TAxis.html">TAxis</a>::<a href="./TAxis.html#TAxis:FindFixBin" title="Int_t TAxis::FindFixBin(Double_t x)">FindFixBin</a>
   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:FindFirstBinAbove" href="src/TH1.cxx.html#biA7FC">FindFirstBinAbove</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> threshold = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> axis = 1) const</span><br />
<div class="funccomm"><pre>find first bin with content &gt; threshold for axis (1=x, 2=y, 3=z)
if no bins with content &gt; threshold is found the function returns -1.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:FindLastBinAbove" href="src/TH1.cxx.html#Rp5cSC">FindLastBinAbove</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> threshold = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> axis = 1) const</span><br />
<div class="funccomm"><pre>find last bin with content &gt; threshold for axis (1=x, 2=y, 3=z)
if no bins with content &gt; threshold is found the function returns -1.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TObject.html">TObject</a> * <a class="funcname" name="TH1:FindObject" href="src/TH1.cxx.html#udH.qB">FindObject</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name) const</span><br />
<div class="funccomm"><pre> search object named name in the list of functions
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TObject.html">TObject</a> * <a class="funcname" name="TH1:FindObject%1" href="src/TH1.cxx.html#UrHHK">FindObject</a>(<span class="keyword">const</span> <a href="./TObject.html">TObject</a>* obj) const</span><br />
<div class="funccomm"><pre> search object obj in the list of functions
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TFitResultPtr.html">TFitResultPtr</a> <a class="funcname" name="TH1:Fit" href="src/TH1.cxx.html#fn.a2E">Fit</a>(<span class="keyword">const</span> <span class="keyword">char</span>* formula, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* goption = <span class="string">""</span>, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmin = 0, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmax = 0)</span><br />
<div class="funccomm"><pre>                     <a href="./TH1.html#TH1:Fit" title="TFitResultPtr TH1::Fit(const char* formula,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Double_t xmin=0,Double_t xmax=0) or overloads">Fit</a> histogram with function fname

      fname is the name of an already predefined function created by <a href="./TF1.html">TF1</a> or <a href="./TF2.html">TF2</a>
      Predefined functions such as gaus, expo and poln are automatically
      created by <a href="./ROOT.html">ROOT</a>.
      fname can also be a formula, accepted by the linear fitter (linear parts divided
      by <span class="string">"++"</span> sign), for example <span class="string">"x++sin(x)"</span> for fitting <span class="string">"[0]*x+[1]*sin(x)"</span>

  This function finds a pointer to the <a href="./TF1.html">TF1</a> object with name fname
  and calls <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Fit" title="TFitResultPtr TH1::Fit(const char* formula,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Double_t xmin=0,Double_t xmax=0) or overloads">Fit</a>(<a href="./TF1.html">TF1</a> *f1,...)
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TFitResultPtr.html">TFitResultPtr</a> <a class="funcname" name="TH1:Fit%1" href="src/TH1.cxx.html#MaLYND">Fit</a>(<a href="./TF1.html">TF1</a>* f1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* goption = <span class="string">""</span>, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmin = 0, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmax = 0)</span><br />
<div class="funccomm"><pre>                     <a href="./TH1.html#TH1:Fit" title="TFitResultPtr TH1::Fit(const char* formula,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Double_t xmin=0,Double_t xmax=0) or overloads">Fit</a> histogram with function f1


      <a href="./TH1.html#TH1:Fit" title="TFitResultPtr TH1::Fit(const char* formula,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Double_t xmin=0,Double_t xmax=0) or overloads">Fit</a> this histogram with function f1.

      The list of fit options is given in parameter option.
         option = <span class="string">"W"</span>  Set all weights to 1 for non empty bins; ignore error bars
                = <span class="string">"WW"</span> Set all weights to 1 including empty bins; ignore error bars
                = <span class="string">"I"</span>  Use integral of function in bin, normalized by the bin volume,
                       instead of value at bin center
                = <span class="string">"L"</span>  Use Loglikelihood method (default is chisquare method)
                = <span class="string">"WL"</span> Use Loglikelihood method and bin contents are not integer,
                       i.e. histogram is weighted (must have <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>() set)
                = <span class="string">"U"</span>  Use a User specified fitting algorithm (via SetFCN)
                = <span class="string">"Q"</span>  Quiet mode (minimum printing)
                = <span class="string">"V"</span>  Verbose mode (default is between Q and V)
                = <span class="string">"E"</span>  Perform better Errors estimation using Minos technique
                = <span class="string">"B"</span>  User defined parameter settings are used for predefined functions
                       like <span class="string">"gaus"</span>, <span class="string">"expo"</span>, <span class="string">"poln"</span>, <span class="string">"landau"</span>.
                       Use this option when you want to fix one or more parameters for these functions.
                = <span class="string">"M"</span>  More. Improve fit results.
                       It uses the IMPROVE command of <a href="./TMinuit.html">TMinuit</a> (see <a href="./TMinuit.html">TMinuit</a>::<a href="./TMinuit.html#TMinuit:mnimpr" title="void TMinuit::mnimpr()">mnimpr</a>).
                       This algorithm attempts to improve the found local minimum by searching for a
                       better one.
                = <span class="string">"R"</span>  Use the Range specified in the function range
                = <span class="string">"N"</span>  Do not store the graphics function, do not draw
                = <span class="string">"0"</span>  Do not plot the result of the fit. By default the fitted function
                       is drawn unless the option<span class="string">"N"</span> above is specified.
                = <span class="string">"+"</span>  <a href="./TH1.html#TH1:Add" title="void TH1::Add(TF1* h1,Double_t c1=1,Option_t* option=&quot;&quot;) or overloads">Add</a> this new fitted function to the list of fitted functions
                       (by default, any previous function is deleted)
                = <span class="string">"C"</span>  In case of linear fitting, don't calculate the chisquare
                       (saves time)
                = <span class="string">"F"</span>  If fitting a polN, switch to minuit fitter
                = <span class="string">"S"</span>  The result of the fit is returned in the <a href="./TFitResultPtr.html">TFitResultPtr</a>
                       (see below Access to the <a href="./TH1.html#TH1:Fit" title="TFitResultPtr TH1::Fit(const char* formula,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Double_t xmin=0,Double_t xmax=0) or overloads">Fit</a> Result)

      When the fit is drawn (by default), the parameter goption may be used
      to specify a list of graphics options. See <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Draw" title="void TH1::Draw(Option_t* option=&quot;&quot;)">Draw</a> for a complete
      list of these options.

      In order to use the Range option, one must first create a function
      with the expression to be fitted. For example, if your histogram
      has a defined range between -4 and 4 and you want to fit a gaussian
      only in the interval 1 to 3, you can do:
           <a href="./TF1.html">TF1</a> *f1 = new <a href="./TF1.html">TF1</a>(<span class="string">"f1"</span>, <span class="string">"gaus"</span>, 1, 3);
           histo-&gt;<a href="./TH1.html#TH1:Fit" title="TFitResultPtr TH1::Fit(const char* formula,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Double_t xmin=0,Double_t xmax=0) or overloads">Fit</a>(<span class="string">"f1"</span>, <span class="string">"R"</span>);

      Setting initial conditions

      Parameters must be initialized before invoking the <a href="./TH1.html#TH1:Fit" title="TFitResultPtr TH1::Fit(const char* formula,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Double_t xmin=0,Double_t xmax=0) or overloads">Fit</a> function.
      The setting of the parameter initial values is automatic for the
      predefined functions : poln, expo, gaus, landau. One can however disable
      this automatic computation by specifying the option <span class="string">"B"</span>.
      Note that if a predefined function is defined with an argument,
      eg, gaus(0), expo(1), you must specify the initial values for
      the parameters.
      You can specify boundary limits for some or all parameters via
           f1-&gt;SetParLimits(p_number, parmin, parmax);
      if parmin&gt;=parmax, the parameter is fixed
      Note that you are not forced to fix the limits for all parameters.
      For example, if you fit a function with 6 parameters, you can do:
        func-&gt;SetParameters(0, 3.1, 1.e-6, -8, 0, 100);
        func-&gt;SetParLimits(3, -10, -4);
        func-&gt;FixParameter(4, 0);
        func-&gt;SetParLimits(5, 1, 1);
      With this setup, parameters 0-&gt;2 can vary freely
      Parameter 3 has boundaries [-10,-4] with initial value -8
      Parameter 4 is fixed to 0
      Parameter 5 is fixed to 100.
      When the lower limit and upper limit are equal, the parameter is fixed.
      However to fix a parameter to 0, one must call the FixParameter function.

      Note that option <span class="string">"I"</span> gives better results but is slower.


      Changing the fitting objective function

     By default a chi square function is used for fitting. When option <span class="string">"L"</span> (or <span class="string">"LL"</span>) is used
     a Poisson likelihood function (see note below) is used.
     The functions are defined in the header <a href="./TH1.html#TH1:Fit" title="TFitResultPtr TH1::Fit(const char* formula,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Double_t xmin=0,Double_t xmax=0) or overloads">Fit</a>/Chi2Func.h or <a href="./TH1.html#TH1:Fit" title="TFitResultPtr TH1::Fit(const char* formula,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Double_t xmin=0,Double_t xmax=0) or overloads">Fit</a>/PoissonLikelihoodFCN and they
     are implemented using the routines FitUtil::EvaluateChi2 or FitUtil::EvaluatePoissonLogL in
     the file math/mathcore/src/FitUtil.cxx.
     To specify a User defined fitting function, specify option <span class="string">"U"</span> and
     call the following functions:
       <a href="./TVirtualFitter.html">TVirtualFitter</a>::<a href="./TVirtualFitter.html#TVirtualFitter:Fitter" title="TVirtualFitter* TVirtualFitter::Fitter(TObject* obj,Int_t maxpar=25)">Fitter</a>(myhist)-><a href="./TVirtualFitter.html#TVirtualFitter:SetFCN" title="void TVirtualFitter::SetFCN(void* fcn) or overloads">SetFCN</a>(MyFittingFunction)
     where MyFittingFunction is of type:
     extern <a href="./ListOfTypes.html#void">void</a> MyFittingFunction(<a href="./ListOfTypes.html#Int_t">Int_t</a> &amp;npar, <a href="./ListOfTypes.html#Double_t">Double_t</a> *gin, <a href="./ListOfTypes.html#Double_t">Double_t</a> &amp;f, <a href="./ListOfTypes.html#Double_t">Double_t</a> *u, <a href="./ListOfTypes.html#Int_t">Int_t</a> flag);

     Likelihood Fits

     When using option <span class="string">"L"</span> a likelihood fit is used instead of the default chi2 square fit.
     The likelihood is built assuming a Poisson probability density function for each bin.
     This method can then be used only when the bin content represents counts (i.e. errors are sqrt(N) ).
     The likelihood method has the advantage of treating correctly the empty bins and use them in the
     fit procedure.
     In the chi2 method the empty bins are skipped and not considered in the fit.
     The likelihood method, although a bit slower, it is the recommended method in case of low
     bin statistics, where the chi2 method may give incorrect results.

      Fitting a histogram of dimension N with a function of dimension N-1

     It is possible to fit a <a href="./TH2.html">TH2</a> with a <a href="./TF1.html">TF1</a> or a <a href="./TH3.html">TH3</a> with a <a href="./TF2.html">TF2</a>.
     In this case the option <span class="string">"Integral"</span> is not allowed and each cell has
     equal weight.

     Associated functions

     One or more object (typically a <a href="./TF1.html">TF1</a>*) can be added to the list
     of functions (<a href="./TH1.html#TH1:fFunctions" title="TList* TH1::fFunctions">fFunctions</a>) associated to each histogram.
     When <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Fit" title="TFitResultPtr TH1::Fit(const char* formula,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Double_t xmin=0,Double_t xmax=0) or overloads">Fit</a> is invoked, the fitted function is added to this list.
     Given an histogram h, one can retrieve an associated function
     with:  <a href="./TF1.html">TF1</a> *myfunc = h-&gt;<a href="./TH1.html#TH1:GetFunction" title="TF1* TH1::GetFunction(const char* name)">GetFunction</a>(<span class="string">"myfunc"</span>);

      Access to the fit result

     The function returns a <a href="./TFitResultPtr.html">TFitResultPtr</a> which can hold a  pointer to a <a href="./TFitResult.html">TFitResult</a> object.
     By default the <a href="./TFitResultPtr.html">TFitResultPtr</a> contains only the status of the fit which is return by an
     automatic conversion of the <a href="./TFitResultPtr.html">TFitResultPtr</a> to an integer. One can write in this case directly:
     <a href="./ListOfTypes.html#Int_t">Int_t</a> fitStatus =  h-&gt;<a href="./TH1.html#TH1:Fit" title="TFitResultPtr TH1::Fit(const char* formula,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Double_t xmin=0,Double_t xmax=0) or overloads">Fit</a>(myFunc)

     If the option <span class="string">"S"</span> is instead used, <a href="./TFitResultPtr.html">TFitResultPtr</a> contains the <a href="./TFitResult.html">TFitResult</a> and behaves as a smart
     pointer to it. For example one can do:
     <a href="./TFitResultPtr.html">TFitResultPtr</a> r = h-&gt;<a href="./TH1.html#TH1:Fit" title="TFitResultPtr TH1::Fit(const char* formula,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Double_t xmin=0,Double_t xmax=0) or overloads">Fit</a>(myFunc,<span class="string">"S"</span>);
     <a href="./TMatrixDSym.html">TMatrixDSym</a> cov = r-&gt;GetCovarianceMatrix();  //  to access the covariance matrix
     <a href="./ListOfTypes.html#Double_t">Double_t</a> chi2   = r-&gt;Chi2(); // to retrieve the fit chi2
     <a href="./ListOfTypes.html#Double_t">Double_t</a> par0   = r-&gt;Parameter(0); // retrieve the value for the parameter 0
     <a href="./ListOfTypes.html#Double_t">Double_t</a> err0   = r-&gt;ParError(0); // retrieve the error for the parameter 0
     r-&gt;<a href="./TH1.html#TH1:Print" title="void TH1::Print(Option_t* option=&quot;&quot;)">Print</a>(<span class="string">"V"</span>);     // print full information of fit including covariance matrix
     r-&gt;<a href="./TObject.html#TObject:Write" title="Int_t TObject::Write(const char* name=0,Int_t option=0,Int_t bufsize=0) or overloads">Write</a>();        // store the result in a file

     The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also
     from the fitted function.
     If the histogram is made persistent, the list of
     associated functions is also persistent. Given a pointer (see above)
     to an associated function myfunc, one can retrieve the function/fit
     parameters with calls such as:
       <a href="./ListOfTypes.html#Double_t">Double_t</a> chi2 = myfunc-&gt;GetChisquare();
       <a href="./ListOfTypes.html#Double_t">Double_t</a> par0 = myfunc-&gt;GetParameter(0); //value of 1st parameter
       <a href="./ListOfTypes.html#Double_t">Double_t</a> err0 = myfunc-&gt;GetParError(0);  //error on first parameter


     Access to the fit status

     The status of the fit can be obtained converting the <a href="./TFitResultPtr.html">TFitResultPtr</a> to an integer
     independently if the fit option <span class="string">"S"</span> is used or not:
     <a href="./TFitResultPtr.html">TFitResultPtr</a> r = h=&gt;<a href="./TH1.html#TH1:Fit" title="TFitResultPtr TH1::Fit(const char* formula,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Double_t xmin=0,Double_t xmax=0) or overloads">Fit</a>(myFunc,opt);
     <a href="./ListOfTypes.html#Int_t">Int_t</a> fitStatus = r;

     The fitStatus is 0 if the fit is OK (i.e no error occurred).
     The value of the fit status code is negative in case of an error not connected with the
     minimization procedure, for example  when a wrong function is used.
     Otherwise the return value is the one returned from the minimization procedure.
     When <a href="./TMinuit.html">TMinuit</a> (default case) or Minuit2 are used as minimizer the status returned is :
     fitStatus =  migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult.
     <a href="./TMinuit.html">TMinuit</a> will return 0 (for migrad, minos, hesse or improve) in case of success and 4 in
     case of error (see the documentation of <a href="./TMinuit.html">TMinuit</a>::<a href="./TMinuit.html#TMinuit:mnexcm" title="void TMinuit::mnexcm(const char* comand,Double_t* plist,Int_t llist,Int_t&amp; ierflg)">mnexcm</a>). So for example, for an error
     only in Minos but not in Migrad a fitStatus of 40 will be returned.
     Minuit2 will return also 0 in case of success and different values in migrad minos or
     hesse depending on the error. See in this case the documentation of
     Minuit2Minimizer::Minimize for the migradResult, Minuit2Minimizer::GetMinosError for the
     minosResult and Minuit2Minimizer::Hesse for the hesseResult.
     If other minimizers are used see their specific documentation for the status code returned.
     For example in the case of Fumili, for the status returned see <a href="./TFumili.html">TFumili</a>::<a href="./TFumili.html#TFumili:Minimize" title="Int_t TFumili::Minimize()">Minimize</a>.

      Excluding points

     Use <a href="./TF1.html">TF1</a>::<a href="./TF1.html#TF1:RejectPoint" title="void TF1::RejectPoint(Bool_t reject=kTRUE)">RejectPoint</a> inside your fitting function to exclude points
     within a certain range from the fit. Example:
     <a href="./ListOfTypes.html#Double_t">Double_t</a> fline(<a href="./ListOfTypes.html#Double_t">Double_t</a> *x, <a href="./ListOfTypes.html#Double_t">Double_t</a> *par)
     {
         if (x[0] &gt; 2.5 &amp;&amp; x[0] &lt; 3.5) {
           <a href="./TF1.html">TF1</a>::<a href="./TF1.html#TF1:RejectPoint" title="void TF1::RejectPoint(Bool_t reject=kTRUE)">RejectPoint</a>();
           return 0;
        }
        return par[0] + par[1]*x[0];
     }

     <a href="./ListOfTypes.html#void">void</a> exclude() {
        <a href="./TF1.html">TF1</a> *f1 = new <a href="./TF1.html">TF1</a>(<span class="string">"f1"</span>, <span class="string">"[0] +[1]*x +gaus(2)"</span>, 0, 5);
        f1-&gt;SetParameters(6, -1,5, 3, 0.2);
        <a href="./TH1F.html">TH1F</a> *h = new <a href="./TH1F.html">TH1F</a>(<span class="string">"h"</span>, <span class="string">"background + signal"</span>, 100, 0, 5);
        h-&gt;<a href="./TH1.html#TH1:FillRandom" title="void TH1::FillRandom(const char* fname,Int_t ntimes=5000) or overloads">FillRandom</a>(<span class="string">"f1"</span>, 2000);
        <a href="./TF1.html">TF1</a> *fline = new <a href="./TF1.html">TF1</a>(<span class="string">"fline"</span>, fline, 0, 5, 2);
        fline-&gt;SetParameters(2, -1);
        h-&gt;<a href="./TH1.html#TH1:Fit" title="TFitResultPtr TH1::Fit(const char* formula,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Double_t xmin=0,Double_t xmax=0) or overloads">Fit</a>(<span class="string">"fline"</span>, <span class="string">"l"</span>);
     }

      <a href="./TObject.html#TObject:Warning" title="void TObject::Warning(const char* method,const char* msgfmt)">Warning</a> when using the option <span class="string">"0"</span>

     When selecting the option <span class="string">"0"</span>, the fitted function is added to
     the list of functions of the histogram, but it is not drawn.
     You can undo what you disabled in the following way:
       h.<a href="./TH1.html#TH1:Fit" title="TFitResultPtr TH1::Fit(const char* formula,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Double_t xmin=0,Double_t xmax=0) or overloads">Fit</a>(<span class="string">"myFunction"</span>, <span class="string">"0"</span>); // fit, store function but do not draw
       h.<a href="./TH1.html#TH1:Draw" title="void TH1::Draw(Option_t* option=&quot;&quot;)">Draw</a>(); function is not drawn
       const <a href="./ListOfTypes.html#Int_t">Int_t</a> kNotDraw = 1&lt;&lt;9;
       h.<a href="./TH1.html#TH1:GetFunction" title="TF1* TH1::GetFunction(const char* name)">GetFunction</a>(<span class="string">"myFunction"</span>)-&gt;<a href="./TObject.html#TObject:ResetBit" title="void TObject::ResetBit(UInt_t f)">ResetBit</a>(kNotDraw);
       h.<a href="./TH1.html#TH1:Draw" title="void TH1::Draw(Option_t* option=&quot;&quot;)">Draw</a>();  // function is visible again

      Access to the Minimizer information during fitting

     This function calls, the <a href="./ROOT.html">ROOT</a>::Fit::FitObject function implemented in HFitImpl.cxx
     which uses the <a href="./ROOT.html">ROOT</a>::Fit::Fitter class. The Fitter class creates the objective fuction
     (e.g. chi2 or likelihood) and uses an implementation of the  Minimizer interface for minimizing
     the function.
     The default minimizer is Minuit (class <a href="./TMinuitMinimizer.html">TMinuitMinimizer</a> which calls <a href="./TMinuit.html">TMinuit</a>).
     The default  can be set in the resource file in etc/system.rootrc. For example
     Root.Fitter:      Minuit2
     A different fitter can also be set via <a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__MinimizerOptions.html">MinimizerOptions</a>::<a href="./ROOT__Math__MinimizerOptions.html#ROOT__Math__MinimizerOptions:SetDefaultMinimizer" title="void ROOT::Math::MinimizerOptions::SetDefaultMinimizer(const char* type,const char* algo=0)">SetDefaultMinimizer</a>
     (or <a href="./TVirtualFitter.html">TVirtualFitter</a>::<a href="./TVirtualFitter.html#TVirtualFitter:SetDefaultFitter" title="void TVirtualFitter::SetDefaultFitter(const char* name=&quot;&quot;)">SetDefaultFitter</a>).
     For example <a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__MinimizerOptions.html">MinimizerOptions</a>::<a href="./ROOT__Math__MinimizerOptions.html#ROOT__Math__MinimizerOptions:SetDefaultMinimizer" title="void ROOT::Math::MinimizerOptions::SetDefaultMinimizer(const char* type,const char* algo=0)">SetDefaultMinimizer</a>(<span class="string">"GSLMultiMin"</span>,<span class="string">"BFGS"</span>);
     will set the usdage of the BFGS algorithm of the GSL multi-dimensional minimization
     (implemented in libMathMore). <a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__MinimizerOptions.html">MinimizerOptions</a> can be used also to set other
     default options, like maximum number of function calls, minimization tolerance or print
     level. See the documentation of this class.

     For fitting linear functions (containing the <span class="string">"++"</span> sign<span class="string">" and polN functions,</span>
     the linear fitter is automatically initialized.

   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:FitPanel" href="src/TH1.cxx.html#LRamK">FitPanel</a>()</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*Display a panel with all histogram fit options*-*-*-*-*-*


      See class TFitPanel for example
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TH1.html">TH1</a> * <a class="funcname" name="TH1:GetAsymmetry" href="src/TH1.cxx.html#kuZUbB">GetAsymmetry</a>(<a href="./TH1.html">TH1</a>* h2, <a href="./ListOfTypes.html#Double_t">Double_t</a> c2 = 1, <a href="./ListOfTypes.html#Double_t">Double_t</a> dc2 = 0)</span><br />
<div class="funccomm"><pre>  return an histogram containing the asymmetry of this histogram with h2,
  where the asymmetry is defined as:

  Asymmetry = (h1 - h2)/(h1 + h2)  where h1 = this

  works for 1D, 2D, etc. histograms
  c2 is an optional argument that gives a relative weight between the two
  histograms, and dc2 is the error on this weight.  This is useful, for example,
  when forming an asymmetry between two histograms from 2 different data sets that
  need to be normalized to each other in some way.  The function calculates
  the errors asumming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)).

  example:  assuming 'h1' and 'h2' are already filled

     h3 = h1-&gt;<a href="./TH1.html#TH1:GetAsymmetry" title="TH1* TH1::GetAsymmetry(TH1* h2,Double_t c2=1,Double_t dc2=0)">GetAsymmetry</a>(h2)

  then 'h3' is created and filled with the asymmetry between 'h1' and 'h2';
  h1 and h2 are left intact.

  Note that it is the user's responsibility to manage the created histogram.

  code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun

 clone the histograms so top and bottom will have the
 correct dimensions:
 <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> just makes sure the errors will be computed properly
 when we form sums and ratios below.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:GetDefaultBufferSize" href="src/TH1.cxx.html#IXoRTE">GetDefaultBufferSize</a>()</span><br />
<div class="funccomm"><pre> static function
 return the default buffer size for automatic histograms
 the parameter <a href="./TH1.html#TH1:fgBufferSize" title="Int_t TH1::fgBufferSize">fgBufferSize</a> may be changed via <a href="./TH1.html#TH1:SetDefaultBufferSize" title="void TH1::SetDefaultBufferSize(Int_t buffersize=1000)">SetDefaultBufferSize</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Bool_t">Bool_t</a> <a class="funcname" name="TH1:GetDefaultSumw2" href="src/TH1.cxx.html#tDr6qC">GetDefaultSumw2</a>()</span><br />
<div class="funccomm"><pre> static function
 return <a href="./ListOfTypes.html#Bool_t">kTRUE</a> if <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> must be called when creating new histograms.
 see <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:SetDefaultSumw2" title="void TH1::SetDefaultSumw2(Bool_t sumw2=kTRUE)">SetDefaultSumw2</a>.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetEntries" href="src/TH1.cxx.html#iedKbB">GetEntries</a>() const</span><br />
<div class="funccomm"><pre> return the current number of entries
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetEffectiveEntries" href="src/TH1.cxx.html#nGY5DE">GetEffectiveEntries</a>() const</span><br />
<div class="funccomm"><pre> number of effective entries of the histogram,
 i.e. the number of unweighted entries a histogram would need to
 have the same statistical power as this histogram with possibly
 weighted entries (i.e. &lt;= <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:GetEntries" title="Double_t TH1::GetEntries()">GetEntries</a>())
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">char</span> * <a class="funcname" name="TH1:GetObjectInfo" href="src/TH1.cxx.html#O3mW.D">GetObjectInfo</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> px, <a href="./ListOfTypes.html#Int_t">Int_t</a> py) const</span><br />
<div class="funccomm"><pre>   Redefines <a href="./TObject.html">TObject</a>::<a href="./TObject.html#TObject:GetObjectInfo" title="char* TObject::GetObjectInfo(Int_t px,Int_t py)">GetObjectInfo</a>.
   Displays the histogram info (bin number, contents, integral up to bin
   corresponding to cursor position px,py

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TVirtualHistPainter.html">TVirtualHistPainter</a> * <a class="funcname" name="TH1:GetPainter" href="src/TH1.cxx.html#cQ35hE">GetPainter</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre> return pointer to painter
 if painter does not exist, it is created
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:GetQuantiles" href="src/TH1.cxx.html#m6tLPC">GetQuantiles</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nprobSum, <a href="./ListOfTypes.html#Double_t">Double_t</a>* q, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* probSum = 0)</span><br />
<div class="funccomm"><pre>  Compute Quantiles for this histogram
     Quantile x_q of a probability distribution Function F is defined as

        F(x_q) = q with 0 &lt;= q &lt;= 1.

     For instance the median x_0.5 of a distribution is defined as that value
     of the random variable for which the distribution function equals 0.5:

        F(x_0.5) = Probability(x &lt; x_0.5) = 0.5

  code from Eddy Offermann, Renaissance

 input parameters
   - this 1-d histogram (<a href="./TH1F.html">TH1F</a>,D,etc). Could also be a <a href="./TProfile.html">TProfile</a>
   - nprobSum maximum size of array q and size of array probSum (if given)
   - probSum array of positions where quantiles will be computed.
     if probSum is null, probSum will be computed internally and will
     have a size = number of bins + 1 in h. it will correspond to the
      quantiles calculated at the lowest edge of the histogram (quantile=0) and
     all the upper edges of the bins.
     if probSum is not null, it is assumed to contain at least nprobSum values.
  output
   - return value nq (&lt;=nprobSum) with the number of quantiles computed
   - array q filled with nq quantiles

  Note that the <a href="./TH1.html#TH1:Integral" title="Double_t TH1::Integral(Option_t* option=&quot;&quot;) or overloads">Integral</a> of the histogram is automatically recomputed
  if the number of entries is different of the number of entries when
  the integral was computed last time. In case you do not use the <a href="./TH1.html#TH1:Fill" title="Int_t TH1::Fill(Double_t x) or overloads">Fill</a>
  functions to fill your histogram, but <a href="./TH1.html#TH1:SetBinContent" title="void TH1::SetBinContent(Int_t bin,Double_t content) or overloads">SetBinContent</a>, you must call
  <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:ComputeIntegral" title="Double_t TH1::ComputeIntegral()">ComputeIntegral</a> before calling this function.

  Getting quantiles q from two histograms and storing results in a <a href="./TGraph.html">TGraph</a>,
   a so-called QQ-plot

     <a href="./TGraph.html">TGraph</a> *gr = new <a href="./TGraph.html">TGraph</a>(nprob);
     h1-&gt;<a href="./TH1.html#TH1:GetQuantiles" title="Int_t TH1::GetQuantiles(Int_t nprobSum,Double_t* q,const Double_t* probSum=0)">GetQuantiles</a>(nprob,gr-&gt;GetX());
     h2-&gt;<a href="./TH1.html#TH1:GetQuantiles" title="Int_t TH1::GetQuantiles(Int_t nprobSum,Double_t* q,const Double_t* probSum=0)">GetQuantiles</a>(nprob,gr-&gt;GetY());
     gr-&gt;<a href="./TH1.html#TH1:Draw" title="void TH1::Draw(Option_t* option=&quot;&quot;)">Draw</a>(<span class="string">"alp"</span>);

 Example:
     <a href="./ListOfTypes.html#void">void</a> quantiles() {
        // demo for quantiles
        const <a href="./ListOfTypes.html#Int_t">Int_t</a> nq = 20;
        <a href="./TH1F.html">TH1F</a> *h = new <a href="./TH1F.html">TH1F</a>(<span class="string">"h"</span>,<span class="string">"demo quantiles"</span>,100,-3,3);
        h-&gt;<a href="./TH1.html#TH1:FillRandom" title="void TH1::FillRandom(const char* fname,Int_t ntimes=5000) or overloads">FillRandom</a>(<span class="string">"gaus"</span>,5000);

        <a href="./ListOfTypes.html#Double_t">Double_t</a> xq[nq];  // position where to compute the quantiles in [0,1]
        <a href="./ListOfTypes.html#Double_t">Double_t</a> yq[nq];  // array to contain the quantiles
        for (<a href="./ListOfTypes.html#Int_t">Int_t</a> i=0;i&lt;nq;i++) xq[i] = <a href="./ListOfTypes.html#Float_t">Float_t</a>(i+1)/nq;
        h-&gt;<a href="./TH1.html#TH1:GetQuantiles" title="Int_t TH1::GetQuantiles(Int_t nprobSum,Double_t* q,const Double_t* probSum=0)">GetQuantiles</a>(nq,yq,xq);

        //show the original histogram in the top pad
        <a href="./TCanvas.html">TCanvas</a> *c1 = new <a href="./TCanvas.html">TCanvas</a>(<span class="string">"c1"</span>,<span class="string">"demo quantiles"</span>,10,10,700,900);
        c1-&gt;<a href="./TH1.html#TH1:Divide" title="void TH1::Divide(TF1* f1,Double_t c1=1) or overloads">Divide</a>(1,2);
        c1-&gt;cd(1);
        h-&gt;<a href="./TH1.html#TH1:Draw" title="void TH1::Draw(Option_t* option=&quot;&quot;)">Draw</a>();

        // show the quantiles in the bottom pad
        c1-&gt;cd(2);
        gPad-&gt;SetGrid();
        <a href="./TGraph.html">TGraph</a> *gr = new <a href="./TGraph.html">TGraph</a>(nq,xq,yq);
        gr-&gt;<a href="./TAttMarker.html#TAttMarker:SetMarkerStyle" title="void TAttMarker::SetMarkerStyle(Style_t mstyle=1)">SetMarkerStyle</a>(21);
        gr-&gt;<a href="./TH1.html#TH1:Draw" title="void TH1::Draw(Option_t* option=&quot;&quot;)">Draw</a>(<span class="string">"alp"</span>);
     }
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:FitOptionsMake" href="src/TH1.cxx.html#CCj86B">FitOptionsMake</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option, <a href="./Foption_t.html">Foption_t</a>&amp; Foption)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*Decode string choptin and fill fitOption structure*-*-*-*-*-*

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:GetBin" href="src/TH1.cxx.html#oOfEfE">GetBin</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> binz = 0) const</span><br />
<div class="funccomm"><pre>   -*-*-*-*Return Global bin number corresponding to binx,y,z*-*-*-*-*-*-*


      2-D and 3-D histograms are represented with a one dimensional
      structure.
      This has the advantage that all existing functions, such as
        <a href="./TH1.html#TH1:GetBinContent" title="Double_t TH1::GetBinContent(Int_t bin) or overloads">GetBinContent</a>, <a href="./TH1.html#TH1:GetBinError" title="Double_t TH1::GetBinError(Int_t bin) or overloads">GetBinError</a>, GetBinFunction work for all dimensions.

     In case of a TH1x, returns binx directly.
     see <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:GetBinXYZ" title="void TH1::GetBinXYZ(Int_t binglobal,Int_t&amp; binx,Int_t&amp; biny,Int_t&amp; binz)">GetBinXYZ</a> for the inverse transformation.

      Convention for numbering bins

      For all histogram types: nbins, xlow, xup
        bin = 0;       underflow bin
        bin = 1;       first bin with low-edge xlow INCLUDED
        bin = nbins;   last bin with upper-edge xup EXCLUDED
        bin = nbins+1; overflow bin
      In case of 2-D or 3-D histograms, a <span class="string">"global bin"</span> number is defined.
      For example, assuming a 3-D histogram with binx,biny,binz, the function
        <a href="./ListOfTypes.html#Int_t">Int_t</a> bin = h-&gt;<a href="./TH1.html#TH1:GetBin" title="Int_t TH1::GetBin(Int_t binx,Int_t biny=0,Int_t binz=0)">GetBin</a>(binx,biny,binz);
      returns a global/linearized bin number. This global bin is useful
      to access the bin information independently of the dimension.
   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:GetBinXYZ" href="src/TH1.cxx.html#Z5oL4C">GetBinXYZ</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binglobal, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; binx, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; biny, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; binz) const</span><br />
<div class="funccomm"><pre> return binx, biny, binz corresponding to the global bin number globalbin
 see <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:GetBin" title="Int_t TH1::GetBin(Int_t binx,Int_t biny=0,Int_t binz=0)">GetBin</a> function above
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetRandom" href="src/TH1.cxx.html#nV53k">GetRandom</a>() const</span><br />
<div class="funccomm"><pre> return a random number distributed according the histogram bin contents.
 This function checks if the bins integral exists. If not, the integral
 is evaluated, normalized to one.
 The integral is automatically recomputed if the number of entries
 is not the same then when the integral was computed.
 NB Only valid for 1-d histograms. Use GetRandom2 or 3 otherwise.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetBinContent" href="src/TH1.cxx.html#zQDvN">GetBinContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin) const</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*Return content of bin number bin

 Implemented in <a href="./TH1C.html">TH1C</a>,S,F,D

      Convention for numbering bins

      For all histogram types: nbins, xlow, xup
        bin = 0;       underflow bin
        bin = 1;       first bin with low-edge xlow INCLUDED
        bin = nbins;   last bin with upper-edge xup EXCLUDED
        bin = nbins+1; overflow bin
      In case of 2-D or 3-D histograms, a <span class="string">"global bin"</span> number is defined.
      For example, assuming a 3-D histogram with binx,biny,binz, the function
        <a href="./ListOfTypes.html#Int_t">Int_t</a> bin = h-&gt;<a href="./TH1.html#TH1:GetBin" title="Int_t TH1::GetBin(Int_t binx,Int_t biny=0,Int_t binz=0)">GetBin</a>(binx,biny,binz);
      returns a global/linearized bin number. This global bin is useful
      to access the bin information independently of the dimension.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetBinContent%1" href="src/TH1.cxx.html#BJ1HNE">GetBinContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny) const</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*Return content of bin number binx, biny

 NB: Function to be called for 2-D histograms only
 see convention for numbering bins in <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:GetBin" title="Int_t TH1::GetBin(Int_t binx,Int_t biny=0,Int_t binz=0)">GetBin</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetBinContent%2" href="src/TH1.cxx.html#OEeXiC">GetBinContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny, <a href="./ListOfTypes.html#Int_t">Int_t</a> binz) const</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*Return content of bin number binx,biny,binz

 NB: Function to be called for 3-D histograms only
 see convention for numbering bins in <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:GetBin" title="Int_t TH1::GetBin(Int_t binx,Int_t biny=0,Int_t binz=0)">GetBin</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetBinWithContent" href="src/TH1.cxx.html#aDineB">GetBinWithContent</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> c, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> firstx = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> lastx = 0, <a href="./ListOfTypes.html#Double_t">Double_t</a> maxdiff = 0) const</span><br />
<div class="funccomm"><pre> compute first binx in the range [firstx,lastx] for which
 diff = abs(bin_content-c) &lt;= maxdiff
 In case several bins in the specified range with diff=0 are found
 the first bin found is returned in binx.
 In case several bins in the specified range satisfy diff &lt;=maxdiff
 the bin with the smallest difference is returned in binx.
 In all cases the function returns the smallest difference.

 NOTE1: if firstx &lt;= 0, firstx is set to bin 1
        if (lastx &lt; firstx then firstx is set to the number of bins
        ie if firstx=0 and lastx=0 (default) the search is on all bins.
 NOTE2: if maxdiff=0 (default), the first bin with content=c is returned.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TAxis.html">TAxis</a> * <a class="funcname" name="TH1:GetXaxis" href="src/TH1.cxx.html#u5i7IC">GetXaxis</a>() const</span><br />
<div class="funccomm"><pre> return a pointer to the X axis object
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TAxis.html">TAxis</a> * <a class="funcname" name="TH1:GetYaxis" href="src/TH1.cxx.html#W3i7IC">GetYaxis</a>() const</span><br />
<div class="funccomm"><pre> return a pointer to the Y axis object
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TAxis.html">TAxis</a> * <a class="funcname" name="TH1:GetZaxis" href="src/TH1.cxx.html#y0i7IC">GetZaxis</a>() const</span><br />
<div class="funccomm"><pre> return a pointer to the Z axis object
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:Interpolate" href="src/TH1.cxx.html#kRFcFC">Interpolate</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> x)</span><br />
<div class="funccomm"><pre> Given a point x, approximates the value via linear interpolation
 based on the two nearest bin centers
 Andy Mastbaum 10/21/08
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:Interpolate%1" href="src/TH1.cxx.html#ZgL3NC">Interpolate</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> x, <a href="./ListOfTypes.html#Double_t">Double_t</a> y)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:Interpolate%2" href="src/TH1.cxx.html#R9ApYD">Interpolate</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> x, <a href="./ListOfTypes.html#Double_t">Double_t</a> y, <a href="./ListOfTypes.html#Double_t">Double_t</a> z)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Bool_t">Bool_t</a> <a class="funcname" name="TH1:IsBinOverflow" href="src/TH1.cxx.html#XZ0QTC">IsBinOverflow</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin) const</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Bool_t">Bool_t</a> <a class="funcname" name="TH1:IsBinUnderflow" href="src/TH1.cxx.html#bNBy">IsBinUnderflow</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin) const</span><br />
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:LabelsDeflate" href="src/TH1.cxx.html#XEv3PC">LabelsDeflate</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</span><br />
<div class="funccomm"><pre> Reduce the number of bins for the axis passed in the option to the number of bins having a label.
 The method will remove only the extra bins existing after the last <span class="string">"labeled"</span> bin.
 Note that if there are <span class="string">"un-labeled"</span> bins present between <span class="string">"labeled"</span> bins they will not be removed
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:LabelsInflate" href="src/TH1.cxx.html#BsHfIC">LabelsInflate</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</span><br />
<div class="funccomm"><pre> Double the number of bins for axis.
 Refill histogram
 This function is called by <a href="./TAxis.html">TAxis</a>::<a href="./TAxis.html#TAxis:FindBin" title="Int_t TAxis::FindBin(Double_t x) or overloads">FindBin</a>(const <a href="./ListOfTypes.html#char">char</a> *label)
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:LabelsOption" href="src/TH1.cxx.html#z8Y6S">LabelsOption</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">"h"</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</span><br />
<div class="funccomm"><pre>  Set option(s) to draw axis with labels
  option = <span class="string">"a"</span> sort by alphabetic order
         = <span class="string">"&gt;"</span> sort by decreasing values
         = <span class="string">"&lt;"</span> sort by increasing values
         = <span class="string">"h"</span> draw labels horizontal
         = <span class="string">"v"</span> draw labels vertical
         = <span class="string">"u"</span> draw labels up (end of label right adjusted)
         = <span class="string">"d"</span> draw labels down (start of label left adjusted)
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Bool_t">Bool_t</a> <a class="funcname" name="TH1:SameLimitsAndNBins" href="src/TH1.cxx.html#Hbtd_D">SameLimitsAndNBins</a>(<span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>&amp; axis1, <span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>&amp; axis2)</span><br />
<div class="funccomm"><pre> Same limits and bins.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Bool_t">Bool_t</a> <a class="funcname" name="TH1:RecomputeAxisLimits" href="src/TH1.cxx.html#VwhIWD">RecomputeAxisLimits</a>(<a href="./TAxis.html">TAxis</a>&amp; destAxis, <span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>&amp; anAxis)</span><br />
<div class="funccomm"><pre> Finds new limits for the axis for the <a href="./TH1.html#TH1:Merge" title="Long64_t TH1::Merge(TCollection* list)">Merge</a> function.
 returns <a href="./ListOfTypes.html#bool">false</a> if the limits are incompatible
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TH1:Merge" href="src/TH1.cxx.html#GUWt6D">Merge</a>(<a href="./TCollection.html">TCollection</a>* list)</span><br />
<div class="funccomm"><pre> <a href="./TH1.html#TH1:Add" title="void TH1::Add(TF1* h1,Double_t c1=1,Option_t* option=&quot;&quot;) or overloads">Add</a> all histograms in the collection to this histogram.
 This function computes the min/max for the x axis,
 compute a new number of bins, if necessary,
 add bin contents, errors and statistics.
 If all histograms have bin labels, bins with identical labels
 will be merged, no matter what their order is.
 If overflows are present and limits are different the function will fail.
 The function returns the total number of entries in the result histogram
 if the merge is successful, -1 otherwise.

 IMPORTANT remark. The axis x may have different number
 of bins and different limits, BUT the largest bin width must be
 a multiple of the smallest bin width and the upper limit must also
 be a multiple of the bin width.
 Example:
 <a href="./ListOfTypes.html#void">void</a> atest() {
    <a href="./TH1F.html">TH1F</a> *h1 = new <a href="./TH1F.html">TH1F</a>(<span class="string">"h1"</span>,<span class="string">"h1"</span>,110,-110,0);
    <a href="./TH1F.html">TH1F</a> *h2 = new <a href="./TH1F.html">TH1F</a>(<span class="string">"h2"</span>,<span class="string">"h2"</span>,220,0,110);
    <a href="./TH1F.html">TH1F</a> *h3 = new <a href="./TH1F.html">TH1F</a>(<span class="string">"h3"</span>,<span class="string">"h3"</span>,330,-55,55);
    <a href="./TRandom.html">TRandom</a> r;
    for (<a href="./ListOfTypes.html#Int_t">Int_t</a> i=0;i&lt;10000;i++) {
       h1-&gt;<a href="./TH1.html#TH1:Fill" title="Int_t TH1::Fill(Double_t x) or overloads">Fill</a>(r.Gaus(-55,10));
       h2-&gt;<a href="./TH1.html#TH1:Fill" title="Int_t TH1::Fill(Double_t x) or overloads">Fill</a>(r.Gaus(55,10));
       h3-&gt;<a href="./TH1.html#TH1:Fill" title="Int_t TH1::Fill(Double_t x) or overloads">Fill</a>(r.Gaus(0,10));
    }

    <a href="./TList.html">TList</a> *list = new <a href="./TList.html">TList</a>;
    list-&gt;<a href="./TH1.html#TH1:Add" title="void TH1::Add(TF1* h1,Double_t c1=1,Option_t* option=&quot;&quot;) or overloads">Add</a>(h1);
    list-&gt;<a href="./TH1.html#TH1:Add" title="void TH1::Add(TF1* h1,Double_t c1=1,Option_t* option=&quot;&quot;) or overloads">Add</a>(h2);
    list-&gt;<a href="./TH1.html#TH1:Add" title="void TH1::Add(TF1* h1,Double_t c1=1,Option_t* option=&quot;&quot;) or overloads">Add</a>(h3);
    <a href="./TH1F.html">TH1F</a> *h = (<a href="./TH1F.html">TH1F</a>*)h1-&gt;<a href="./TNamed.html#TNamed:Clone" title="TObject* TNamed::Clone(const char* newname=&quot;&quot;)">Clone</a>(<span class="string">"h"</span>);
    h-&gt;<a href="./TH1.html#TH1:Reset" title="void TH1::Reset(Option_t* option=&quot;&quot;)">Reset</a>();
    h.<a href="./TH1.html#TH1:Merge" title="Long64_t TH1::Merge(TCollection* list)">Merge</a>(list);
    h-&gt;<a href="./TH1.html#TH1:Draw" title="void TH1::Draw(Option_t* option=&quot;&quot;)">Draw</a>();
 }
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Multiply" href="src/TH1.cxx.html#wluYKC">Multiply</a>(<a href="./TF1.html">TF1</a>* h1, <a href="./ListOfTypes.html#Double_t">Double_t</a> c1 = 1)</span><br />
<div class="funccomm"><pre> Performs the operation: this = this*c1*f1
 if errors are defined (see <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>), errors are also recalculated.

 Only bins inside the function range are recomputed.
 IMPORTANT NOTE: If you intend to use the errors of this histogram later
 you should call <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> before making this operation.
 This is particularly important if you fit the histogram after <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Multiply" title="void TH1::Multiply(TF1* h1,Double_t c1=1) or overloads">Multiply</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Multiply%1" href="src/TH1.cxx.html#jBDYrC">Multiply</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h1)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*-*-*<a href="./TH1.html#TH1:Multiply" title="void TH1::Multiply(TF1* h1,Double_t c1=1) or overloads">Multiply</a> this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*


   this = this*h1

   If errors of this are available (<a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>), errors are recalculated.
   Note that if h1 has <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> set, <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> is automatically called for this
   if not already set.

 IMPORTANT NOTE: If you intend to use the errors of this histogram later
 you should call <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> before making this operation.
 This is particularly important if you fit the histogram after <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Multiply" title="void TH1::Multiply(TF1* h1,Double_t c1=1) or overloads">Multiply</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Multiply%2" href="src/TH1.cxx.html#ygJMiB">Multiply</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h1, <span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h2, <a href="./ListOfTypes.html#Double_t">Double_t</a> c1 = 1, <a href="./ListOfTypes.html#Double_t">Double_t</a> c2 = 1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre>   -*-*-*Replace contents of this histogram by multiplication of h1 by h2*-*


   this = (c1*h1)*(c2*h2)

   If errors of this are available (<a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>), errors are recalculated.
   Note that if h1 or h2 have <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> set, <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> is automatically called for this
   if not already set.

 IMPORTANT NOTE: If you intend to use the errors of this histogram later
 you should call <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> before making this operation.
 This is particularly important if you fit the histogram after <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Multiply" title="void TH1::Multiply(TF1* h1,Double_t c1=1) or overloads">Multiply</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Paint" href="src/TH1.cxx.html#GBfgEC">Paint</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*Control routine to paint any kind of histograms*-*-*-*-*-*-*


  This function is automatically called by <a href="./TCanvas.html">TCanvas</a>::<a href="./TCanvas.html#TCanvas:Update" title="void TCanvas::Update()">Update</a>.
  (see <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Draw" title="void TH1::Draw(Option_t* option=&quot;&quot;)">Draw</a> for the list of options)
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TH1.html">TH1</a> * <a class="funcname" name="TH1:Rebin" href="src/TH1.cxx.html#HvzlIB">Rebin</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> ngroup = 2, <span class="keyword">const</span> <span class="keyword">char</span>* newname = <span class="string">""</span>, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* xbins = 0)</span><br />
<div class="funccomm"><pre>   <a href="./TH1.html#TH1:Rebin" title="TH1* TH1::Rebin(Int_t ngroup=2,const char* newname=&quot;&quot;,const Double_t* xbins=0)">Rebin</a> this histogram

  -case 1  xbins=0
   If newname is blank (default), the current histogram is modified and
   a pointer to it is returned.

   If newname is not blank, the current histogram is not modified, and a
   new histogram is returned which is a <a href="./TNamed.html#TNamed:Clone" title="TObject* TNamed::Clone(const char* newname=&quot;&quot;)">Clone</a> of the current histogram
   with its name set to newname.

   The parameter ngroup indicates how many bins of this have to be merged
   into one bin of the result.

   If the original histogram has errors stored (via <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>), the resulting
   histograms has new errors correctly calculated.

   examples: if h1 is an existing <a href="./TH1F.html">TH1F</a> histogram with 100 bins
     h1-&gt;<a href="./TH1.html#TH1:Rebin" title="TH1* TH1::Rebin(Int_t ngroup=2,const char* newname=&quot;&quot;,const Double_t* xbins=0)">Rebin</a>();  //merges two bins in one in h1: previous contents of h1 are lost
     h1-&gt;<a href="./TH1.html#TH1:Rebin" title="TH1* TH1::Rebin(Int_t ngroup=2,const char* newname=&quot;&quot;,const Double_t* xbins=0)">Rebin</a>(5); //merges five bins in one in h1
     <a href="./TH1F.html">TH1F</a> *hnew = h1-&gt;<a href="./TH1.html#TH1:Rebin" title="TH1* TH1::Rebin(Int_t ngroup=2,const char* newname=&quot;&quot;,const Double_t* xbins=0)">Rebin</a>(5,<span class="string">"hnew"</span>); // creates a new histogram hnew
                                       // merging 5 bins of h1 in one bin

   NOTE:  If ngroup is not an exact divider of the number of bins,
          the top limit of the rebinned histogram is reduced
          to the upper edge of the last bin that can make a complete
          group. The remaining bins are added to the overflow bin.
          Statistics will be recomputed from the new bin contents.

  -case 2  xbins!=0
   A new histogram is created (you should specify newname).
   The parameter ngroup is the number of variable size bins in the created histogram.
   The array xbins must contain ngroup+1 elements that represent the low-edges
   of the bins.
   If the original histogram has errors stored (via <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>), the resulting
   histograms has new errors correctly calculated.

   NOTE:  The bin edges specified in xbins should correspond to bin edges
          in the original histogram. If a bin edge in the new histogram is
          in the middle of a bin in the original histogram, all entries in
          the split bin in the original histogram will be transfered to the
          lower of the two possible bins in the new histogram. This is
          probably not what you want.

   examples: if h1 is an existing <a href="./TH1F.html">TH1F</a> histogram with 100 bins
     <a href="./ListOfTypes.html#Double_t">Double_t</a> xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin
     h1-&gt;<a href="./TH1.html#TH1:Rebin" title="TH1* TH1::Rebin(Int_t ngroup=2,const char* newname=&quot;&quot;,const Double_t* xbins=0)">Rebin</a>(24,<span class="string">"hnew"</span>,xbins);  //creates a new variable bin size histogram hnew
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Bool_t">Bool_t</a> <a class="funcname" name="TH1:FindNewAxisLimits" href="src/TH1.cxx.html#swTr2D">FindNewAxisLimits</a>(<span class="keyword">const</span> <a href="./TAxis.html">TAxis</a>* axis, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a> point, <a href="./ListOfTypes.html#Double_t">Double_t</a>&amp; newMin, <a href="./ListOfTypes.html#Double_t">Double_t</a>&amp; newMax)</span><br />
<div class="funccomm"><pre> finds new limits for the axis so that *point* is within the range and
 the limits are compatible with the previous ones (see <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Merge" title="Long64_t TH1::Merge(TCollection* list)">Merge</a>).
 new limits are put into *newMin* and *newMax* variables.
 axis - axis whose limits are to be recomputed
 point - point that should fit within the new axis limits
 newMin - new minimum will be stored here
 newMax - new maximum will be stored here.
 <a href="./ListOfTypes.html#bool">false</a> if failed (e.g. if the initial axis limits are wrong
 or the new range is more than 2^64 times the old one).
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:RebinAxis" href="src/TH1.cxx.html#Gtcl3E">RebinAxis</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> x, <a href="./TAxis.html">TAxis</a>* axis)</span><br />
<div class="funccomm"><pre> Histogram is resized along axis such that x is in the axis range.
 The new axis limits are recomputed by doubling iteratively
 the current axis range until the specified value x is within the limits.
 The algorithm makes a copy of the histogram, then loops on all bins
 of the old histogram to fill the rebinned histogram.
 Takes into account errors (<a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>) if any.
 The algorithm works for 1-d, 2-D and 3-D histograms.
 The bit <a href="./TH1.html#TH1:kCanRebin" title="const enum TH1:: TH1::kCanRebin">kCanRebin</a> must be set before invoking this function.
  Ex:  h-&gt;<a href="./TObject.html#TObject:SetBit" title="void TObject::SetBit(UInt_t f,Bool_t set) or overloads">SetBit</a>(<a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:kCanRebin" title="const enum TH1:: TH1::kCanRebin">kCanRebin</a>);
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:RecursiveRemove" href="src/TH1.cxx.html#OIZQrE">RecursiveRemove</a>(<a href="./TObject.html">TObject</a>* obj)</span><br />
<div class="funccomm"><pre> Recursively remove object from the list of functions
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Scale" href="src/TH1.cxx.html#HLKZ1D">Scale</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> c1 = 1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre>   -*-*-*<a href="./TH1.html#TH1:Multiply" title="void TH1::Multiply(TF1* h1,Double_t c1=1) or overloads">Multiply</a> this histogram by a constant c1*-*-*-*-*-*-*-*-*


   this = c1*this

 Note that both contents and errors(if any) are scaled.
 This function uses the services of <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Add" title="void TH1::Add(TF1* h1,Double_t c1=1,Option_t* option=&quot;&quot;) or overloads">Add</a>

 IMPORTANT NOTE: If you intend to use the errors of this histogram later
 you should call <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> before making this operation.
 This is particularly important if you fit the histogram after <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Scale" title="void TH1::Scale(Double_t c1=1,Option_t* option=&quot;&quot;)">Scale</a>

 One can scale an histogram such that the bins integral is equal to
 the normalization parameter via <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Scale" title="void TH1::Scale(Double_t c1=1,Option_t* option=&quot;&quot;)">Scale</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> norm), where norm
 is the desired normalization divided by the integral of the histogram.

 If option contains <span class="string">"width"</span> the bin contents and errors are divided
 by the bin width.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetDefaultBufferSize" href="src/TH1.cxx.html#ZuRX_B">SetDefaultBufferSize</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> buffersize = 1000)</span><br />
<div class="funccomm"><pre> static function to set the default buffer size for automatic histograms.
 When an histogram is created with one of its axis lower limit greater
 or equal to its upper limit, the function <a href="./TH1.html#TH1:SetBuffer" title="void TH1::SetBuffer(Int_t buffersize,Option_t* option=&quot;&quot;)">SetBuffer</a> is automatically
 called with the default buffer size.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetDefaultSumw2" href="src/TH1.cxx.html#j2fCI">SetDefaultSumw2</a>(<a href="./ListOfTypes.html#Bool_t">Bool_t</a> sumw2 = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</span><br />
<div class="funccomm"><pre> static function.
 When this static function is called with sumw2=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>, all new
 histograms will automatically activate the storage
 of the sum of squares of errors, ie <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a> is automatically called.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetTitle" href="src/TH1.cxx.html#TToUsB">SetTitle</a>(<span class="keyword">const</span> <span class="keyword">char</span>* title)</span><br />
<div class="funccomm"><pre> Change (i.e. set) the title

   if title is in the form <span class="string">"stringt;stringx;stringy;stringz"</span>
   the histogram title is set to stringt, the x axis title to stringx,
   the y axis title to stringy, and the z axis title to stringz.
   To insert the character <span class="string">";"</span> in one of the titles, one should use <span class="string">"#;"</span>
   or <span class="string">"#semicolon"</span>.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SmoothArray" href="src/TH1.cxx.html#HA.OVD">SmoothArray</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> NN, <a href="./ListOfTypes.html#Double_t">Double_t</a>* XX, <a href="./ListOfTypes.html#Int_t">Int_t</a> ntimes = 1)</span><br />
<div class="funccomm"><pre> smooth array xx, translation of Hbook routine hsmoof.F
 based on algorithm 353QH twice presented by J. Friedman
 in Proc.of the 1974 CERN School of Computing, Norway, 11-24 August, 1974.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Smooth" href="src/TH1.cxx.html#PEyrRD">Smooth</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> ntimes = 1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre> <a href="./TH1.html#TH1:Smooth" title="void TH1::Smooth(Int_t ntimes=1,Option_t* option=&quot;&quot;)">Smooth</a> bin contents of this histogram.
 if option contains <span class="string">"R"</span> smoothing is applied only to the bins
 defined in the X axis range (default is to smooth all bins)
 Bin contents are replaced by their smooth values.
 Errors (if any) are not modified.
 the smoothing procedure is repeated ntimes (default=1)
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:StatOverflows" href="src/TH1.cxx.html#hz.HQC">StatOverflows</a>(<a href="./ListOfTypes.html#Bool_t">Bool_t</a> flag = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</span><br />
<div class="funccomm"><pre>  if flag=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>, underflows and overflows are used by the <a href="./TH1.html#TH1:Fill" title="Int_t TH1::Fill(Double_t x) or overloads">Fill</a> functions
  in the computation of statistics (mean value, RMS).
  By default, underflows or overflows are not used.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Streamer" href="src/TH1.cxx.html#V1PTAC">Streamer</a>(<a href="./TBuffer.html">TBuffer</a>&amp; b)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*Stream a class object*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Print" href="src/TH1.cxx.html#E8oYB">Print</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) const</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*<a href="./TH1.html#TH1:Print" title="void TH1::Print(Option_t* option=&quot;&quot;)">Print</a> some global quantities for this histogram*-*-*-*-*-*-*-*


  If option <span class="string">"base"</span> is given, number of bins and ranges are also printed
  If option <span class="string">"range"</span> is given, bin contents and errors are also printed
                     for all bins in the current range (default 1--&gt;nbins)
  If option <span class="string">"all"</span> is given, bin contents and errors are also printed
                     for all bins including under and overflows.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Rebuild" href="src/TH1.cxx.html#WxNr2B">Rebuild</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre> Using the current bin info, recompute the arrays for contents and errors
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Reset" href="src/TH1.cxx.html#kKVg0B">Reset</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*<a href="./TH1.html#TH1:Reset" title="void TH1::Reset(Option_t* option=&quot;&quot;)">Reset</a> this histogram: contents, errors, etc*-*-*-*-*-*-*-*


 if option <span class="string">"ICE"</span> is specified, resets only <a href="./TH1.html#TH1:Integral" title="Double_t TH1::Integral(Option_t* option=&quot;&quot;) or overloads">Integral</a>, Contents and Errors.
 if option <span class="string">"ICES"</span> is specified, resets only <a href="./TH1.html#TH1:Integral" title="Double_t TH1::Integral(Option_t* option=&quot;&quot;) or overloads">Integral</a>, Contents , Errors and Statistics
                  This option is used
 if option <span class="string">"M"</span>   is specified, resets also Minimum and Maximum
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SavePrimitive" href="src/TH1.cxx.html#cc4.sE">SavePrimitive</a>(<a href="./ListOfTypes.html#ostream">ostream</a>&amp; out, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre> Save primitive as a C++ statement(s) on output stream out
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SavePrimitiveHelp" href="src/TH1.cxx.html#HTHNlD">SavePrimitiveHelp</a>(<a href="./ListOfTypes.html#ostream">ostream</a>&amp; out, <span class="keyword">const</span> <span class="keyword">char</span>* hname, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre> helper function for the <a href="./TH1.html#TH1:SavePrimitive" title="void TH1::SavePrimitive(ostream&amp; out,Option_t* option=&quot;&quot;)">SavePrimitive</a> functions from <a href="./TH1.html">TH1</a>
 or classes derived from <a href="./TH1.html">TH1</a>, eg <a href="./TProfile.html">TProfile</a>, <a href="./TProfile2D.html">TProfile2D</a>.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:UseCurrentStyle" href="src/TH1.cxx.html#dBcjkE">UseCurrentStyle</a>()</span><br />
<div class="funccomm"><pre>   <a href="./TH1.html#TH1:Copy" title="void TH1::Copy(TObject&amp; hnew)">Copy</a> current attributes from/to current style
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetMean" href="src/TH1.cxx.html#HP7VfE">GetMean</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> axis = 1) const</span><br />
<div class="funccomm"><pre>  For axis = 1,2 or 3 returns the mean value of the histogram along
  X,Y or Z axis.
  For axis = 11, 12, 13 returns the standard error of the mean value
  of the histogram along X, Y or Z axis

  Note that the mean value/RMS is computed using the bins in the currently
  defined range (see <a href="./TAxis.html">TAxis</a>::<a href="./TAxis.html#TAxis:SetRange" title="void TAxis::SetRange(Int_t first=0,Int_t last=0)">SetRange</a>). By default the range includes
  all bins from 1 to nbins included, excluding underflows and overflows.
  To force the underflows and overflows in the computation, one must
  call the static function <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:StatOverflows" title="void TH1::StatOverflows(Bool_t flag=kTRUE)">StatOverflows</a>(<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) before filling
  the histogram.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetMeanError" href="src/TH1.cxx.html#JzWwsC">GetMeanError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> axis = 1) const</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*Return standard error of mean of this histogram along the X axis*-*-*-*-*

  Note that the mean value/RMS is computed using the bins in the currently
  defined range (see <a href="./TAxis.html">TAxis</a>::<a href="./TAxis.html#TAxis:SetRange" title="void TAxis::SetRange(Int_t first=0,Int_t last=0)">SetRange</a>). By default the range includes
  all bins from 1 to nbins included, excluding underflows and overflows.
  To force the underflows and overflows in the computation, one must
  call the static function <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:StatOverflows" title="void TH1::StatOverflows(Bool_t flag=kTRUE)">StatOverflows</a>(<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) before filling
  the histogram.
  Also note, that although the definition of standard error doesn't include the
  assumption of normality, many uses of this feature implicitly assume it.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetRMS" href="src/TH1.cxx.html#tv3dGD">GetRMS</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> axis = 1) const</span><br />
<div class="funccomm"><pre>  For axis = 1,2 or 3 returns the Sigma value of the histogram along
  X, Y or Z axis
  For axis = 11, 12 or 13 returns the error of RMS estimation along
  X, Y or Z axis for Normal distribution

     Note that the mean value/sigma is computed using the bins in the currently
  defined range (see <a href="./TAxis.html">TAxis</a>::<a href="./TAxis.html#TAxis:SetRange" title="void TAxis::SetRange(Int_t first=0,Int_t last=0)">SetRange</a>). By default the range includes
  all bins from 1 to nbins included, excluding underflows and overflows.
  To force the underflows and overflows in the computation, one must
  call the static function <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:StatOverflows" title="void TH1::StatOverflows(Bool_t flag=kTRUE)">StatOverflows</a>(<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) before filling
  the histogram.
  Note that this function returns the Standard Deviation (Sigma)
  of the distribution (not RMS).
  The Sigma estimate is computed as Sqrt((1/N)*(Sum(x_i-x_mean)^2))
  The name <span class="string">"RMS"</span> was introduced many years ago (Hbook/PAW times).
  We kept the name for continuity.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetRMSError" href="src/TH1.cxx.html#ZYxvtB">GetRMSError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> axis = 1) const</span><br />
<div class="funccomm"><pre>  Return error of RMS estimation for Normal distribution

  Note that the mean value/RMS is computed using the bins in the currently
  defined range (see <a href="./TAxis.html">TAxis</a>::<a href="./TAxis.html#TAxis:SetRange" title="void TAxis::SetRange(Int_t first=0,Int_t last=0)">SetRange</a>). By default the range includes
  all bins from 1 to nbins included, excluding underflows and overflows.
  To force the underflows and overflows in the computation, one must
  call the static function <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:StatOverflows" title="void TH1::StatOverflows(Bool_t flag=kTRUE)">StatOverflows</a>(<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) before filling
  the histogram.
  Value returned is standard deviation of sample standard deviation.
  Note that it is an approximated value which is valid only in the case that the
  original data distribution is Normal. The correct one would require
  the 4-th momentum value, which cannot be accurately estimated from an histogram since
  the x-information for all entries is not kept.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetSkewness" href="src/TH1.cxx.html#ZCrv7">GetSkewness</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> axis = 1) const</span><br />
<div class="funccomm"><pre>For axis = 1, 2 or 3 returns skewness of the histogram along x, y or z axis.
For axis = 11, 12 or 13 returns the approximate standard error of skewness
of the histogram along x, y or z axis
Note, that since third and fourth moment are not calculated
at the fill time, skewness and its standard error are computed bin by bin
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetKurtosis" href="src/TH1.cxx.html#j4iW.">GetKurtosis</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> axis = 1) const</span><br />
<div class="funccomm"><pre>For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.
Kurtosis(gaussian(0, 1)) = 0.
For axis =11, 12 or 13 returns the approximate standard error of kurtosis
of the histogram along x, y or z axis
Note, that since third and fourth moment are not calculated
at the fill time, kurtosis and its standard error are computed bin by bin
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:GetStats" href="src/TH1.cxx.html#YA5Yw">GetStats</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a>* stats) const</span><br />
<div class="funccomm"><pre> fill the array stats from the contents of this histogram
 The array stats must be correctly dimensioned in the calling program.
 stats[0] = sumw
 stats[1] = sumw2
 stats[2] = sumwx
 stats[3] = sumwx2

 If no axis-subrange is specified (via <a href="./TAxis.html">TAxis</a>::<a href="./TAxis.html#TAxis:SetRange" title="void TAxis::SetRange(Int_t first=0,Int_t last=0)">SetRange</a>), the array stats
 is simply a copy of the statistics quantities computed at filling time.
 If a sub-range is specified, the function recomputes these quantities
 from the bin contents in the current axis range.

  Note that the mean value/RMS is computed using the bins in the currently
  defined range (see <a href="./TAxis.html">TAxis</a>::<a href="./TAxis.html#TAxis:SetRange" title="void TAxis::SetRange(Int_t first=0,Int_t last=0)">SetRange</a>). By default the range includes
  all bins from 1 to nbins included, excluding underflows and overflows.
  To force the underflows and overflows in the computation, one must
  call the static function <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:StatOverflows" title="void TH1::StatOverflows(Bool_t flag=kTRUE)">StatOverflows</a>(<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) before filling
  the histogram.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:PutStats" href="src/TH1.cxx.html#znbD8B">PutStats</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a>* stats)</span><br />
<div class="funccomm"><pre> Replace current statistics with the values in array stats
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:ResetStats" href="src/TH1.cxx.html#FedTtC">ResetStats</a>()</span><br />
<div class="funccomm"><pre> <a href="./TH1.html#TH1:Reset" title="void TH1::Reset(Option_t* option=&quot;&quot;)">Reset</a> the statistics including the number of entries
 and replace with values calculates from bin content
 The number of entries is set to the total bin content or (in case of weighted histogram)
 to number of effective entries
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetSumOfWeights" href="src/TH1.cxx.html#H1gE7C">GetSumOfWeights</a>() const</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*Return the sum of weights excluding under/overflows*-*-*-*-*

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:Integral" href="src/TH1.cxx.html#lu6fB">Integral</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) const</span><br />
<div class="funccomm"><pre>Return integral of bin contents. Only bins in the bins range are considered.
 By default the integral is computed as the sum of bin contents in the range.
 if option <span class="string">"width"</span> is specified, the integral is the sum of
 the bin contents multiplied by the bin width in x.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:Integral%1" href="src/TH1.cxx.html#CwfyX">Integral</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx1, <a href="./ListOfTypes.html#Int_t">Int_t</a> binx2, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) const</span><br />
<div class="funccomm"><pre>Return integral of bin contents in range [binx1,binx2]
 By default the integral is computed as the sum of bin contents in the range.
 if option <span class="string">"width"</span> is specified, the integral is the sum of
 the bin contents multiplied by the bin width in x.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:IntegralAndError" href="src/TH1.cxx.html#UdxrFB">IntegralAndError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx1, <a href="./ListOfTypes.html#Int_t">Int_t</a> binx2, <a href="./ListOfTypes.html#Double_t">Double_t</a>&amp; err, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) const</span><br />
<div class="funccomm"><pre>Return integral of bin contents in range [binx1,binx2] and its error
 By default the integral is computed as the sum of bin contents in the range.
 if option <span class="string">"width"</span> is specified, the integral is the sum of
 the bin contents multiplied by the bin width in x.
 the error is computed using error propagation from the bin errors assumming that
 all the bins are uncorrelated
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:DoIntegral" href="src/TH1.cxx.html#xQJNQB">DoIntegral</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> ix1, <a href="./ListOfTypes.html#Int_t">Int_t</a> ix2, <a href="./ListOfTypes.html#Int_t">Int_t</a> iy1, <a href="./ListOfTypes.html#Int_t">Int_t</a> iy2, <a href="./ListOfTypes.html#Int_t">Int_t</a> iz1, <a href="./ListOfTypes.html#Int_t">Int_t</a> iz2, <a href="./ListOfTypes.html#Double_t">Double_t</a>&amp; err, <a href="./ListOfTypes.html#Option_t">Option_t</a>* opt, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> doerr = <a href="./ListOfTypes.html#Bool_t">kFALSE</a>) const</span><br />
<div class="funccomm"><pre> internal function compute integral and optionally the error  between the limits
 specified by the bin number values working for all histograms (1D, 2D and 3D)
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:KolmogorovTest" href="src/TH1.cxx.html#CvWKzB">KolmogorovTest</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>* h2, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) const</span><br />
<div class="funccomm"><pre>  Statistical test of compatibility in shape between
  THIS histogram and h2, using Kolmogorov test.

     Default: Ignore under- and overflow bins in comparison

     option is a character string to specify options
         <span class="string">"U"</span> include Underflows in test  (also for 2-dim)
         <span class="string">"O"</span> include Overflows     (also valid for 2-dim)
         <span class="string">"N"</span> include comparison of normalizations
         <span class="string">"D"</span> Put out a line of <span class="string">"Debug"</span> printout
         <span class="string">"M"</span> Return the Maximum Kolmogorov distance instead of prob
         <span class="string">"X"</span> Run the pseudo experiments post-processor with the following procedure:
             make pseudoexperiments based on random values from the parent
             distribution and compare the KS distance of the pseudoexperiment
             to the parent distribution. Bin the KS distances in a histogram,
             and then take the integral of all the KS values above the value
             obtained from the original data to Monte Carlo distribution.
             The number of pseudo-experiments nEXPT is currently fixed at 1000.
             The function returns the integral.
             (thanks to Ben Kilminster to submit this procedure). Note that
             this option <span class="string">"X"</span> is much slower.

   The returned function value is the probability of test
       (much less than one means NOT compatible)

  Code adapted by Rene Brun from original HBOOK routine HDIFF

  NOTE1
  A good description of the Kolmogorov test can be seen at:
    http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm

  NOTE2
  see also alternative function <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Chi2Test" title="Double_t TH1::Chi2Test(const TH1* h2,Option_t* option=&quot;UU&quot;,Double_t* res=0)">Chi2Test</a>
  The Kolmogorov test is assumed to give better results than <a href="./TH1.html#TH1:Chi2Test" title="Double_t TH1::Chi2Test(const TH1* h2,Option_t* option=&quot;UU&quot;,Double_t* res=0)">Chi2Test</a>
  in case of histograms with low statistics.

  NOTE3 (Jan Conrad, Fred James)
  <span class="string">"The returned value PROB is calculated such that it will be</span>
  uniformly distributed between zero and one for compatible histograms,
  provided the data are not binned (or the number of bins is very large
  compared with the number of events). Users who have access to unbinned
  data and wish exact confidence levels should therefore not put their data
  into histograms, but should call directly <a href="./TMath.html">TMath</a>::<a href="./TMath.html#TMath:KolmogorovTest" title="Double_t TMath::KolmogorovTest(Int_t na,const Double_t* a,Int_t nb,const Double_t* b,Option_t* option)">KolmogorovTest</a>. On
  the other hand, since <a href="./TH1.html">TH1</a> is a convenient way of collecting data and
  saving space, this function has been provided. However, the values of
  PROB for binned data will be shifted slightly higher than expected,
  depending on the effects of the binning. For example, when comparing two
  uniform distributions of 500 events in 100 bins, the values of PROB,
  instead of being exactly uniformly distributed between zero and one, have
  a mean value of about 0.56. We can apply a useful
  rule: As <a href="./ListOfTypes.html#long">long</a> as the bin width is small compared with any significant
  physical effect (for example the experimental resolution) then the binning
  cannot have an important effect. Therefore, we believe that for all
  practical purposes, the probability value PROB is calculated correctly
  provided the user is aware that:
     1. The value of PROB should not be expected to have exactly the correct
  distribution for binned data.
     2. The user is responsible for seeing to it that the bin widths are
  small compared with any physical phenomena of interest.
     3. The effect of binning (if any) is always to make the value of PROB
  slightly too big. That is, setting an acceptance criterion of (PROB&gt;0.05
  will assure that at most 5% of truly compatible histograms are rejected,
  and usually somewhat less.<span class="string">"</span>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetContent" href="src/TH1.cxx.html#CEXUt">SetContent</a>(<span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* content)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*Replace bin contents by the contents of array content*-*-*-*

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:GetContour" href="src/TH1.cxx.html#o7Ry5E">GetContour</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a>* levels = 0)</span><br />
<div class="funccomm"><pre>  Return contour values into array levels if pointer levels is non zero

  The function returns the number of contour levels.
  see <a href="./TH1.html#TH1:GetContourLevel" title="Double_t TH1::GetContourLevel(Int_t level)">GetContourLevel</a> to return one contour only

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetContourLevel" href="src/TH1.cxx.html#TTiXkE">GetContourLevel</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> level) const</span><br />
<div class="funccomm"><pre> Return value of contour number level
 see <a href="./TH1.html#TH1:GetContour" title="Int_t TH1::GetContour(Double_t* levels=0)">GetContour</a> to return the array of all contour levels
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetContourLevelPad" href="src/TH1.cxx.html#r4chTD">GetContourLevelPad</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> level) const</span><br />
<div class="funccomm"><pre> Return the value of contour number <span class="string">"level"</span> in Pad coordinates ie: if the Pad
 is in log scale along Z it returns le log of the contour level value.
 see <a href="./TH1.html#TH1:GetContour" title="Int_t TH1::GetContour(Double_t* levels=0)">GetContour</a> to return the array of all contour levels
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetBuffer" href="src/TH1.cxx.html#DDPhfB">SetBuffer</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> buffersize, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre> set the maximum number of entries to be kept in the buffer
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetContour" href="src/TH1.cxx.html#XblouD">SetContour</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nlevels, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* levels = 0)</span><br />
<div class="funccomm"><pre>  Set the number and values of contour levels.

  By default the number of contour levels is set to 20. The contours values
  in the array <span class="string">"levels"</span> should be specified in increasing order.

  if argument levels = 0 or missing, equidistant contours are computed
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetContourLevel" href="src/TH1.cxx.html#M28sq">SetContourLevel</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> level, <a href="./ListOfTypes.html#Double_t">Double_t</a> value)</span><br />
<div class="funccomm"><pre> Set value for one contour level.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetMaximum" href="src/TH1.cxx.html#RnlOaC">GetMaximum</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> maxval = FLT_MAX) const</span><br />
<div class="funccomm"><pre>  Return maximum value smaller than maxval of bins in the range,
  unless the value has been overridden by <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:SetMaximum" title="void TH1::SetMaximum(Double_t maximum=-1111)">SetMaximum</a>,
  in which case it returns that value. (This happens, for example,
  when the histogram is drawn and the y or z axis limits are changed

  To get the maximum value of bins in the histogram regardless of
  whether the value has been overridden, use
      h-&gt;<a href="./TH1.html#TH1:GetBinContent" title="Double_t TH1::GetBinContent(Int_t bin) or overloads">GetBinContent</a>(h-&gt;<a href="./TH1.html#TH1:GetMaximumBin" title="Int_t TH1::GetMaximumBin() or overloads">GetMaximumBin</a>())
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:GetMaximumBin" href="src/TH1.cxx.html#cbd67D">GetMaximumBin</a>() const</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*Return location of bin with maximum value in the range*-*

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:GetMaximumBin%1" href="src/TH1.cxx.html#ZytCZE">GetMaximumBin</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; locmax, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; locmay, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; locmaz) const</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*Return location of bin with maximum value in the range*-*

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetMinimum" href="src/TH1.cxx.html#JxXY8D">GetMinimum</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> minval = -FLT_MAX) const</span><br />
<div class="funccomm"><pre>  Return minimum value smaller than maxval of bins in the range,
  unless the value has been overridden by <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:SetMinimum" title="void TH1::SetMinimum(Double_t minimum=-1111)">SetMinimum</a>,
  in which case it returns that value. (This happens, for example,
  when the histogram is drawn and the y or z axis limits are changed

  To get the minimum value of bins in the histogram regardless of
  whether the value has been overridden, use
     h-&gt;<a href="./TH1.html#TH1:GetBinContent" title="Double_t TH1::GetBinContent(Int_t bin) or overloads">GetBinContent</a>(h-&gt;<a href="./TH1.html#TH1:GetMinimumBin" title="Int_t TH1::GetMinimumBin() or overloads">GetMinimumBin</a>())
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:GetMinimumBin" href="src/TH1.cxx.html#MvJ47D">GetMinimumBin</a>() const</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*Return location of bin with minimum value in the range*-*

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:GetMinimumBin%1" href="src/TH1.cxx.html#lz8H0D">GetMinimumBin</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; locmix, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; locmiy, <a href="./ListOfTypes.html#Int_t">Int_t</a>&amp; locmiz) const</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*Return location of bin with minimum value in the range*-*

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetBins" href="src/TH1.cxx.html#lSMTuC">SetBins</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nx, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmin, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmax)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*Redefine  x axis parameters*-*-*-*-*-*-*-*-*-*-*-*

 The X axis parameters are modified.
 The bins content array is resized
 if errors (<a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>) the errors array is resized
 The previous bin contents are lost
 To change only the axis limits, see <a href="./TAxis.html">TAxis</a>::<a href="./TAxis.html#TAxis:SetRange" title="void TAxis::SetRange(Int_t first=0,Int_t last=0)">SetRange</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetBins%1" href="src/TH1.cxx.html#mtRS2D">SetBins</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nx, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* xBins)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*Redefine  x axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*-*

 The X axis parameters are modified.
 The bins content array is resized
 if errors (<a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>) the errors array is resized
 The previous bin contents are lost
 To change only the axis limits, see <a href="./TAxis.html">TAxis</a>::<a href="./TAxis.html#TAxis:SetRange" title="void TAxis::SetRange(Int_t first=0,Int_t last=0)">SetRange</a>
 xBins is supposed to be of length nx+1
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetBins%2" href="src/TH1.cxx.html#KLVvEB">SetBins</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nx, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmin, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmax, <a href="./ListOfTypes.html#Int_t">Int_t</a> ny, <a href="./ListOfTypes.html#Double_t">Double_t</a> ymin, <a href="./ListOfTypes.html#Double_t">Double_t</a> ymax)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*Redefine  x and y axis parameters*-*-*-*-*-*-*-*-*-*-*-*

 The X and Y axis parameters are modified.
 The bins content array is resized
 if errors (<a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>) the errors array is resized
 The previous bin contents are lost
 To change only the axis limits, see <a href="./TAxis.html">TAxis</a>::<a href="./TAxis.html#TAxis:SetRange" title="void TAxis::SetRange(Int_t first=0,Int_t last=0)">SetRange</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetBins%3" href="src/TH1.cxx.html#zLA7qB">SetBins</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nx, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* xBins, <a href="./ListOfTypes.html#Int_t">Int_t</a> ny, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* yBins)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*Redefine  x and y axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*

 The X and Y axis parameters are modified.
 The bins content array is resized
 if errors (<a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>) the errors array is resized
 The previous bin contents are lost
 To change only the axis limits, see <a href="./TAxis.html">TAxis</a>::<a href="./TAxis.html#TAxis:SetRange" title="void TAxis::SetRange(Int_t first=0,Int_t last=0)">SetRange</a>
 xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetBins%4" href="src/TH1.cxx.html#pPTxG">SetBins</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nx, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmin, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmax, <a href="./ListOfTypes.html#Int_t">Int_t</a> ny, <a href="./ListOfTypes.html#Double_t">Double_t</a> ymin, <a href="./ListOfTypes.html#Double_t">Double_t</a> ymax, <a href="./ListOfTypes.html#Int_t">Int_t</a> nz, <a href="./ListOfTypes.html#Double_t">Double_t</a> zmin, <a href="./ListOfTypes.html#Double_t">Double_t</a> zmax)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*Redefine  x, y and z axis parameters*-*-*-*-*-*-*-*-*-*-*-*

 The X, Y and Z axis parameters are modified.
 The bins content array is resized
 if errors (<a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>) the errors array is resized
 The previous bin contents are lost
 To change only the axis limits, see <a href="./TAxis.html">TAxis</a>::<a href="./TAxis.html#TAxis:SetRange" title="void TAxis::SetRange(Int_t first=0,Int_t last=0)">SetRange</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetBins%5" href="src/TH1.cxx.html#QDdllD">SetBins</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nx, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* xBins, <a href="./ListOfTypes.html#Int_t">Int_t</a> ny, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* yBins, <a href="./ListOfTypes.html#Int_t">Int_t</a> nz, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* zBins)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*Redefine  x, y and z axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*

 The X, Y and Z axis parameters are modified.
 The bins content array is resized
 if errors (<a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>) the errors array is resized
 The previous bin contents are lost
 To change only the axis limits, see <a href="./TAxis.html">TAxis</a>::<a href="./TAxis.html#TAxis:SetRange" title="void TAxis::SetRange(Int_t first=0,Int_t last=0)">SetRange</a>
 xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1,
 zBins is supposed to be of length nz+1
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetMaximum" href="src/TH1.cxx.html#MAmeIC">SetMaximum</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> maximum = -1111)</span><br />
<div class="funccomm"><pre> Set the maximum value for the Y axis, in case of 1-D histograms,
 or the Z axis in case of 2-D histograms

 By default the maximum value used in drawing is the maximum value of the histogram plus
 a margin of 10 per cent. If this function has been called, the value of 'maximum' is
 used, with no extra margin.

 <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:GetMaximum" title="Double_t TH1::GetMaximum(Double_t maxval=FLT_MAX)">GetMaximum</a> returns the maximum value of the bins in the histogram, unless the
 maximum has been set manually by this function or by altering the y/z axis limits.
 Use <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:GetMaximumBin" title="Int_t TH1::GetMaximumBin() or overloads">GetMaximumBin</a> to find the bin with the maximum value of an histogram

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetMinimum" href="src/TH1.cxx.html#UOSKEC">SetMinimum</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> minimum = -1111)</span><br />
<div class="funccomm"><pre> Set the minimum value for the Y axis, in case of 1-D histograms,
 or the Z axis in case of 2-D histograms

 By default the minimum value used in drawing is the minimum value of the histogram plus
 a margin of 10 per cent. If this function has been called, the value of 'minimum' is
 used, with no extra margin.

 <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:GetMinimum" title="Double_t TH1::GetMinimum(Double_t minval=-FLT_MAX)">GetMinimum</a> returns the minimum value of the bins in the histogram, unless the
 minimum has been set manually by this function or by altering the y/z axis limits.
 Use <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:GetMinimumBin" title="Int_t TH1::GetMinimumBin() or overloads">GetMinimumBin</a> to find the bin with the minimum value of an histogram

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetDirectory" href="src/TH1.cxx.html#yZ7ED">SetDirectory</a>(<a href="./TDirectory.html">TDirectory</a>* dir)</span><br />
<div class="funccomm"><pre> By default when an histogram is created, it is added to the list
 of histogram objects in the current directory in memory.
 Remove reference to this histogram from current directory and add
 reference to new directory dir. dir can be 0 in which case the
 histogram does not belong to any directory.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetError" href="src/TH1.cxx.html#MXu1OC">SetError</a>(<span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* error)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*Replace bin errors by values in array error*-*-*-*-*-*-*-*-*

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetName" href="src/TH1.cxx.html#v95EkC">SetName</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span><br />
<div class="funccomm"><pre> Change the name of this histogram

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetNameTitle" href="src/TH1.cxx.html#w7UpFE">SetNameTitle</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* title)</span><br />
<div class="funccomm"><pre> Change the name and title of this histogram

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetStats" href="src/TH1.cxx.html#odfGTB">SetStats</a>(<a href="./ListOfTypes.html#Bool_t">Bool_t</a> stats = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*-*-*Set statistics option on/off

  By default, the statistics box is drawn.
  The paint options can be selected via <a href="./TStyle.html">gStyle</a>->SetOptStats.
  This function sets/resets the <a href="./TH1.html#TH1:kNoStats" title="const enum TH1:: TH1::kNoStats">kNoStats</a> bin in the histogram object.
  It has priority over the Style option.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:Sumw2" href="src/TH1.cxx.html#TuVxfD">Sumw2</a>()</span><br />
<div class="funccomm"><pre> Create structure to store sum of squares of weights*-*-*-*-*-*-*-*

     if histogram is already filled, the sum of squares of weights
     is filled with the existing bin contents

     The error per bin will be computed as sqrt(sum of squares of weight)
     for each bin.

  This function is automatically called when the histogram is created
  if the static function <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:SetDefaultSumw2" title="void TH1::SetDefaultSumw2(Bool_t sumw2=kTRUE)">SetDefaultSumw2</a> has been called before.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TF1.html">TF1</a> * <a class="funcname" name="TH1:GetFunction" href="src/TH1.cxx.html#PvlB1B">GetFunction</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name) const</span><br />
<div class="funccomm"><pre>   -*-*-*Return pointer to function with name*-*-*-*-*-*-*-*-*-*-*-*-*


 Functions such as <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Fit" title="TFitResultPtr TH1::Fit(const char* formula,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Double_t xmin=0,Double_t xmax=0) or overloads">Fit</a> store the fitted function in the list of
 functions of this histogram.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetBinError" href="src/TH1.cxx.html#NNDAEC">GetBinError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin) const</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*Return value of error associated to bin number bin*-*-*-*-*


    if the sum of squares of weights has been defined (via <a href="./TH1.html#TH1:Sumw2" title="void TH1::Sumw2()">Sumw2</a>),
    this function returns the sqrt(sum of w2).
    otherwise it returns the sqrt(contents) for this bin.

   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetBinError%1" href="src/TH1.cxx.html#Wnz3_B">GetBinError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny) const</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*Return error of bin number binx, biny

 NB: Function to be called for 2-D histograms only
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetBinError%2" href="src/TH1.cxx.html#D5PYXE">GetBinError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny, <a href="./ListOfTypes.html#Int_t">Int_t</a> binz) const</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*Return error of bin number binx,biny,binz

 NB: Function to be called for 3-D histograms only
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetCellContent" href="src/TH1.cxx.html#XbAV4D">GetCellContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny) const</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*Return content of bin number binx, biny

 NB: Function to be called for 2-D histograms only
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetCellError" href="src/TH1.cxx.html#E4TsaC">GetCellError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny) const</span><br />
<div class="funccomm"><pre>   -*-*-*-*-*Return error of bin number binx, biny

 NB: Function to be called for 2-D histograms only
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetBinError" href="src/TH1.cxx.html#gi_Pz">SetBinError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin, <a href="./ListOfTypes.html#Double_t">Double_t</a> error)</span><br />
<div class="funccomm"><pre> see convention for numbering bins in <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:GetBin" title="Int_t TH1::GetBin(Int_t binx,Int_t biny=0,Int_t binz=0)">GetBin</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetBinContent%1" href="src/TH1.cxx.html#OQiA_">SetBinContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny, <a href="./ListOfTypes.html#Double_t">Double_t</a> content)</span><br />
<div class="funccomm"><pre> see convention for numbering bins in <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:GetBin" title="Int_t TH1::GetBin(Int_t binx,Int_t biny=0,Int_t binz=0)">GetBin</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetBinContent%2" href="src/TH1.cxx.html#sQrEtC">SetBinContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny, <a href="./ListOfTypes.html#Int_t">Int_t</a> binz, <a href="./ListOfTypes.html#Double_t">Double_t</a> content)</span><br />
<div class="funccomm"><pre> see convention for numbering bins in <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:GetBin" title="Int_t TH1::GetBin(Int_t binx,Int_t biny=0,Int_t binz=0)">GetBin</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetCellContent" href="src/TH1.cxx.html#UboY_C">SetCellContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny, <a href="./ListOfTypes.html#Double_t">Double_t</a> content)</span><br />
<div class="funccomm"><pre> Set cell content.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetBinError%1" href="src/TH1.cxx.html#IR7wbD">SetBinError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny, <a href="./ListOfTypes.html#Double_t">Double_t</a> error)</span><br />
<div class="funccomm"><pre> see convention for numbering bins in <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:GetBin" title="Int_t TH1::GetBin(Int_t binx,Int_t biny=0,Int_t binz=0)">GetBin</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetBinError%2" href="src/TH1.cxx.html#z1LOXC">SetBinError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny, <a href="./ListOfTypes.html#Int_t">Int_t</a> binz, <a href="./ListOfTypes.html#Double_t">Double_t</a> error)</span><br />
<div class="funccomm"><pre> see convention for numbering bins in <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:GetBin" title="Int_t TH1::GetBin(Int_t binx,Int_t biny=0,Int_t binz=0)">GetBin</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetCellError" href="src/TH1.cxx.html#p2LPJB">SetCellError</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> binx, <a href="./ListOfTypes.html#Int_t">Int_t</a> biny, <a href="./ListOfTypes.html#Double_t">Double_t</a> content)</span><br />
<div class="funccomm"><pre> see convention for numbering bins in <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:GetBin" title="Int_t TH1::GetBin(Int_t binx,Int_t biny=0,Int_t binz=0)">GetBin</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetBinContent" href="src/TH1.cxx.html#AaJ1u">SetBinContent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin, <a href="./ListOfTypes.html#Double_t">Double_t</a> content)</span><br />
<div class="funccomm"><pre> see convention for numbering bins in <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:GetBin" title="Int_t TH1::GetBin(Int_t binx,Int_t biny=0,Int_t binz=0)">GetBin</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TH1.html">TH1</a> * <a class="funcname" name="TH1:ShowBackground" href="src/TH1.cxx.html#PRUQY">ShowBackground</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> niter = 20, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">"same"</span>)</span><br />
<div class="funccomm"><pre>   This function calculates the background spectrum in this histogram.
   The background is returned as a histogram.

   Function parameters:
   -niter, number of iterations (default value = 2)
      Increasing niter make the result smoother and lower.
   -option: may contain one of the following options
      - to set the direction parameter
        <span class="string">"BackDecreasingWindow"</span>. By default the direction is BackIncreasingWindow
      - filterOrder-order of clipping filter,  (default <span class="string">"BackOrder2"</span>
                  -possible values= <span class="string">"BackOrder4"</span>
                                    <span class="string">"BackOrder6"</span>
                                    <span class="string">"BackOrder8"</span>
      - <span class="string">"nosmoothing"</span>- if selected, the background is not smoothed
           By default the background is smoothed.
      - smoothWindow-width of smoothing window, (default is <span class="string">"BackSmoothing3"</span>)
                  -possible values= <span class="string">"BackSmoothing5"</span>
                                    <span class="string">"BackSmoothing7"</span>
                                    <span class="string">"BackSmoothing9"</span>
                                    <span class="string">"BackSmoothing11"</span>
                                    <span class="string">"BackSmoothing13"</span>
                                    <span class="string">"BackSmoothing15"</span>
      - <span class="string">"nocompton"</span>- if selected the estimation of Compton edge
                  will be not be included   (by default the compton estimation is set)
      - <span class="string">"same"</span> : if this option is specified, the resulting background
                 histogram is superimposed on the picture in the current pad.
                 This option is given by default.

  NOTE that the background is only evaluated in the current range of this histogram.
  i.e., if this has a bin range (set via h-&gt;<a href="./TH1.html#TH1:GetXaxis" title="TAxis* TH1::GetXaxis()">GetXaxis</a>()-><a href="./TAxis.html#TAxis:SetRange" title="void TAxis::SetRange(Int_t first=0,Int_t last=0)">SetRange</a>(binmin, binmax),
  the returned histogram will be created with the same number of bins
  as this input histogram, but only bins from binmin to binmax will be filled
  with the estimated background.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:ShowPeaks" href="src/TH1.cxx.html#wptaFE">ShowPeaks</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> sigma = 2, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Double_t">Double_t</a> threshold = 0.05)</span><br />
<div class="funccomm"><pre>Interface to <a href="./TSpectrum.html">TSpectrum</a>::<a href="./TSpectrum.html#TSpectrum:Search" title="Int_t TSpectrum::Search(const TH1* hist,Double_t sigma=2,Option_t* option=&quot;&quot;,Double_t threshold=0.05)">Search</a>.
The function finds peaks in this histogram where the width is &gt; sigma
and the peak maximum greater than threshold*maximum bin content of this.
For more details see <a href="./TSpectrum.html">TSpectrum</a>::<a href="./TSpectrum.html#TSpectrum:Search" title="Int_t TSpectrum::Search(const TH1* hist,Double_t sigma=2,Option_t* option=&quot;&quot;,Double_t threshold=0.05)">Search</a>.
Note the difference in the default value for option compared to <a href="./TSpectrum.html">TSpectrum</a>::<a href="./TSpectrum.html#TSpectrum:Search" title="Int_t TSpectrum::Search(const TH1* hist,Double_t sigma=2,Option_t* option=&quot;&quot;,Double_t threshold=0.05)">Search</a>
option=<span class="string">""</span> by default (instead of <span class="string">"goff"</span>).
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TH1.html">TH1</a>* <a class="funcname" name="TH1:TransformHisto" href="src/TH1.cxx.html#IMMn3D">TransformHisto</a>(<a href="./TVirtualFFT.html">TVirtualFFT</a>* fft, <a href="./TH1.html">TH1</a>* h_output, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option)</span><br />
<div class="funccomm"><pre>For a given transform (first parameter), fills the histogram (second parameter)
with the transform output data, specified in the third parameter
If the 2nd parameter h_output is empty, a new histogram (<a href="./TH1D.html">TH1D</a> or <a href="./TH2D.html">TH2D</a>) is created
and the user is responsible for deleting it.
 Available options:
   <span class="string">"RE"</span> - real part of the output
   <span class="string">"IM"</span> - imaginary part of the output
   <span class="string">"MAG"</span> - magnitude of the output
   <span class="string">"PH"</span>  - phase of the output
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:AxisChoice" href="src/TH1.h.html#NIF3JC">AxisChoice</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis) const</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./TH1.html">TH1</a>&amp; <a class="funcname" name="TH1:operator_" href="src/TH1.h.html#CFoazD">operator=</a>(<span class="keyword">const</span> <a href="./TH1.html">TH1</a>&amp; )</span><br />
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:FillN" href="src/TH1.h.html#wInz.D">FillN</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> ntimes, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* x, <span class="keyword">const</span> <a href="./ListOfTypes.html#Double_t">Double_t</a>* w, <a href="./ListOfTypes.html#Int_t">Int_t</a> stride = 1)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:GetBufferLength" href="src/TH1.h.html#GkyeYD">GetBufferLength</a>() const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./TH1.html#TH1:fBuffer" title="Double_t* TH1::fBuffer">fBuffer</a> ? (<a href="./ListOfTypes.html#Int_t">Int_t</a>)<a href="./TH1.html#TH1:fBuffer" title="Double_t* TH1::fBuffer">fBuffer</a>[0] : 0;}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:GetBufferSize" href="src/TH1.h.html#ZOoRFB">GetBufferSize</a>() const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./TH1.html#TH1:fBufferSize" title="Int_t TH1::fBufferSize">fBufferSize</a>;}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">const</span>   <a href="./ListOfTypes.html#Double_t">Double_t</a> * <a class="funcname" name="TH1:GetBuffer" href="src/TH1.h.html#bASX5B">GetBuffer</a>() const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./TH1.html#TH1:fBuffer" title="Double_t* TH1::fBuffer">fBuffer</a>;}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TList.html">TList</a>           * <a class="funcname" name="TH1:GetListOfFunctions" href="src/TH1.h.html#u90BeD">GetListOfFunctions</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TH1.html#TH1:fFunctions" title="TList* TH1::fFunctions">fFunctions</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:GetNdivisions" href="src/TH1.h.html#OD_Ec">GetNdivisions</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) const</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Color_t">Color_t</a> <a class="funcname" name="TH1:GetAxisColor" href="src/TH1.h.html#yjGRcE">GetAxisColor</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) const</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Color_t">Color_t</a> <a class="funcname" name="TH1:GetLabelColor" href="src/TH1.h.html#HixxiB">GetLabelColor</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) const</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Style_t">Style_t</a> <a class="funcname" name="TH1:GetLabelFont" href="src/TH1.h.html#wbugkE">GetLabelFont</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) const</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Float_t">Float_t</a> <a class="funcname" name="TH1:GetLabelOffset" href="src/TH1.h.html#kyyZr">GetLabelOffset</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) const</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Float_t">Float_t</a> <a class="funcname" name="TH1:GetLabelSize" href="src/TH1.h.html#U0mCJ">GetLabelSize</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) const</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Style_t">Style_t</a> <a class="funcname" name="TH1:GetTitleFont" href="src/TH1.h.html#RTAt1E">GetTitleFont</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) const</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Float_t">Float_t</a> <a class="funcname" name="TH1:GetTitleOffset" href="src/TH1.h.html#mazdWE">GetTitleOffset</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) const</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Float_t">Float_t</a> <a class="funcname" name="TH1:GetTitleSize" href="src/TH1.h.html#lwzTV">GetTitleSize</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) const</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Float_t">Float_t</a> <a class="funcname" name="TH1:GetTickLength" href="src/TH1.h.html#Qritr">GetTickLength</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>) const</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Float_t">Float_t</a> <a class="funcname" name="TH1:GetBarOffset" href="src/TH1.h.html#FxFs8C">GetBarOffset</a>() const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./ListOfTypes.html#Float_t">Float_t</a>(0.001*<a href="./ListOfTypes.html#Float_t">Float_t</a>(<a href="./TH1.html#TH1:fBarOffset" title="Short_t TH1::fBarOffset">fBarOffset</a>));}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Float_t">Float_t</a> <a class="funcname" name="TH1:GetBarWidth" href="src/TH1.h.html#AngN3E">GetBarWidth</a>() const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./ListOfTypes.html#Float_t">Float_t</a>(0.001*<a href="./ListOfTypes.html#Float_t">Float_t</a>(<a href="./TH1.html#TH1:fBarWidth" title="Short_t TH1::fBarWidth">fBarWidth</a>));}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetBinCenter" href="src/TH1.h.html#Yc2C1D">GetBinCenter</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin) const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./TH1.html#TH1:fXaxis" title="TAxis TH1::fXaxis">fXaxis</a>.<a href="./TAxis.html#TAxis:GetBinCenter" title="Double_t TAxis::GetBinCenter(Int_t bin)">GetBinCenter</a>(bin);}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetBinLowEdge" href="src/TH1.h.html#XS14rD">GetBinLowEdge</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin) const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./TH1.html#TH1:fXaxis" title="TAxis TH1::fXaxis">fXaxis</a>.<a href="./TAxis.html#TAxis:GetBinLowEdge" title="Double_t TAxis::GetBinLowEdge(Int_t bin)">GetBinLowEdge</a>(bin);}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetBinWidth" href="src/TH1.h.html#UtYvTC">GetBinWidth</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> bin) const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./TH1.html#TH1:fXaxis" title="TAxis TH1::fXaxis">fXaxis</a>.<a href="./TAxis.html#TAxis:GetBinWidth" title="Double_t TAxis::GetBinWidth(Int_t bin)">GetBinWidth</a>(bin);}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:GetCenter" href="src/TH1.h.html#PTDtFD">GetCenter</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a>* center) const</span><br />

<div class="code"><code class="inlinecode">{<a href="./TH1.html#TH1:fXaxis" title="TAxis TH1::fXaxis">fXaxis</a>.<a href="./TAxis.html#TAxis:GetCenter" title="void TAxis::GetCenter(Double_t* center)">GetCenter</a>(center);}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TDirectory.html">TDirectory</a>      * <a class="funcname" name="TH1:GetDirectory" href="src/TH1.h.html#m3_NyC">GetDirectory</a>() const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./TH1.html#TH1:fDirectory" title="TDirectory* TH1::fDirectory">fDirectory</a>;}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:GetDimension" href="src/TH1.h.html#lGuHwB">GetDimension</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TH1.html#TH1:fDimension" title="Int_t TH1::fDimension">fDimension</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:GetLowEdge" href="src/TH1.h.html#jn8.sC">GetLowEdge</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a>* edge) const</span><br />

<div class="code"><code class="inlinecode">{<a href="./TH1.html#TH1:fXaxis" title="TAxis TH1::fXaxis">fXaxis</a>.<a href="./TAxis.html#TAxis:GetLowEdge" title="void TAxis::GetLowEdge(Double_t* edge)">GetLowEdge</a>(edge);}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetMaximumStored" href="src/TH1.h.html#RaTrtD">GetMaximumStored</a>() const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./TH1.html#TH1:fMaximum" title="Double_t TH1::fMaximum">fMaximum</a>;}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetMinimumStored" href="src/TH1.h.html#TaYJ">GetMinimumStored</a>() const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./TH1.html#TH1:fMinimum" title="Double_t TH1::fMinimum">fMinimum</a>;}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:GetNbinsX" href="src/TH1.h.html#IK0UnC">GetNbinsX</a>() const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./TH1.html#TH1:fXaxis" title="TAxis TH1::fXaxis">fXaxis</a>.<a href="./TAxis.html#TAxis:GetNbins" title="Int_t TAxis::GetNbins()">GetNbins</a>();}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:GetNbinsY" href="src/TH1.h.html#U7CGnC">GetNbinsY</a>() const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./TH1.html#TH1:fYaxis" title="TAxis TH1::fYaxis">fYaxis</a>.<a href="./TAxis.html#TAxis:GetNbins" title="Int_t TAxis::GetNbins()">GetNbins</a>();}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:GetNbinsZ" href="src/TH1.h.html#gsR3mC">GetNbinsZ</a>() const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./TH1.html#TH1:fZaxis" title="TAxis TH1::fZaxis">fZaxis</a>.<a href="./TAxis.html#TAxis:GetNbins" title="Int_t TAxis::GetNbins()">GetNbins</a>();}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TH1:GetNormFactor" href="src/TH1.h.html#tGL.MC">GetNormFactor</a>() const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./TH1.html#TH1:fNormFactor" title="Double_t TH1::fNormFactor">fNormFactor</a>;}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Option_t">Option_t</a>        * <a class="funcname" name="TH1:GetOption" href="src/TH1.h.html#FI5CNB">GetOption</a>() const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./TH1.html#TH1:fOption" title="TString TH1::fOption">fOption</a>.<a href="./TString.html#TString:Data" title="const char* TString::Data()">Data</a>();}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TArrayD.html">TArrayD</a> * <a class="funcname" name="TH1:GetSumw2" href="src/TH1.h.html#Zmsu8D">GetSumw2</a>()</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> &amp;<a href="./TH1.html#TH1:fSumw2" title="TArrayD TH1::fSumw2">fSumw2</a>;}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">const</span> <a href="./TArrayD.html">TArrayD</a> * <a class="funcname" name="TH1:GetSumw2%1" href="src/TH1.h.html#WuldZC">GetSumw2</a>() const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> &amp;<a href="./TH1.html#TH1:fSumw2" title="TArrayD TH1::fSumw2">fSumw2</a>;}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TH1:GetSumw2N" href="src/TH1.h.html#RydrSC">GetSumw2N</a>() const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./TH1.html#TH1:fSumw2" title="TArrayD TH1::fSumw2">fSumw2</a>.fN;}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetAxisColor" href="src/TH1.h.html#YQSJgB">SetAxisColor</a>(<a href="./ListOfTypes.html#Color_t">Color_t</a> color = 1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetAxisRange" href="src/TH1.h.html#kqJ9AC">SetAxisRange</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> xmin, <a href="./ListOfTypes.html#Double_t">Double_t</a> xmax, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetBarOffset" href="src/TH1.h.html#avBT6D">SetBarOffset</a>(<a href="./ListOfTypes.html#Float_t">Float_t</a> offset = 0.25)</span><br />

<div class="code"><code class="inlinecode">{<a href="./TH1.html#TH1:fBarOffset" title="Short_t TH1::fBarOffset">fBarOffset</a> = <a href="./ListOfTypes.html#Short_t">Short_t</a>(1000*offset);}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetBarWidth" href="src/TH1.h.html#uemjpC">SetBarWidth</a>(<a href="./ListOfTypes.html#Float_t">Float_t</a> width = 0.5)</span><br />

<div class="code"><code class="inlinecode">{<a href="./TH1.html#TH1:fBarWidth" title="Short_t TH1::fBarWidth">fBarWidth</a> = <a href="./ListOfTypes.html#Short_t">Short_t</a>(1000*width);}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetBinsLength" href="src/TH1.h.html#r9SXm">SetBinsLength</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a>  = -1)</span><br />

<div class="code"><code class="inlinecode">{ }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetEntries" href="src/TH1.h.html#HVOXZ">SetEntries</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> n)</span><br />

<div class="code"><code class="inlinecode">{<a href="./TH1.html#TH1:fEntries" title="Double_t TH1::fEntries">fEntries</a> = n;}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetLabelColor" href="src/TH1.h.html#nkto3B">SetLabelColor</a>(<a href="./ListOfTypes.html#Color_t">Color_t</a> color = 1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetLabelFont" href="src/TH1.h.html#KMi26E">SetLabelFont</a>(<a href="./ListOfTypes.html#Style_t">Style_t</a> font = 62, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetLabelOffset" href="src/TH1.h.html#vF1WbC">SetLabelOffset</a>(<a href="./ListOfTypes.html#Float_t">Float_t</a> offset = 0.005, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetLabelSize" href="src/TH1.h.html#FESs.C">SetLabelSize</a>(<a href="./ListOfTypes.html#Float_t">Float_t</a> size = 0.02, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetNdivisions" href="src/TH1.h.html#Tck8wD">SetNdivisions</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> n = 510, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetNormFactor" href="src/TH1.h.html#SBmcLB">SetNormFactor</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> factor = 1)</span><br />

<div class="code"><code class="inlinecode">{<a href="./TH1.html#TH1:fNormFactor" title="Double_t TH1::fNormFactor">fNormFactor</a> = factor;}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetOption" href="src/TH1.h.html#K.ANBD">SetOption</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">" "</span>)</span><br />

<div class="code"><code class="inlinecode">{<a href="./TH1.html#TH1:fOption" title="TString TH1::fOption">fOption</a> = option;}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetTickLength" href="src/TH1.h.html#JVYkO">SetTickLength</a>(<a href="./ListOfTypes.html#Float_t">Float_t</a> length = 0.02, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetTitleFont" href="src/TH1.h.html#WCTPsE">SetTitleFont</a>(<a href="./ListOfTypes.html#Style_t">Style_t</a> font = 62, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetTitleOffset" href="src/TH1.h.html#j0hw2D">SetTitleOffset</a>(<a href="./ListOfTypes.html#Float_t">Float_t</a> offset = 1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetTitleSize" href="src/TH1.h.html#UQj.m">SetTitleSize</a>(<a href="./ListOfTypes.html#Float_t">Float_t</a> size = 0.02, <a href="./ListOfTypes.html#Option_t">Option_t</a>* axis = <span class="string">"X"</span>)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetXTitle" href="src/TH1.h.html#INc6GE">SetXTitle</a>(<span class="keyword">const</span> <span class="keyword">char</span>* title)</span><br />

<div class="code"><code class="inlinecode">{<a href="./TH1.html#TH1:fXaxis" title="TAxis TH1::fXaxis">fXaxis</a>.<a href="./TNamed.html#TNamed:SetTitle" title="void TNamed::SetTitle(const char* title=&quot;&quot;)">SetTitle</a>(title);}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetYTitle" href="src/TH1.h.html#U_qr1D">SetYTitle</a>(<span class="keyword">const</span> <span class="keyword">char</span>* title)</span><br />

<div class="code"><code class="inlinecode">{<a href="./TH1.html#TH1:fYaxis" title="TAxis TH1::fYaxis">fYaxis</a>.<a href="./TNamed.html#TNamed:SetTitle" title="void TNamed::SetTitle(const char* title=&quot;&quot;)">SetTitle</a>(title);}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TH1:SetZTitle" href="src/TH1.h.html#kq_XpE">SetZTitle</a>(<span class="keyword">const</span> <span class="keyword">char</span>* title)</span><br />

<div class="code"><code class="inlinecode">{<a href="./TH1.html#TH1:fZaxis" title="TAxis TH1::fZaxis">fZaxis</a>.<a href="./TNamed.html#TNamed:SetTitle" title="void TNamed::SetTitle(const char* title=&quot;&quot;)">SetTitle</a>(title);}</code></div>
<div style="clear:both;"></div>
</div>

<br />
<!--SIGNATURE-->
<div id="footer">
<em>&raquo; Author: <a href="http://consult.cern.ch/xwho/people?Rene+Brun"> Rene Brun   26/12/94</a> </em><em>&raquo; Copyright   (C) 1995-2000, Rene Brun and Fons Rademakers.               *</em><br />
<em>&raquo; Last changed: root/hist:$Id: TH1.h 40378 2011-07-27 20:45:07Z pcanal $ </em><em>&raquo; Last generated: 2011-12-02 14:27</em><br />
<em>This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>.</em>
</div>
</div>
</body>
</html>
