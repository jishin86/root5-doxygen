<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!--                                             -->
<!-- Author: ROOT team (rootdev@pcroot.cern.ch)  -->
<!--                                             -->
<!--   Date: Thu Nov  3 20:04:45 2011            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<title>ROOT::Math::GSLMultiRootFinder</title>
<meta name="rating" content="General" />
<meta name="objecttype" content="Manual" />
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers, cern" />
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis." />
<link rel="stylesheet" type="text/css" href="ROOT.css" id="ROOTstyle" />
<script type="text/javascript" src="ROOT.js"></script>
</head>
<body  onload="javascript:SetValuesFromCookie();"><div id="body_content">
<div id="root_header"><img src="http://root.cern.ch/drupal/sites/default/files/rootdrawing-logo.png" alt="ROOT logo"/></div>
<a name="TopOfPage"></a>
<script type="text/javascript">WriteFollowPageBox('class ROOT::Math::GSLMultiRootFinder','libMathMore','Math/GSLMultiRootFinder.h');</script>
<div id="toplinks">
<div class="descrhead"><div class="descrheadcontent">
<span class="descrtitle">Quick Links:</span>
<a class="descrheadentry" href="http://root.cern.ch">ROOT Homepage</a>
<a class="descrheadentry" href="./ClassIndex.html">Class Index</a>
<a class="descrheadentry" href="./ClassHierarchy.html">Class Hierarchy</a></div>
<script type="text/javascript">
function onSearch() {
var s='http://www.google.com/search?q=%s+site%3A%u+-site%3A%u%2Fsrc%2F+-site%3A%u%2Fexamples%2F';
var ref=String(document.location.href).replace(/https?:\/\//,'').replace(/\/[^\/]*$/,'').replace(/\//g,'%2F');
window.location.href=s.replace(/%u/ig,ref).replace(/%s/ig,escape(document.searchform.t.value));
return false;}
</script>
<form id="searchform" name="searchform" onsubmit="return onSearch()" action="javascript:onSearch();" method="post">
<input name="t" size="30" value="Search documentation..." onfocus="if (document.searchform.t.value=='Search documentation...') document.searchform.t.value='';"></input>
<a id="searchlink"  title="www.google.com"  href="javascript:onSearch();" onclick="return onSearch()">Search</a></form>
</div>
<div class="descrhead"><div class="descrheadcontent">
<span class="descrtitle">Source:</span>
<a class="descrheadentry" href="src/ROOT__Math__GSLMultiRootFinder.h.html">header file</a>
<a class="descrheadentry"> </a>
<a class="descrheadentry" href="http://root.cern.ch/viewcvs/trunk/mathmore/inc/Math/GSLMultiRootFinder.h?view=log">viewVC header</a> <a class="descrheadentry"> </a> 
</div></div>
<div class="descrhead"><div class="descrheadcontent">
<span class="descrtitle">Sections:</span>
<a class="descrheadentry" href="#ROOT__Math__GSLMultiRootFinder:description">class description</a> 
<a class="descrheadentry" href="#ROOT__Math__GSLMultiRootFinder:Function_Members">function members</a>
<a class="descrheadentry" href="#ROOT__Math__GSLMultiRootFinder:Data_Members">data members</a>
<a class="descrheadentry" href="#ROOT__Math__GSLMultiRootFinder:Class_Charts">class charts</a>
</div></div>
</div>
<div class="location">
<a class="locationlevel" href="index.html">ROOT</a>
 &#187; <a class="locationlevel" href="./MATH_Index.html">MATH</a>
 &#187; <a class="locationlevel" href="./MATH_MATHMORE_Index.html">MATHMORE</a>
 &#187; <a class="locationlevel" href="#TopOfPage">ROOT::Math::GSLMultiRootFinder</a>
</div>
<div class="dropshadow"><div class="withshadow"><h1><a name="ROOT__Math__GSLMultiRootFinder:description"></a>class ROOT::Math::GSLMultiRootFinder</h1>
<div class="classdescr">
<pre>

     Class for  Multidimensional root finding algorithms bassed on GSL. This class is used to solve a
     non-linear system of equations:

     f1(x1,....xn) = 0
     f2(x1,....xn) = 0
     ..................
     fn(x1,....xn) = 0

     See the GSL &lt;A HREF=<span class="string">"http://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Root_002dFinding.html"</span>&gt; online manual&lt;/A&gt; for
     information on the GSL MultiRoot finding algorithms

     The available GSL algorithms require the derivatives of the supplied functions or not (they are
     computed internally by GSL). In the first case the user needs to provide a list of multidimensional functions implementing the
     gradient interface (<a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__IMultiGradFunction.html">IMultiGradFunction</a>) while in the second case it is enough to supply a list of
     functions impelmenting the <a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__IMultiGenFunction.html">IMultiGenFunction</a> interface.
     The available algorithms requiring derivatives (see also the GSL
     &lt;A HREF=<span class="string">"http://www.gnu.org/software/gsl/manual/html_node/Algorithms-using-Derivatives.html"</span>&gt;documentation&lt;/A&gt; )
     are the followings:
     &lt;ul&gt;
         &lt;li&gt;&lt;tt&gt;<a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html">GSLMultiRootFinder</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html#ROOT__Math__GSLMultiRootFinder:kHybridSJ" title="const ROOT::Math::GSLMultiRootFinder::EDerivType ROOT::Math::GSLMultiRootFinder::kHybridSJ">kHybridSJ</a>&lt;/tt&gt;  with name &lt;it&gt;<span class="string">"HybridSJ"</span>&lt;/it&gt;: modified Powell's hybrid
     method as implemented in HYBRJ in MINPACK
         &lt;li&gt;&lt;tt&gt;<a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html">GSLMultiRootFinder</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html#ROOT__Math__GSLMultiRootFinder:kHybridJ" title="const ROOT::Math::GSLMultiRootFinder::EDerivType ROOT::Math::GSLMultiRootFinder::kHybridJ">kHybridJ</a>&lt;/tt&gt;  with name &lt;it&gt;<span class="string">"HybridJ"</span>&lt;/it&gt;: unscaled version of the
     previous algorithm&lt;/li&gt;
         &lt;li&gt;&lt;tt&gt;<a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html">GSLMultiRootFinder</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html#ROOT__Math__GSLMultiRootFinder:kNewton" title="const ROOT::Math::GSLMultiRootFinder::EDerivType ROOT::Math::GSLMultiRootFinder::kNewton">kNewton</a>&lt;/tt&gt;  with name &lt;it&gt;<span class="string">"Newton"</span>&lt;/it&gt;: Newton method &lt;/li&gt;
         &lt;li&gt;&lt;tt&gt;<a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html">GSLMultiRootFinder</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html#ROOT__Math__GSLMultiRootFinder:kGNewton" title="const ROOT::Math::GSLMultiRootFinder::EDerivType ROOT::Math::GSLMultiRootFinder::kGNewton">kGNewton</a>&lt;/tt&gt;  with name &lt;it&gt;<span class="string">"GNewton"</span>&lt;/it&gt;: modified Newton method &lt;/li&gt;
     &lt;/ul&gt;
     The algorithms without derivatives (see also the GSL
     &lt;A HREF=<span class="string">"http://www.gnu.org/software/gsl/manual/html_node/Algorithms-without-Derivatives.html"</span>&gt;documentation&lt;/A&gt; )
     are the followings:
     &lt;ul&gt;
         &lt;li&gt;&lt;tt&gt;<a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html">GSLMultiRootFinder</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html#ROOT__Math__GSLMultiRootFinder:kHybridS" title="const ROOT::Math::GSLMultiRootFinder::EType ROOT::Math::GSLMultiRootFinder::kHybridS">kHybridS</a>&lt;/tt&gt;  with name &lt;it&gt;<span class="string">"HybridS"</span>&lt;/it&gt;: same as HybridSJ but using
     finate difference approximation for the derivatives&lt;/li&gt;
         &lt;li&gt;&lt;tt&gt;<a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html">GSLMultiRootFinder</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html#ROOT__Math__GSLMultiRootFinder:kHybrid" title="const ROOT::Math::GSLMultiRootFinder::EType ROOT::Math::GSLMultiRootFinder::kHybrid">kHybrid</a>&lt;/tt&gt;  with name &lt;it&gt;<span class="string">"Hybrid"</span>&lt;/it&gt;: unscaled version of the
     previous algorithm&lt;/li&gt;
         &lt;li&gt;&lt;tt&gt;<a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html">GSLMultiRootFinder</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html#ROOT__Math__GSLMultiRootFinder:kDNewton" title="const ROOT::Math::GSLMultiRootFinder::EType ROOT::Math::GSLMultiRootFinder::kDNewton">kDNewton</a>&lt;/tt&gt;  with name &lt;it&gt;<span class="string">"DNewton"</span>&lt;/it&gt;: discrete Newton algorithm &lt;/li&gt;
         &lt;li&gt;&lt;tt&gt;<a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html">GSLMultiRootFinder</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html#ROOT__Math__GSLMultiRootFinder:kBroyden" title="const ROOT::Math::GSLMultiRootFinder::EType ROOT::Math::GSLMultiRootFinder::kBroyden">kBroyden</a>&lt;/tt&gt;  with name &lt;it&gt;<span class="string">"Broyden"</span>&lt;/it&gt;: Broyden algorithm &lt;/li&gt;
     &lt;/ul&gt;

     @ingroup MultiRoot

</pre><h4>This class is also known as (typedefs to this class)</h4><a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__MultiRootFinder.html">MultiRootFinder</a></div>
</div></div>

<div id="functions">
<h2><a id="ROOT__Math__GSLMultiRootFinder:Function_Members"></a>Function Members (Methods)</h2>
<div class="access" id="funcpubl"><b>public:</b>
<table class="func" id="tabfuncpubl" cellspacing="0">
<tr class="func"><td class="funcret"> virtual</td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:_GSLMultiRootFinder">~GSLMultiRootFinder</a>()</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">int</span></td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:AddFunction">AddFunction</a>(<span class="keyword">const</span> <a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__IMultiGenFunction.html">IMultiGenFunction</a>&amp; func)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:Clear">Clear</a>()</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">unsigned</span> <span class="keyword">int</span></td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:Dim">Dim</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><span class="keyword">const</span> <span class="keyword">double</span>*</td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:Dx">Dx</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><span class="keyword">const</span> <span class="keyword">double</span>*</td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:FVal">FVal</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html">GSLMultiRootFinder</a></td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:GSLMultiRootFinder">GSLMultiRootFinder</a>(<a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html">GSLMultiRootFinder</a>::EType type)</td></tr>
<tr class="func"><td class="funcret"><a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html">GSLMultiRootFinder</a></td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:GSLMultiRootFinder%1">GSLMultiRootFinder</a>(<a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html">GSLMultiRootFinder</a>::EDerivType type)</td></tr>
<tr class="func"><td class="funcret"><a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html">GSLMultiRootFinder</a></td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:GSLMultiRootFinder%2">GSLMultiRootFinder</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name = 0)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">int</span></td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:Iterations">Iterations</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><span class="keyword">const</span> <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:Name">Name</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><span class="keyword">int</span></td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:PrintLevel">PrintLevel</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:PrintState">PrintState</a>(<a href="./ListOfTypes.html#ostream">ostream</a>&amp; os = std::<a href="./ListOfTypes.html#ostream">cout</a>)</td></tr>
<tr class="func"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:SetDefaultMaxIterations">SetDefaultMaxIterations</a>(<span class="keyword">int</span> maxiter)</td></tr>
<tr class="func"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:SetDefaultTolerance">SetDefaultTolerance</a>(<span class="keyword">double</span> abstol, <span class="keyword">double</span> reltol = 0)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:SetPrintLevel">SetPrintLevel</a>(<span class="keyword">int</span> level)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:SetType">SetType</a>(<a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html">GSLMultiRootFinder</a>::EType type)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:SetType%1">SetType</a>(<a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html">GSLMultiRootFinder</a>::EDerivType type)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:SetType%2">SetType</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">bool</span></td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:Solve">Solve</a>(<span class="keyword">const</span> <span class="keyword">double</span>* x, <span class="keyword">int</span> maxIter = 0, <span class="keyword">double</span> absTol = 0, <span class="keyword">double</span> relTol = 0)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">int</span></td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:Status">Status</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><span class="keyword">const</span> <span class="keyword">double</span>*</td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:X">X</a>() <span class="keyword">const</span></td></tr>

</table></div>
<div class="access" id="funcprot"><b>protected:</b>
<table class="func" id="tabfuncprot" cellspacing="0">
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:ClearFunctions">ClearFunctions</a>()</td></tr>
<tr class="func"><td class="funcret">pair&lt;<span class="keyword">bool</span>,<span class="keyword">int</span>&gt;</td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:GetType">GetType</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</td></tr>

</table></div>
<div class="access" id="funcpriv"><b>private:</b>
<table class="func" id="tabfuncpriv" cellspacing="0">
<tr class="func"><td class="funcret"><a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html">GSLMultiRootFinder</a></td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:GSLMultiRootFinder%3">GSLMultiRootFinder</a>(<span class="keyword">const</span> <a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html">GSLMultiRootFinder</a>&amp;)</td></tr>
<tr class="func"><td class="funcret"><a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html">GSLMultiRootFinder</a>&amp;</td><td class="funcname"><a class="funcname" href="#ROOT__Math__GSLMultiRootFinder:operator_">operator=</a>(<span class="keyword">const</span> <a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__GSLMultiRootFinder.html">GSLMultiRootFinder</a>&amp;)</td></tr>

</table></div>
</div>

<div id="datamembers">
<h2><a name="ROOT__Math__GSLMultiRootFinder:Data_Members"></a>Data Members</h2>
<div class="access" id="enumpubl"><b>public:</b>
<table class="data" id="tabenumpubl" cellspacing="0">
<tr class="data"><td class="datatype">enum EDerivType { </td><td class="dataname"><a name="ROOT__Math__GSLMultiRootFinder:kHybridSJ"></a>kHybridSJ</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="ROOT__Math__GSLMultiRootFinder:kHybridJ"></a>kHybridJ</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="ROOT__Math__GSLMultiRootFinder:kNewton"></a>kNewton</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="ROOT__Math__GSLMultiRootFinder:kGNewton"></a>kGNewton</td><td></td></tr>
<tr class="data"><td class="datatype">};</td><td></td><td></td></tr>
<tr class="data"><td class="datatype">enum EType { </td><td class="dataname"><a name="ROOT__Math__GSLMultiRootFinder:kHybridS"></a>kHybridS</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="ROOT__Math__GSLMultiRootFinder:kHybrid"></a>kHybrid</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="ROOT__Math__GSLMultiRootFinder:kDNewton"></a>kDNewton</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="ROOT__Math__GSLMultiRootFinder:kBroyden"></a>kBroyden</td><td></td></tr>
<tr class="data"><td class="datatype">};</td><td></td><td></td></tr>

</table></div>
<div class="access" id="datapriv"><b>private:</b>
<table class="data" id="tabdatapriv" cellspacing="0">
<tr class="data"><td class="datatype">vector&lt;<a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__IMultiGenFunction.html">IMultiGenFunction</a>*&gt;</td><td class="dataname"><a name="ROOT__Math__GSLMultiRootFinder:fFunctions"></a>fFunctions</td><td class="datadesc">! transient Vector of the functions </td></tr>
<tr class="data"><td class="datatype"><span class="keyword">int</span></td><td class="dataname"><a name="ROOT__Math__GSLMultiRootFinder:fIter"></a>fIter</td><td class="datadesc">current numer of iterations</td></tr>
<tr class="data"><td class="datatype"><span class="keyword">int</span></td><td class="dataname"><a name="ROOT__Math__GSLMultiRootFinder:fPrintLevel"></a>fPrintLevel</td><td class="datadesc">print level </td></tr>
<tr class="data"><td class="datatype"><a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::GSLMultiRootBaseSolver*</td><td class="dataname"><a name="ROOT__Math__GSLMultiRootFinder:fSolver"></a>fSolver</td><td></td></tr>
<tr class="data"><td class="datatype"><span class="keyword">int</span></td><td class="dataname"><a name="ROOT__Math__GSLMultiRootFinder:fStatus"></a>fStatus</td><td class="datadesc">current status </td></tr>
<tr class="data"><td class="datatype"><span class="keyword">int</span></td><td class="dataname"><a name="ROOT__Math__GSLMultiRootFinder:fType"></a>fType</td><td class="datadesc">type of algorithm </td></tr>
<tr class="data"><td class="datatype"><span class="keyword">bool</span></td><td class="dataname"><a name="ROOT__Math__GSLMultiRootFinder:fUseDerivAlgo"></a>fUseDerivAlgo</td><td class="datadesc">algorithm using derivative</td></tr>

</table></div>
</div>
<h2><a id="ROOT__Math__GSLMultiRootFinder:Class_Charts"></a>Class Charts</h2>
<map name="MapROOT__Math__GSLMultiRootFinder_Lib" id="MapROOT__Math__GSLMultiRootFinder_Lib">
<area shape="rect" href="LibraryDependencies.html" title="All Libraries" alt="" coords="513,83,641,131"/>
</map>
<div class="tabs">
<a id="imgROOT__Math__GSLMultiRootFinder_Inh" class="tabsel" href="inh/ROOT__Math__GSLMultiRootFinder_Inh.png" onclick="javascript:return SetImg('Charts','inh/ROOT__Math__GSLMultiRootFinder_Inh.png');">Inheritance</a>
<a id="imgROOT__Math__GSLMultiRootFinder_InhMem" class="tab" href="inhmem/ROOT__Math__GSLMultiRootFinder_InhMem.png" onclick="javascript:return SetImg('Charts','inhmem/ROOT__Math__GSLMultiRootFinder_InhMem.png');">Inherited Members</a>
<a id="imgROOT__Math__GSLMultiRootFinder_Incl" class="tab" href="incl/ROOT__Math__GSLMultiRootFinder_Incl.png" onclick="javascript:return SetImg('Charts','incl/ROOT__Math__GSLMultiRootFinder_Incl.png');">Includes</a>
<a id="imgROOT__Math__GSLMultiRootFinder_Lib" class="tab" href="lib/ROOT__Math__GSLMultiRootFinder_Lib.png" onclick="javascript:return SetImg('Charts','lib/ROOT__Math__GSLMultiRootFinder_Lib.png');">Libraries</a><br/>
</div><div class="classcharts"><div class="classchartswidth"></div>
<img id="Charts" alt="Class Charts" class="classcharts" usemap="#MapROOT__Math__GSLMultiRootFinder_Inh" src="inh/ROOT__Math__GSLMultiRootFinder_Inh.png"/></div>
<h2>Function documentation</h2>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:GSLMultiRootFinder" href="src/ROOT__Math__GSLMultiRootFinder.h.html#v78NwE">GSLMultiRootFinder</a>(EType type)</span><br />
<div class="funccomm"><pre> create a multi-root finder based on an algorithm not requiring function derivative
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:GSLMultiRootFinder" href="src/ROOT__Math__GSLMultiRootFinder.h.html#kDJEqE">GSLMultiRootFinder</a>(EDerivType type)</span><br />
<div class="funccomm"><pre> create a multi-root finder based on an algorithm requiring function derivative
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:GSLMultiRootFinder%2" href="src/ROOT__Math__GSLMultiRootFinder.h.html#q7sYsC">GSLMultiRootFinder</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name = 0)</span><br />
<div class="funccomm"><pre>
      create a multi-root finder using a string.
      The names are those defined in the GSL manuals
      after having remived the GSL prefix (gsl_multiroot_fsolver).
      Default algorithm  is <span class="string">"hybrids"</span> (without derivative).

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">virtual</span> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:_GSLMultiRootFinder" href="src/ROOT__Math__GSLMultiRootFinder.h.html#b7KzQB">~GSLMultiRootFinder</a>()</span><br />
<div class="funccomm"><pre> destructor
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:GSLMultiRootFinder" href="src/ROOT__Math__GSLMultiRootFinder.h.html#v3JHdD">GSLMultiRootFinder</a>(<span class="keyword">const</span> <a href="./ROOT__Math__GSLMultiRootFinder.html#ROOT__Math__GSLMultiRootFinder:GSLMultiRootFinder" title="ROOT::Math::GSLMultiRootFinder ROOT::Math::GSLMultiRootFinder::GSLMultiRootFinder(ROOT::Math::GSLMultiRootFinder::EType type) or overloads">GSLMultiRootFinder</a> &amp;)</span><br />
<div class="funccomm"><pre> usually copying is non trivial, so we make this unaccessible
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:SetType" href="src/ROOT__Math__GSLMultiRootFinder.h.html#URVIwD">SetType</a>(EType type)</span><br />
<div class="funccomm"><pre> set the type for an algorithm without derivatives
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:SetType" href="src/ROOT__Math__GSLMultiRootFinder.h.html#Eb7J6D">SetType</a>(EDerivType type)</span><br />
<div class="funccomm"><pre> set the type of algorithm using derivatives
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:SetType%2" href="src/ROOT__Math__GSLMultiRootFinder.h.html#f8cYQB">SetType</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span><br />
<div class="funccomm"><pre> set the type using a string
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">int</span> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:AddFunction" href="src/ROOT__Math__GSLMultiRootFinder.h.html#xOoa6B">AddFunction</a>(<span class="keyword">const</span> <a href="./ROOT.html">ROOT</a>::<a href="./ROOT__Math.html">Math</a>::<a href="./ROOT__Math__IMultiGenFunction.html">IMultiGenFunction</a>&amp; func)</span><br />
<div class="funccomm"><pre>
      add (set) a single function fi(x1,...xn) which is part of the system of
       specifying the begin and end of the iterator.
       If using a derivative type algorithm the function must implement the
       ROOOT::Math::IMultiGradFunction interface
       Return the current number of function in the list and 0 if failed to add the function

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">unsigned</span>  <span class="keyword">int</span> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:Dim" href="src/ROOT__Math__GSLMultiRootFinder.h.html#SVUTQ">Dim</a>() const</span><br />
<div class="funccomm"><pre>
       return the number of sunctions set in the class.
       The number must be equal to the dimension of the functions

</pre></div>

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./ROOT__Math__GSLMultiRootFinder.html#ROOT__Math__GSLMultiRootFinder:fFunctions" title="vector&lt;ROOT::Math::IMultiGenFunction*&gt; ROOT::Math::GSLMultiRootFinder::fFunctions">fFunctions</a>.size(); }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:Clear" href="src/ROOT__Math__GSLMultiRootFinder.h.html#Pcilr">Clear</a>()</span><br />
<div class="funccomm"><pre> clear list of functions
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">const</span> <span class="keyword">double</span> * <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:X" href="src/ROOT__Math__GSLMultiRootFinder.h.html#fwsgK">X</a>() const</span><br />
<div class="funccomm"><pre> return the root <a href="./ROOT__Math__GSLMultiRootFinder.html#ROOT__Math__GSLMultiRootFinder:X" title="const double* ROOT::Math::GSLMultiRootFinder::X()">X</a> values solving the system
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">const</span> <span class="keyword">double</span> * <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:FVal" href="src/ROOT__Math__GSLMultiRootFinder.h.html#c8sL3B">FVal</a>() const</span><br />
<div class="funccomm"><pre> return the function values f(<a href="./ROOT__Math__GSLMultiRootFinder.html#ROOT__Math__GSLMultiRootFinder:X" title="const double* ROOT::Math::GSLMultiRootFinder::X()">X</a>) solving the system
 i.e. they must be close to zero at the solution
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">const</span> <span class="keyword">double</span> * <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:Dx" href="src/ROOT__Math__GSLMultiRootFinder.h.html#roz._D">Dx</a>() const</span><br />
<div class="funccomm"><pre> return the last step size
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">bool</span> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:Solve" href="src/ROOT__Math__GSLMultiRootFinder.h.html#I.A.1E">Solve</a>(<span class="keyword">const</span> <span class="keyword">double</span>* x, <span class="keyword">int</span> maxIter = 0, <span class="keyword">double</span> absTol = 0, <span class="keyword">double</span> relTol = 0)</span><br />
<div class="funccomm"><pre>
       Find the root starting from the point <a href="./ROOT__Math__GSLMultiRootFinder.html#ROOT__Math__GSLMultiRootFinder:X" title="const double* ROOT::Math::GSLMultiRootFinder::X()">X</a>;
       Use the number of iteration and tolerance if given otherwise use
       default parameter values which can be defined by
       the static method SetDefault...

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">int</span> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:Iterations" href="src/ROOT__Math__GSLMultiRootFinder.h.html#X.ZuJB">Iterations</a>() const</span><br />
<div class="funccomm"><pre> Return number of iterations
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">int</span> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:Status" href="src/ROOT__Math__GSLMultiRootFinder.h.html#k6SP2E">Status</a>() const</span><br />
<div class="funccomm"><pre> Return the status of last root finding
</pre></div>

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./ROOT__Math__GSLMultiRootFinder.html#ROOT__Math__GSLMultiRootFinder:fStatus" title="int ROOT::Math::GSLMultiRootFinder::fStatus">fStatus</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">const</span> <span class="keyword">char</span> * <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:Name" href="src/ROOT__Math__GSLMultiRootFinder.h.html#GtsGZC">Name</a>() const</span><br />
<div class="funccomm"><pre> Return the algorithm name
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:SetPrintLevel" href="src/ROOT__Math__GSLMultiRootFinder.h.html#A9sDfD">SetPrintLevel</a>(<span class="keyword">int</span> level)</span><br />
<div class="funccomm"><pre>
       set print level
       level = 0  quiet (no messages print)
             = 1  print only the result
             = 3  max debug. Print result at each iteration

</pre></div>

<div class="code"><code class="inlinecode">{ <a href="./ROOT__Math__GSLMultiRootFinder.html#ROOT__Math__GSLMultiRootFinder:fPrintLevel" title="int ROOT::Math::GSLMultiRootFinder::fPrintLevel">fPrintLevel</a> = level; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">int</span> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:PrintLevel" href="src/ROOT__Math__GSLMultiRootFinder.h.html#TnMQq">PrintLevel</a>() const</span><br />
<div class="funccomm"><pre> return the print level
</pre></div>

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./ROOT__Math__GSLMultiRootFinder.html#ROOT__Math__GSLMultiRootFinder:fPrintLevel" title="int ROOT::Math::GSLMultiRootFinder::fPrintLevel">fPrintLevel</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:SetDefaultTolerance" href="src/ROOT__Math__GSLMultiRootFinder.h.html#MSeSRC">SetDefaultTolerance</a>(<span class="keyword">double</span> abstol, <span class="keyword">double</span> reltol = 0)</span><br />
<div class="funccomm"><pre>-- static methods to set configurations
 set tolerance (absolute and relative)
 relative tolerance is only use to verify the convergence
 do it is a minor parameter
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:SetDefaultMaxIterations" href="src/ROOT__Math__GSLMultiRootFinder.h.html#SlzVq">SetDefaultMaxIterations</a>(<span class="keyword">int</span> maxiter)</span><br />
<div class="funccomm"><pre> set maximum number of iterations
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:PrintState" href="src/ROOT__Math__GSLMultiRootFinder.h.html#nD0H8B">PrintState</a>(<a href="./ListOfTypes.html#ostream">ostream</a>&amp; os = std::<a href="./ListOfTypes.html#ostream">cout</a>)</span><br />
<div class="funccomm"><pre> print iteration state
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">std::pair&lt;<span class="keyword">bool</span>,<span class="keyword">int</span>&gt; <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:GetType" href="src/ROOT__Math__GSLMultiRootFinder.h.html#BcNQT">GetType</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span><br />
<div class="funccomm"><pre> return type given a name
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="ROOT__Math__GSLMultiRootFinder:ClearFunctions" href="src/ROOT__Math__GSLMultiRootFinder.h.html#z54miD">ClearFunctions</a>()</span><br />
<div class="funccomm"><pre> clear list of functions
</pre></div>
</div>

<br />
<!--SIGNATURE-->
<div id="footer">
<em>&raquo; Author: <a href="http://consult.cern.ch/xwho/people?L.+Moneta"> L. Moneta  03/2011</a> </em><em>&raquo; Copyright   (c) 2004 ROOT Foundation,  CERN/PH-SFT                   *</em><br />
<em>&raquo; Last changed: root/mathmore:$Id: GSLMultiRootFinder.h 38726 2011-04-04 14:05:51Z moneta $ </em><em>&raquo; Last generated: 2011-11-03 20:04</em><br />
<em>This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>.</em>
</div>
</div>
</body>
</html>
