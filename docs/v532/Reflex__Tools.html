<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!--                                             -->
<!-- Author: ROOT team (rootdev@pcroot.cern.ch)  -->
<!--                                             -->
<!--   Date: Thu Nov  3 20:06:28 2011            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<title>Reflex::Tools</title>
<meta name="rating" content="General" />
<meta name="objecttype" content="Manual" />
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers, cern" />
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis." />
<link rel="stylesheet" type="text/css" href="ROOT.css" id="ROOTstyle" />
<script type="text/javascript" src="ROOT.js"></script>
</head>
<body  onload="javascript:SetValuesFromCookie();"><div id="body_content">
<div id="root_header"><img src="http://root.cern.ch/drupal/sites/default/files/rootdrawing-logo.png" alt="ROOT logo"/></div>
<a name="TopOfPage"></a>
<script type="text/javascript">WriteFollowPageBox('namespace Reflex::Tools','','Reflex/Tools.h');</script>
<div id="toplinks">
<div class="descrhead"><div class="descrheadcontent">
<span class="descrtitle">Quick Links:</span>
<a class="descrheadentry" href="http://root.cern.ch">ROOT Homepage</a>
<a class="descrheadentry" href="./ClassIndex.html">Class Index</a>
<a class="descrheadentry" href="./ClassHierarchy.html">Class Hierarchy</a></div>
<script type="text/javascript">
function onSearch() {
var s='http://www.google.com/search?q=%s+site%3A%u+-site%3A%u%2Fsrc%2F+-site%3A%u%2Fexamples%2F';
var ref=String(document.location.href).replace(/https?:\/\//,'').replace(/\/[^\/]*$/,'').replace(/\//g,'%2F');
window.location.href=s.replace(/%u/ig,ref).replace(/%s/ig,escape(document.searchform.t.value));
return false;}
</script>
<form id="searchform" name="searchform" onsubmit="return onSearch()" action="javascript:onSearch();" method="post">
<input name="t" size="30" value="Search documentation..." onfocus="if (document.searchform.t.value=='Search documentation...') document.searchform.t.value='';"></input>
<a id="searchlink"  title="www.google.com"  href="javascript:onSearch();" onclick="return onSearch()">Search</a></form>
</div>
<div class="descrhead"><div class="descrheadcontent">
<span class="descrtitle">Source:</span>
<a class="descrheadentry" href="src/Reflex__Tools.h.html">header file</a>
<a class="descrheadentry"> </a>
<a class="descrheadentry" href="http://root.cern.ch/viewcvs/trunk//inc/Reflex/Tools.h?view=log">viewVC header</a> <a class="descrheadentry"> </a> 
</div></div>
<div class="descrhead"><div class="descrheadcontent">
<span class="descrtitle">Sections:</span>
<a class="descrheadentry" href="#Reflex__Tools:description">namespace description</a> 
<a class="descrheadentry" href="#Reflex__Tools:Function_Members">function members</a>
<a class="descrheadentry" href="#Reflex__Tools:Data_Members">data members</a>
<a class="descrheadentry" href="#Reflex__Tools:Class_Charts">class charts</a>
</div></div>
</div>
<div class="location">
<a class="locationlevel" href="index.html">ROOT</a>
 &#187; <a class="locationlevel" href="./CINT_Index.html">CINT</a>
 &#187; <a class="locationlevel" href="./CINT_REFLEX_Index.html">REFLEX</a>
 &#187; <a class="locationlevel" href="#TopOfPage">Reflex::Tools</a>
</div>
<div class="dropshadow"><div class="withshadow"><h1><a name="Reflex__Tools:description"></a>namespace Reflex::Tools</h1>
<div class="classdescr">
</div>
</div></div>

<div id="functions">
<h2><a id="Reflex__Tools:Function_Members"></a>Function Members (Methods)</h2>
<div class="access" id="funcpubl"><b>public:</b>
<table class="func" id="tabfuncpubl" cellspacing="0">
<tr class="func"><td class="funcret">string</td><td class="funcname"><a class="funcname" href="#Reflex__Tools:BuildTypeName">BuildTypeName</a>(<a href="./Reflex.html">Reflex</a>::<a href="./Reflex__Type.html">Type</a>&amp; t, <span class="keyword">unsigned</span> <span class="keyword">int</span> modifiers)</td></tr>
<tr class="func"><td class="funcret">string</td><td class="funcname"><a class="funcname" href="#Reflex__Tools:Demangle">Demangle</a>(<span class="keyword">const</span> type_info&amp; ti)</td></tr>
<tr class="func"><td class="funcret"><a href="./Reflex.html">Reflex</a>::EFUNDAMENTALTYPE</td><td class="funcname"><a class="funcname" href="#Reflex__Tools:FundamentalType">FundamentalType</a>(<span class="keyword">const</span> <a href="./Reflex.html">Reflex</a>::<a href="./Reflex__Type.html">Type</a>&amp; typ)</td></tr>
<tr class="func"><td class="funcret">vector&lt;std::string&gt;</td><td class="funcname"><a class="funcname" href="#Reflex__Tools:GenTemplateArgVec">GenTemplateArgVec</a>(<span class="keyword">const</span> string&amp; name)</td></tr>
<tr class="func"><td class="funcret">string</td><td class="funcname"><a class="funcname" href="#Reflex__Tools:GetBaseName">GetBaseName</a>(<span class="keyword">const</span> string&amp; name, <span class="keyword">bool</span> startFromLeft = <span class="keyword">false</span>)</td></tr>
<tr class="func"><td class="funcret"><a href="./ListOfTypes.html#size_t">size_t</a></td><td class="funcname"><a class="funcname" href="#Reflex__Tools:GetBasePosition">GetBasePosition</a>(<span class="keyword">const</span> string&amp; name)</td></tr>
<tr class="func"><td class="funcret"><a href="./ListOfTypes.html#size_t">size_t</a></td><td class="funcname"><a class="funcname" href="#Reflex__Tools:GetFirstScopePosition">GetFirstScopePosition</a>(<span class="keyword">const</span> string&amp; name, <a href="./ListOfTypes.html#size_t">size_t</a>&amp; start)</td></tr>
<tr class="func"><td class="funcret">string</td><td class="funcname"><a class="funcname" href="#Reflex__Tools:GetScopeName">GetScopeName</a>(<span class="keyword">const</span> string&amp; name, <span class="keyword">bool</span> startFromLeft = <span class="keyword">false</span>)</td></tr>
<tr class="func"><td class="funcret">string</td><td class="funcname"><a class="funcname" href="#Reflex__Tools:GetTemplateArguments">GetTemplateArguments</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#Reflex__Tools:GetTemplateComponents">GetTemplateComponents</a>(<span class="keyword">const</span> string&amp; Name, string&amp; templatename, vector&lt;std::string&gt;&amp; args)</td></tr>
<tr class="func"><td class="funcret">string</td><td class="funcname"><a class="funcname" href="#Reflex__Tools:GetTemplateName">GetTemplateName</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">bool</span></td><td class="funcname"><a class="funcname" href="#Reflex__Tools:IsTemplated">IsTemplated</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</td></tr>
<tr class="func"><td class="funcret">string</td><td class="funcname"><a class="funcname" href="#Reflex__Tools:NormalizeName">NormalizeName</a>(<span class="keyword">const</span> string&amp; name)</td></tr>
<tr class="func"><td class="funcret">string</td><td class="funcname"><a class="funcname" href="#Reflex__Tools:NormalizeName%1">NormalizeName</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#Reflex__Tools:StringSplit">StringSplit</a>(vector&lt;std::string&gt;&amp; splitValues, <span class="keyword">const</span> string&amp; str, <span class="keyword">const</span> string&amp; delim = <span class="string">","</span>)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#Reflex__Tools:StringSplitPair">StringSplitPair</a>(string&amp; val1, string&amp; val2, <span class="keyword">const</span> string&amp; str, <span class="keyword">const</span> string&amp; delim = <span class="string">","</span>)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#Reflex__Tools:StringStrip">StringStrip</a>(string&amp; str)</td></tr>
<tr class="func"><td class="funcret">string</td><td class="funcname"><a class="funcname" href="#Reflex__Tools:StringVec2String">StringVec2String</a>(<span class="keyword">const</span> vector&lt;std::string&gt;&amp; vec)</td></tr>

</table></div>
</div>
<h2><a id="Reflex__Tools:Class_Charts"></a>Class Charts</h2>
<h2>Function documentation</h2>
<div class="funcdoc"><span class="funcname">RFLX_API EFUNDAMENTALTYPE <a class="funcname" name="Reflex__Tools:FundamentalType" href="src/Reflex__Tools.h.html#groCfB">FundamentalType</a>(<span class="keyword">const</span> <a href="./Reflex.html">Reflex</a>::<a href="./Reflex__Type.html">Type</a>&amp; typ)</span><br />
<div class="funccomm"><pre>
 * GetFundamentalType will return an enum representing the
 * fundamental type which was passed in, or NOFUNDAMENTALTYPE
 * @param typ the type passed into the system
 * @return enum representing kind of fundamental type

</pre></div>
</div>
<div class="funcdoc"><span class="funcname">RFLX_API std::string <a class="funcname" name="Reflex__Tools:Demangle" href="src/Reflex__Tools.h.html#etpHd">Demangle</a>(<span class="keyword">const</span> type_info&amp; ti)</span><br />
<div class="funccomm"><pre>
 * <a href="./Reflex__Tools.html#Reflex__Tools:Demangle" title="string Reflex::Tools::Demangle(const type_info&amp; ti)">Demangle</a> will call the internal demangling routines and
 * return the demangled string of a At
 * @param ti the mangled At string
 * @return the demangled string

</pre></div>
</div>
<div class="funcdoc"><span class="funcname">RFLX_API <span class="keyword">void</span> <a class="funcname" name="Reflex__Tools:StringSplit" href="src/Reflex__Tools.h.html#xgBRhC">StringSplit</a>(vector&lt;std::string&gt;&amp; splitValues, <span class="keyword">const</span> string&amp; str, <span class="keyword">const</span> string&amp; delim = <span class="string">","</span>)</span><br />
<div class="funccomm"><pre>
 * <a href="./Reflex__Tools.html#Reflex__Tools:StringSplit" title="void Reflex::Tools::StringSplit(vector&lt;std::string&gt;&amp; splitValues,const string&amp; str,const string&amp; delim=&quot;,&quot;)">StringSplit</a> will return a vector of splitted strings
 * @param  splitValues returns the vector with splitted strings
 * @param  str the input string
 * @param  delim the delimiter on which to split

</pre></div>
</div>
<div class="funcdoc"><span class="funcname">RFLX_API <span class="keyword">void</span> <a class="funcname" name="Reflex__Tools:StringStrip" href="src/Reflex__Tools.h.html#lVAz3C">StringStrip</a>(string&amp; str)</span><br />
<div class="funccomm"><pre>
 * <a href="./Reflex__Tools.html#Reflex__Tools:StringSplitPair" title="void Reflex::Tools::StringSplitPair(string&amp; val1,string&amp; val2,const string&amp; str,const string&amp; delim=&quot;,&quot;)">StringSplitPair</a> will return two values which are split
 * @param  val1 returns the first value
 * @param  val2 returns the second value
 * @param  str the string to be split
 * @param  delim the delimiter on which to split


 * <a href="./Reflex__Tools.html#Reflex__Tools:StringStrip" title="void Reflex::Tools::StringStrip(string&amp; str)">StringStrip</a> will strip off Empty spaces of a string
 * @param str a reference to a string to be stripped

</pre></div>
</div>
<div class="funcdoc"><span class="funcname">RFLX_API std::string <a class="funcname" name="Reflex__Tools:StringVec2String" href="src/Reflex__Tools.h.html#ateMv">StringVec2String</a>(<span class="keyword">const</span> vector&lt;std::string&gt;&amp; vec)</span><br />
<div class="funccomm"><pre>
 * <a href="./Reflex__Tools.html#Reflex__Tools:StringVec2String" title="string Reflex::Tools::StringVec2String(const vector&lt;std::string&gt;&amp; vec)">StringVec2String</a> will take a vector of strings and return the
 * vector containees concatenated by commas
 * @param vec the vector to be converted
 * @return string of comma concatenated containees

</pre></div>
</div>
<div class="funcdoc"><span class="funcname">RFLX_API std::string <a class="funcname" name="Reflex__Tools:BuildTypeName" href="src/Reflex__Tools.h.html#F6z3X">BuildTypeName</a>(<a href="./Reflex.html">Reflex</a>::<a href="./Reflex__Type.html">Type</a>&amp; t, <span class="keyword">unsigned</span> <span class="keyword">int</span> modifiers)</span><br />
</div>
<div class="funcdoc"><span class="funcname">RFLX_API <span class="keyword">void</span> <a class="funcname" name="Reflex__Tools:GetTemplateComponents" href="src/Reflex__Tools.h.html#S9sD5C">GetTemplateComponents</a>(<span class="keyword">const</span> string&amp; Name, string&amp; templatename, vector&lt;std::string&gt;&amp; args)</span><br />
<div class="funccomm"><pre>
 * <a href="./Reflex__Tools.html#Reflex__Tools:GetTemplateComponents" title="void Reflex::Tools::GetTemplateComponents(const string&amp; Name,string&amp; templatename,vector&lt;std::string&gt;&amp; args)">GetTemplateComponents</a> extract from 'Name' a template name and a vector containing its argument.
 *

</pre></div>
</div>
<div class="funcdoc"><span class="funcname">RFLX_API <a href="./ListOfTypes.html#size_t">size_t</a> <a class="funcname" name="Reflex__Tools:GetFirstScopePosition" href="src/Reflex__Tools.h.html#idDHqE">GetFirstScopePosition</a>(<span class="keyword">const</span> string&amp; name, <a href="./ListOfTypes.html#size_t">size_t</a>&amp; start)</span><br />
<div class="funccomm"><pre>
 * <a href="./Reflex__Tools.html#Reflex__Tools:GetBasePosition" title="size_t Reflex::Tools::GetBasePosition(const string&amp; name)">GetBasePosition</a> will return the position in a
 * string where the unscoped At begins

</pre></div>
</div>
<div class="funcdoc"><span class="funcname">RFLX_API std::string <a class="funcname" name="Reflex__Tools:GetScopeName" href="src/Reflex__Tools.h.html#bmcNwB">GetScopeName</a>(<span class="keyword">const</span> string&amp; name, <span class="keyword">bool</span> startFromLeft = <span class="keyword">false</span>)</span><br />
<div class="funccomm"><pre>
 * Get the At part of a given At/member Name

</pre></div>
</div>
<div class="funcdoc"><span class="funcname">RFLX_API <span class="keyword">bool</span> <a class="funcname" name="Reflex__Tools:IsTemplated" href="src/Reflex__Tools.h.html#w8ZLg">IsTemplated</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span><br />
<div class="funccomm"><pre>
 * Get the BaseAt (unscoped) Name of a At/member Name


 * <a href="./Reflex__Tools.html#Reflex__Tools:IsTemplated" title="bool Reflex::Tools::IsTemplated(const char* name)">IsTemplated</a> returns <a href="./ListOfTypes.html#bool">true</a> if the At (class) is templated
 * @param Name the At Name
 * @return <a href="./ListOfTypes.html#bool">true</a> if At is templated

</pre></div>
</div>
<div class="funcdoc"><span class="funcname">RFLX_API std::string <a class="funcname" name="Reflex__Tools:GetTemplateArguments" href="src/Reflex__Tools.h.html#nxZ0XC">GetTemplateArguments</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span><br />
<div class="funccomm"><pre>
 * templateArguments returns a string containing the template arguments
 * of a templated At (including outer angular brackets)
 * @param Name the Name of the templated At
 * @return template arguments of the templated At

</pre></div>
</div>
<div class="funcdoc"><span class="funcname">RFLX_API std::string <a class="funcname" name="Reflex__Tools:GetTemplateName" href="src/Reflex__Tools.h.html#CThF6E">GetTemplateName</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span><br />
<div class="funccomm"><pre>
 * <a href="./Reflex__Tools.html#Reflex__Tools:GetTemplateName" title="string Reflex::Tools::GetTemplateName(const char* name)">GetTemplateName</a> returns the Name of the template At (without arguments)
 * @param Name the Name of the template At
 * @return template Name

</pre></div>
</div>
<div class="funcdoc"><span class="funcname">RFLX_API std::string <a class="funcname" name="Reflex__Tools:NormalizeName" href="src/Reflex__Tools.h.html#od1PDB">NormalizeName</a>(<span class="keyword">const</span> std::string&amp; name)</span><br />
</div>
<div class="funcdoc"><span class="funcname">RFLX_API std::string <a class="funcname" name="Reflex__Tools:NormalizeName%1" href="src/Reflex__Tools.h.html#U3joiE">NormalizeName</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span><br />
</div>

<br />
<!--SIGNATURE-->
<div id="footer">

<em>&raquo; Last changed: root/reflex:$Id: Tools.h 32228 2010-02-05 16:13:09Z axel $ </em><em>&raquo; Last generated: 2011-11-03 20:06</em><br />
<em>This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>.</em>
</div>
</div>
</body>
</html>
