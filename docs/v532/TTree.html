<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!--                                             -->
<!-- Author: ROOT team (rootdev@pcroot.cern.ch)  -->
<!--                                             -->
<!--   Date: Thu Nov  3 20:23:49 2011            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<title>TTree</title>
<meta name="rating" content="General" />
<meta name="objecttype" content="Manual" />
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers, cern" />
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis." />
<link rel="stylesheet" type="text/css" href="ROOT.css" id="ROOTstyle" />
<script type="text/javascript" src="ROOT.js"></script>
</head>
<body  onload="javascript:SetValuesFromCookie();"><div id="body_content">
<div id="root_header"><img src="http://root.cern.ch/drupal/sites/default/files/rootdrawing-logo.png" alt="ROOT logo"/></div>
<a name="TopOfPage"></a>
<script type="text/javascript">WriteFollowPageBox('class TTree','libTree','TTree.h');</script>
<div id="toplinks">
<div class="descrhead"><div class="descrheadcontent">
<span class="descrtitle">Quick Links:</span>
<a class="descrheadentry" href="http://root.cern.ch">ROOT Homepage</a>
<a class="descrheadentry" href="./ClassIndex.html">Class Index</a>
<a class="descrheadentry" href="./ClassHierarchy.html">Class Hierarchy</a></div>
<script type="text/javascript">
function onSearch() {
var s='http://www.google.com/search?q=%s+site%3A%u+-site%3A%u%2Fsrc%2F+-site%3A%u%2Fexamples%2F';
var ref=String(document.location.href).replace(/https?:\/\//,'').replace(/\/[^\/]*$/,'').replace(/\//g,'%2F');
window.location.href=s.replace(/%u/ig,ref).replace(/%s/ig,escape(document.searchform.t.value));
return false;}
</script>
<form id="searchform" name="searchform" onsubmit="return onSearch()" action="javascript:onSearch();" method="post">
<input name="t" size="30" value="Search documentation..." onfocus="if (document.searchform.t.value=='Search documentation...') document.searchform.t.value='';"></input>
<a id="searchlink"  title="www.google.com"  href="javascript:onSearch();" onclick="return onSearch()">Search</a></form>
</div>
<div class="descrhead"><div class="descrheadcontent">
<span class="descrtitle">Source:</span>
<a class="descrheadentry" href="src/TTree.h.html">header file</a>
<a class="descrheadentry" href="src/TTree.cxx.html">source file</a>
<a class="descrheadentry" href="http://root.cern.ch/viewcvs/trunk/tree/tree/inc/TTree.h?view=log">viewVC header</a> <a class="descrheadentry" href="http://root.cern.ch/viewcvs/trunk/tree/tree/src/TTree.cxx?view=log">viewVC source</a> 
</div></div>
<div class="descrhead"><div class="descrheadcontent">
<span class="descrtitle">Sections:</span>
<a class="descrheadentry" href="#TTree:description">class description</a> 
<a class="descrheadentry" href="#TTree:Function_Members">function members</a>
<a class="descrheadentry" href="#TTree:Data_Members">data members</a>
<a class="descrheadentry" href="#TTree:Class_Charts">class charts</a>
</div></div>
</div>
<div class="location">
<a class="locationlevel" href="index.html">ROOT</a>
 &#187; <a class="locationlevel" href="./TREE_Index.html">TREE</a>
 &#187; <a class="locationlevel" href="./TREE_TREE_Index.html">TREE</a>
 &#187; <a class="locationlevel" href="#TopOfPage">TTree</a>
</div>
<div class="dropshadow"><div class="withshadow"><h1><a name="TTree:description"></a>class TTree: public <a href="./TNamed.html">TNamed</a>, public <a href="./TAttLine.html">TAttLine</a>, public <a href="./TAttFill.html">TAttFill</a>, public <a href="./TAttMarker.html">TAttMarker</a></h1>
<div class="classdescr">
<pre>

<a href="./TTree.html">TTree</a>

  A <a href="./TTree.html">TTree</a> object has a header with a name and a title.
  It consists of a list of independent branches (<a href="./TBranch.html">TBranch</a>). Each branch
  has its own definition and list of buffers. <a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> buffers may be
  automatically written to disk or kept in memory until the Tree attribute
  <a href="./TTree.html#TTree:fMaxVirtualSize" title="Long64_t TTree::fMaxVirtualSize">fMaxVirtualSize</a> is reached. Variables of one branch are written to the
  same buffer. A branch buffer is automatically compressed if the file
  compression attribute is set (default).

  Branches may be written to different files (see <a href="./TBranch.html">TBranch</a>::<a href="./TBranch.html#TBranch:SetFile" title="void TBranch::SetFile(TFile* file=0) or overloads">SetFile</a>).

  The <a href="./ROOT.html">ROOT</a> user can decide to make one single branch and serialize one
  object into one single I/O buffer or to make several branches.
  Making one single branch and one single buffer can be the right choice
  when one wants to process only a subset of all entries in the tree.
  (you know for example the list of entry numbers you want to process).
  Making several branches is particularly interesting in the data analysis
  phase, when one wants to histogram some attributes of an object (entry)
  without reading all the attributes.

  ==&gt; <a href="./TTree.html">TTree</a> *tree = new <a href="./TTree.html">TTree</a>(name, title)
     Creates a Tree with name and title.

     Various kinds of branches can be added to a tree:
       A - simple structures or list of variables. (may be for C or Fortran structures)
       B - any object (inheriting from <a href="./TObject.html">TObject</a>). (we expect this option be the most frequent)
       C - a ClonesArray. (a specialized object for collections of same class objects)

  ==&gt; Case A

     <a href="./TBranch.html">TBranch</a> *branch = tree-&gt;<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>(branchname, address, leaflist, bufsize)
       * address is the address of the first item of a structure
       * leaflist is the concatenation of all the variable names and types
         separated by a colon character :
         The variable name and the variable type are separated by a
         slash (/). The variable type must be 1 character. (Characters
         after the first are legal and will be appended to the visible
         name of the leaf, but have no effect.) If no type is given, the
         type of the variable is assumed to be the same as the previous
         variable. If the first variable does not have a type, it is
         assumed of type F by default. The list of currently supported
         types is given below:
            - C : a character string terminated by the 0 character
            - B : an 8 bit signed integer (<a href="./ListOfTypes.html#Char_t">Char_t</a>)
            - b : an 8 bit <a href="./ListOfTypes.html#unsigned">unsigned</a> integer (<a href="./ListOfTypes.html#UChar_t">UChar_t</a>)
            - S : a 16 bit signed integer (<a href="./ListOfTypes.html#Short_t">Short_t</a>)
            - s : a 16 bit <a href="./ListOfTypes.html#unsigned">unsigned</a> integer (<a href="./ListOfTypes.html#UShort_t">UShort_t</a>)
            - I : a 32 bit signed integer (<a href="./ListOfTypes.html#Int_t">Int_t</a>)
            - i : a 32 bit <a href="./ListOfTypes.html#unsigned">unsigned</a> integer (<a href="./ListOfTypes.html#UInt_t">UInt_t</a>)
            - F : a 32 bit floating point (<a href="./ListOfTypes.html#Float_t">Float_t</a>)
            - D : a 64 bit floating point (<a href="./ListOfTypes.html#Double_t">Double_t</a>)
            - L : a 64 bit signed integer (<a href="./ListOfTypes.html#Long64_t">Long64_t</a>)
            - l : a 64 bit <a href="./ListOfTypes.html#unsigned">unsigned</a> integer (<a href="./ListOfTypes.html#ULong64_t">ULong64_t</a>)
            - O : [the letter <span class="string">'o'</span>, not a zero] a boolean (<a href="./ListOfTypes.html#Bool_t">Bool_t</a>)
       * If the address points to a single numerical variable, the leaflist is optional:
           <a href="./ListOfTypes.html#int">int</a> value;
           tree-&gt;<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>(branchname, &amp;value);
       * If the address points to more than one numerical variable, we strongly recommend
         that the variable be sorted in decreasing order of size.  Any other order will
         result in a non-portable (even between CINT and compiled code on the platform)
         <a href="./TTree.html">TTree</a> (i.e. you will not be able to read it back on a platform with a different
         padding strategy).

  ==&gt; Case B

     <a href="./TBranch.html">TBranch</a> *branch = tree-&gt;<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>(branchname, &amp;p_object, bufsize, splitlevel)
     <a href="./TBranch.html">TBranch</a> *branch = tree-&gt;<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>(branchname, className, &amp;p_object, bufsize, splitlevel)
       * p_object is a pointer to an object.
       * If className is not specified, <a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> uses the type of p_object to determine the
           type of the object.
       * If className is used to specify explicitly the object type, the className must
           be of a type related to the one pointed to by the pointer.  It should be either
           a parent or derived class.
       * if splitlevel=0, the object is serialized in the branch buffer.
       * if splitlevel=1, this branch will automatically be split
           into subbranches, with one subbranch for each data member or object
           of the object itself. In case the object member is a <a href="./TClonesArray.html">TClonesArray</a>,
           the mechanism described in case C is applied to this array.
       * if splitlevel=2 ,this branch will automatically be split
           into subbranches, with one subbranch for each data member or object
           of the object itself. In case the object member is a <a href="./TClonesArray.html">TClonesArray</a>,
           it is processed as a <a href="./TObject.html">TObject</a>*, only one branch.

       Note: The pointer whose address is passed to <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> must not
             be destroyed (i.e. go out of scope) until the <a href="./TTree.html">TTree</a> is deleted or
             <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:ResetBranchAddress" title="void TTree::ResetBranchAddress(TBranch* )">ResetBranchAddress</a> is called.

       Note: The pointer p_object must be initialized before calling <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>
          Do either:
             MyDataClass* p_object = 0;
             tree-&gt;<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>(branchname, &amp;p_object);
          Or
             MyDataClass* p_object = new MyDataClass;
             tree-&gt;<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>(branchname, &amp;p_object);

  ==&gt; Case C

     MyClass object;
     <a href="./TBranch.html">TBranch</a> *branch = tree-&gt;<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>(branchname, &amp;object, bufsize, splitlevel)

       Note: The 2nd parameter must be the address of a valid object.
              The object must not be destroyed (i.e. be deleted) until the <a href="./TTree.html">TTree</a>
               is deleted or <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:ResetBranchAddress" title="void TTree::ResetBranchAddress(TBranch* )">ResetBranchAddress</a> is called.

       * if splitlevel=0, the object is serialized in the branch buffer.
       * if splitlevel=1 (default), this branch will automatically be split
           into subbranches, with one subbranch for each data member or object
           of the object itself. In case the object member is a <a href="./TClonesArray.html">TClonesArray</a>,
           the mechanism described in case C is applied to this array.
       * if splitlevel=2 ,this branch will automatically be split
           into subbranches, with one subbranch for each data member or object
           of the object itself. In case the object member is a <a href="./TClonesArray.html">TClonesArray</a>,
           it is processed as a <a href="./TObject.html">TObject</a>*, only one branch.

  ==&gt; Case D

     <a href="./TBranch.html">TBranch</a> *branch = tree-&gt;<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>(branchname,clonesarray, bufsize, splitlevel)
         clonesarray is the address of a pointer to a <a href="./TClonesArray.html">TClonesArray</a>.
         The <a href="./TClonesArray.html">TClonesArray</a> is a direct access list of objects of the same class.
         For example, if the <a href="./TClonesArray.html">TClonesArray</a> is an array of TTrack objects,
         this function will create one subbranch for each data member of
         the object TTrack.

  ==&gt; Case E

     <a href="./TBranch.html">TBranch</a> *branch = tree-&gt;<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>( branchname, STLcollection, buffsize, splitlevel);
         STLcollection is the address of a pointer to std::vector, std::list,
         std::deque, std::set or std::multiset containing pointers to objects.
         If the splitlevel is a value bigger than 100 (<a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:kSplitCollectionOfPointers" title="const enum TTree:: TTree::kSplitCollectionOfPointers">kSplitCollectionOfPointers</a>)
         then the collection will be written in split mode, e.g. if it contains objects of
         any types deriving from TTrack this function will sort the objects
         based on their type and store them in separate branches in split
         mode.

  ==&gt; branch-&gt;SetAddress(Void *address)
      In case of dynamic structures changing with each entry for example, one must
      redefine the branch address before filling the branch again.
      This is done via the <a href="./TBranch.html">TBranch</a>::<a href="./TBranch.html#TBranch:SetAddress" title="void TBranch::SetAddress(void* add)">SetAddress</a> member function.

  ==&gt; tree-&gt;<a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a>()
      loops on all defined branches and for each branch invokes the <a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a> function.

         See also the class <a href="./TNtuple.html">TNtuple</a> (a simple Tree with branches of floats)

       Adding a <a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> to an Existing Tree

 You may want to add a branch to an existing tree. For example,
 if one variable in the tree was computed with a certain algorithm,
 you may want to try another algorithm and compare the results.
 One solution is to add a new branch, fill it, and save the tree.
 The code below adds a simple branch to an existing tree.
 Note the kOverwrite option in the <a href="./TTree.html#TTree:Write" title="Int_t TTree::Write(const char* name=0,Int_t option=0,Int_t bufsize=0) or overloads">Write</a> method, it overwrites the
 existing tree. If it is not specified, two copies of the tree headers
 are saved.

 <a href="./ListOfTypes.html#void">void</a> tree3AddBranch(){
   <a href="./TFile.html">TFile</a> f(<span class="string">"tree3.root"</span>, <span class="string">"update"</span>);

   <a href="./ListOfTypes.html#Float_t">Float_t</a> new_v;
   <a href="./TTree.html">TTree</a> *t3 = (<a href="./TTree.html">TTree</a>*)f-&gt;Get(<span class="string">"t3"</span>);
   <a href="./TBranch.html">TBranch</a> *newBranch = t3-&gt;<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>(<span class="string">"new_v"</span>, &amp;new_v, <span class="string">"new_v/F"</span>);

   //read the number of entries in the t3
   <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = t3-&gt;<a href="./TTree.html#TTree:GetEntries" title="Long64_t TTree::GetEntries() or overloads">GetEntries</a>();

   for (<a href="./ListOfTypes.html#Long64_t">Long64_t</a> i = 0; i &lt; nentries; i++){
     new_v= <a href="./TRandom.html">gRandom</a>-><a href="./TRandom.html#TRandom:Gaus" title="Double_t TRandom::Gaus(Double_t mean=0,Double_t sigma=1)">Gaus</a>(0, 1);
     newBranch-&gt;<a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a>();
   }
   // save only the new version of the tree
   t3-&gt;<a href="./TTree.html#TTree:Write" title="Int_t TTree::Write(const char* name=0,Int_t option=0,Int_t bufsize=0) or overloads">Write</a>(<span class="string">""</span>, <a href="./TObject.html">TObject</a>::<a href="./TObject.html#TObject:kOverwrite" title="const enum TObject:: TObject::kOverwrite">kOverwrite</a>);
 }
 Adding a branch is often not possible because the tree is in a read-only
 file and you do not have permission to save the modified tree with the
 new branch. Even if you do have the permission, you risk losing the
 original tree with an unsuccessful attempt to save  the modification.
 Since trees are usually large, adding a branch could extend it over the
 2GB limit. In this case, the attempt to write the tree fails, and the
 original data is erased.
 In addition, adding a branch to a tree enlarges the tree and increases
 the amount of memory needed to read an entry, and therefore decreases
 the performance.

 For these reasons, <a href="./ROOT.html">ROOT</a> offers the concept of friends for trees (and chains).
 We encourage you to use <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:AddFriend" title="TFriendElement* TTree::AddFriend(const char* treename,const char* filename=&quot;&quot;) or overloads">AddFriend</a> rather than adding a branch manually.


</pre><!-- TDocHtmlDirective start -->/*
<img src="gif/tree_layout.gif">
*/
<!-- TDocHtmlDirective end --><pre>


A simple example with histograms and a tree*-*-*-
*-*          ===========================================

  This program creates :
    - a one dimensional histogram
    - a two dimensional histogram
    - a profile histogram
    - a tree

  These objects are filled with some random numbers and saved on a file.

-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

 #include <span class="string">"TFile.h"</span>
 #include <span class="string">"TH1.h"</span>
 #include <span class="string">"TH2.h"</span>
 #include <span class="string">"TProfile.h"</span>
 #include <span class="string">"TRandom.h"</span>
 #include <span class="string">"TTree.h"</span>


 //______________________________________________________________________________
 main(<a href="./ListOfTypes.html#int">int</a> argc, <a href="./ListOfTypes.html#char">char</a> **argv)
 {
 // Create a new <a href="./ROOT.html">ROOT</a> binary machine independent file.
 // Note that this file may contain any kind of <a href="./ROOT.html">ROOT</a> objects, histograms,trees
 // pictures, graphics objects, detector geometries, tracks, events, etc..
 // This file is now becoming the current directory.
   <a href="./TFile.html">TFile</a> hfile(<span class="string">"htree.root"</span>,<span class="string">"RECREATE"</span>,<span class="string">"Demo ROOT file with histograms &amp; trees"</span>);

 // Create some histograms and a profile histogram
   <a href="./TH1F.html">TH1F</a> *hpx   = new <a href="./TH1F.html">TH1F</a>(<span class="string">"hpx"</span>,<span class="string">"This is the px distribution"</span>,100,-4,4);
   <a href="./TH2F.html">TH2F</a> *hpxpy = new <a href="./TH2F.html">TH2F</a>(<span class="string">"hpxpy"</span>,<span class="string">"py ps px"</span>,40,-4,4,40,-4,4);
   <a href="./TProfile.html">TProfile</a> *hprof = new <a href="./TProfile.html">TProfile</a>(<span class="string">"hprof"</span>,<span class="string">"Profile of pz versus px"</span>,100,-4,4,0,20);

 // Define some simple structures
   typedef struct {<a href="./ListOfTypes.html#Float_t">Float_t</a> x,y,z;} POINT;
   typedef struct {
      <a href="./ListOfTypes.html#Int_t">Int_t</a> ntrack,nseg,nvertex;
      <a href="./ListOfTypes.html#UInt_t">UInt_t</a> flag;
      <a href="./ListOfTypes.html#Float_t">Float_t</a> temperature;
   } EVENTN;
   static POINT point;
   static EVENTN eventn;

 // Create a <a href="./ROOT.html">ROOT</a> Tree
   <a href="./TTree.html">TTree</a> *tree = new <a href="./TTree.html">TTree</a>(<span class="string">"T"</span>,<span class="string">"An example of ROOT tree with a few branches"</span>);
   tree-&gt;<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>(<span class="string">"point"</span>,&amp;point,<span class="string">"x:y:z"</span>);
   tree-&gt;<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>(<span class="string">"eventn"</span>,&amp;eventn,<span class="string">"ntrack/I:nseg:nvertex:flag/i:temperature/F"</span>);
   tree-&gt;<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>(<span class="string">"hpx"</span>,<span class="string">"TH1F"</span>,&amp;hpx,128000,0);

   <a href="./ListOfTypes.html#Float_t">Float_t</a> px,py,pz;
   static <a href="./ListOfTypes.html#Float_t">Float_t</a> p[3];

 //--------------------Here we start a loop on 1000 events
   for ( <a href="./ListOfTypes.html#Int_t">Int_t</a> i=0; i&lt;1000; i++) {
      <a href="./TRandom.html">gRandom</a>-><a href="./TRandom.html#TRandom:Rannor" title="void TRandom::Rannor(Float_t&amp; a,Float_t&amp; b) or overloads">Rannor</a>(px,py);
      pz = px*px + py*py;
      <a href="./ListOfTypes.html#Float_t">Float_t</a> random = <a href="./TRandom.html">gRandom</a>->::<a href="./TRandom.html#TRandom:Rndm" title="Double_t TRandom::Rndm(Int_t i=0)">Rndm</a>(1);

 //         <a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a> histograms
      hpx-&gt;<a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a>(px);
      hpxpy-&gt;<a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a>(px,py,1);
      hprof-&gt;<a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a>(px,pz,1);

 //         <a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a> structures
      p[0] = px;
      p[1] = py;
      p[2] = pz;
      point.x = 10*(random-1);;
      point.y = 5*random;
      point.z = 20*random;
      eventn.ntrack  = <a href="./ListOfTypes.html#Int_t">Int_t</a>(100*random);
      eventn.nseg    = <a href="./ListOfTypes.html#Int_t">Int_t</a>(2*eventn.ntrack);
      eventn.nvertex = 1;
      eventn.flag    = <a href="./ListOfTypes.html#Int_t">Int_t</a>(random+0.5);
      eventn.temperature = 20+random;

 //        <a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a> the tree. For each event, save the 2 structures and 3 objects
 //      In this simple example, the objects hpx, hprof and hpxpy are slightly
 //      different from event to event. We expect a big compression factor!
      tree-&gt;<a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a>();
   }
  //--------------End of the loop

   tree-&gt;<a href="./TTree.html#TTree:Print" title="void TTree::Print(Option_t* option=&quot;&quot;)">Print</a>();

 // Save all objects in this file
   hfile.<a href="./TTree.html#TTree:Write" title="Int_t TTree::Write(const char* name=0,Int_t option=0,Int_t bufsize=0) or overloads">Write</a>();

 // Close the file. Note that this is automatically done when you leave
 // the application.
   hfile.Close();

   return 0;
 }


</pre></div>
</div></div>

<div id="functions">
<h2><a id="TTree:Function_Members"></a>Function Members (Methods)</h2>
<div class="access" id="funcpubl"><b>public:</b>
<table class="func" id="tabfuncpubl" cellspacing="0">
<tr class="func"><td class="funcret"></td><td class="funcname"><a class="funcname" href="#TTree:TTree%1">TTree</a>()</td></tr>
<tr class="func"><td class="funcret"></td><td class="funcname"><a class="funcname" href="#TTree:TTree%2">TTree</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* title, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel = 99)</td></tr>
<tr class="func"><td class="funcret"> virtual</td><td class="funcname"><a class="funcname" href="#TTree:_TTree">~TTree</a>()</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:AbstractMethod"><span class="baseclass">TObject::</span>AbstractMethod</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:AddBranchToCache">AddBranchToCache</a>(<span class="keyword">const</span> <span class="keyword">char</span>* bname, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> subbranches = <a href="./ListOfTypes.html#Bool_t">kFALSE</a>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:AddBranchToCache%1">AddBranchToCache</a>(<a href="./TBranch.html">TBranch</a>* branch, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> subbranches = <a href="./ListOfTypes.html#Bool_t">kFALSE</a>)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TFriendElement.html">TFriendElement</a>*</td><td class="funcname"><a class="funcname" href="#TTree:AddFriend">AddFriend</a>(<span class="keyword">const</span> <span class="keyword">char</span>* treename, <span class="keyword">const</span> <span class="keyword">char</span>* filename = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TFriendElement.html">TFriendElement</a>*</td><td class="funcname"><a class="funcname" href="#TTree:AddFriend%1">AddFriend</a>(<span class="keyword">const</span> <span class="keyword">char</span>* treename, <a href="./TFile.html">TFile</a>* file)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TFriendElement.html">TFriendElement</a>*</td><td class="funcname"><a class="funcname" href="#TTree:AddFriend%2">AddFriend</a>(<a href="./TTree.html">TTree</a>* tree, <span class="keyword">const</span> <span class="keyword">char</span>* alias = <span class="string">""</span>, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> warn = <a href="./ListOfTypes.html#Bool_t">kFALSE</a>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:AddTotBytes">AddTotBytes</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> tot)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:AddZipBytes">AddZipBytes</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> zip)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:AppendPad"><span class="baseclass">TObject::</span>AppendPad</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:AutoSave">AutoSave</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:Branch%1">Branch</a>(<a href="./TList.html">TList</a>* list, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel = 99)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:Branch%2">Branch</a>(<span class="keyword">const</span> <span class="keyword">char</span>* folder, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel = 99)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:Branch">Branch</a>(<a href="./TCollection.html">TCollection</a>* list, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel = 99, <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TBranch.html">TBranch</a>*</td><td class="funcname"><a class="funcname" href="#TTree:Branch%3">Branch</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">void</span>* address, <span class="keyword">const</span> <span class="keyword">char</span>* leaflist, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000)</td></tr>
<tr class="func"><td class="funcret"><a href="./TBranch.html">TBranch</a>*</td><td class="funcname"><a class="funcname" href="#TTree:Branch%4">Branch</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">char</span>* address, <span class="keyword">const</span> <span class="keyword">char</span>* leaflist, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000)</td></tr>
<tr class="func"><td class="funcret"><a href="./TBranch.html">TBranch</a>*</td><td class="funcname"><a class="funcname" href="#TTree:Branch%5">Branch</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">long</span> address, <span class="keyword">const</span> <span class="keyword">char</span>* leaflist, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000)</td></tr>
<tr class="func"><td class="funcret"><a href="./TBranch.html">TBranch</a>*</td><td class="funcname"><a class="funcname" href="#TTree:Branch%6">Branch</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> address, <span class="keyword">const</span> <span class="keyword">char</span>* leaflist, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000)</td></tr>
<tr class="func"><td class="funcret"><a href="./TBranch.html">TBranch</a>*</td><td class="funcname"><a class="funcname" href="#TTree:Branch%8">Branch</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">void</span>** obj, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel = 99)</td></tr>
<tr class="func"><td class="funcret"><a href="./TBranch.html">TBranch</a>*</td><td class="funcname"><a class="funcname" href="#TTree:Branch%7">Branch</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* classname, <span class="keyword">void</span>** obj, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel = 99)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TBranch.html">TBranch</a>*</td><td class="funcname"><a class="funcname" href="#TTree:BranchOld">BranchOld</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* classname, <span class="keyword">void</span>* addobj, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel = 1)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TBranch.html">TBranch</a>*</td><td class="funcname"><a class="funcname" href="#TTree:BranchRef">BranchRef</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TBranch.html">TBranch</a>*</td><td class="funcname"><a class="funcname" href="#TTree:Bronch">Bronch</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* classname, <span class="keyword">void</span>* addobj, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel = 99)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:Browse">Browse</a>(<a href="./TBrowser.html">TBrowser</a>*)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:BuildIndex">BuildIndex</a>(<span class="keyword">const</span> <span class="keyword">char</span>* majorname, <span class="keyword">const</span> <span class="keyword">char</span>* minorname = <span class="string">"0"</span>)</td></tr>
<tr class="func"><td class="funcret"><a href="./TStreamerInfo.html">TStreamerInfo</a>*</td><td class="funcname"><a class="funcname" href="#TTree:BuildStreamerInfo">BuildStreamerInfo</a>(<a href="./TClass.html">TClass</a>* cl, <span class="keyword">void</span>* pointer = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> canOptimize = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TFile.html">TFile</a>*</td><td class="funcname"><a class="funcname" href="#TTree:ChangeFile">ChangeFile</a>(<a href="./TFile.html">TFile</a>* file)</td></tr>
<tr class="func"><td class="funcret">static <a href="./TClass.html">TClass</a>*</td><td class="funcname"><a class="funcname" href="#TTree:Class">Class</a>()</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">const</span> <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:ClassName"><span class="baseclass">TObject::</span>ClassName</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:Clear"><span class="baseclass">TNamed::</span>Clear</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./TObject.html">TObject</a>*</td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:Clone"><span class="baseclass">TNamed::</span>Clone</a>(<span class="keyword">const</span> <span class="keyword">char</span>* newname = <span class="string">""</span>) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TTree.html">TTree</a>*</td><td class="funcname"><a class="funcname" href="#TTree:CloneTree">CloneTree</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = -1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:Compare"><span class="baseclass">TNamed::</span>Compare</a>(<span class="keyword">const</span> <a href="./TObject.html">TObject</a>* obj) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:Copy"><span class="baseclass">TNamed::</span>Copy</a>(<a href="./TObject.html">TObject</a>&amp; named) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:CopyAddresses">CopyAddresses</a>(<a href="./TTree.html">TTree</a>*, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> undo = <a href="./ListOfTypes.html#Bool_t">kFALSE</a>)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:CopyEntries">CopyEntries</a>(<a href="./TTree.html">TTree</a>* tree, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = -1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TTree.html">TTree</a>*</td><td class="funcname"><a class="funcname" href="#TTree:CopyTree">CopyTree</a>(<span class="keyword">const</span> <span class="keyword">char</span>* selection, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TBasket.html">TBasket</a>*</td><td class="funcname"><a class="funcname" href="#TTree:CreateBasket">CreateBasket</a>(<a href="./TBranch.html">TBranch</a>*)</td></tr>
<tr class="func"><td class="funcret"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:Debug">Debug</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:Delete">Delete</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:DirectoryAutoAdd">DirectoryAutoAdd</a>(<a href="./TDirectory.html">TDirectory</a>*)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:DistancetoLine"><span class="baseclass">TAttLine::</span>DistancetoLine</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> px, <a href="./ListOfTypes.html#Int_t">Int_t</a> py, <a href="./ListOfTypes.html#Double_t">Double_t</a> xp1, <a href="./ListOfTypes.html#Double_t">Double_t</a> yp1, <a href="./ListOfTypes.html#Double_t">Double_t</a> xp2, <a href="./ListOfTypes.html#Double_t">Double_t</a> yp2)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:DistancetoPrimitive"><span class="baseclass">TObject::</span>DistancetoPrimitive</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> px, <a href="./ListOfTypes.html#Int_t">Int_t</a> py)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:Draw">Draw</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* opt)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:Draw%1">Draw</a>(<span class="keyword">const</span> <span class="keyword">char</span>* varexp, <span class="keyword">const</span> <a href="./TCut.html">TCut</a>&amp; selection, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:Draw%2">Draw</a>(<span class="keyword">const</span> <span class="keyword">char</span>* varexp, <span class="keyword">const</span> <span class="keyword">char</span>* selection, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:DrawClass"><span class="baseclass">TObject::</span>DrawClass</a>() <span class="keyword">const</span><span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./TObject.html">TObject</a>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:DrawClone"><span class="baseclass">TObject::</span>DrawClone</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) <span class="keyword">const</span><span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:DropBaskets">DropBaskets</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:DropBranchFromCache">DropBranchFromCache</a>(<span class="keyword">const</span> <span class="keyword">char</span>* bname, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> subbranches = <a href="./ListOfTypes.html#Bool_t">kFALSE</a>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:DropBranchFromCache%1">DropBranchFromCache</a>(<a href="./TBranch.html">TBranch</a>* branch, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> subbranches = <a href="./ListOfTypes.html#Bool_t">kFALSE</a>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:DropBuffers">DropBuffers</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nbytes)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Dump"><span class="baseclass">TObject::</span>Dump</a>() <span class="keyword">const</span><span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Error"><span class="baseclass">TObject::</span>Error</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* msgfmt) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Execute"><span class="baseclass">TObject::</span>Execute</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* params, <a href="./ListOfTypes.html#Int_t">Int_t</a>* error = 0)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Execute%1"><span class="baseclass">TObject::</span>Execute</a>(<a href="./TMethod.html">TMethod</a>* method, <a href="./TObjArray.html">TObjArray</a>* params, <a href="./ListOfTypes.html#Int_t">Int_t</a>* error = 0)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:ExecuteEvent"><span class="baseclass">TObject::</span>ExecuteEvent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> event, <a href="./ListOfTypes.html#Int_t">Int_t</a> px, <a href="./ListOfTypes.html#Int_t">Int_t</a> py)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Fatal"><span class="baseclass">TObject::</span>Fatal</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* msgfmt) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:Fill">Fill</a>()</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:FillBuffer"><span class="baseclass">TNamed::</span>FillBuffer</a>(<span class="keyword">char</span>*&amp; buffer)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TBranch.html">TBranch</a>*</td><td class="funcname"><a class="funcname" href="#TTree:FindBranch">FindBranch</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TLeaf.html">TLeaf</a>*</td><td class="funcname"><a class="funcname" href="#TTree:FindLeaf">FindLeaf</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./TObject.html">TObject</a>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:FindObject"><span class="baseclass">TObject::</span>FindObject</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./TObject.html">TObject</a>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:FindObject%1"><span class="baseclass">TObject::</span>FindObject</a>(<span class="keyword">const</span> <a href="./TObject.html">TObject</a>* obj) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:Fit">Fit</a>(<span class="keyword">const</span> <span class="keyword">char</span>* funcname, <span class="keyword">const</span> <span class="keyword">char</span>* varexp, <span class="keyword">const</span> <span class="keyword">char</span>* selection = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* goption = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:FlushBaskets">FlushBaskets</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">const</span> <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="#TTree:GetAlias">GetAlias</a>(<span class="keyword">const</span> <span class="keyword">char</span>* aliasName) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetAutoFlush">GetAutoFlush</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetAutoSave">GetAutoSave</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TBranch.html">TBranch</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetBranch">GetBranch</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TBranchRef.html">TBranchRef</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetBranchRef">GetBranchRef</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetBranchStatus">GetBranchStatus</a>(<span class="keyword">const</span> <span class="keyword">char</span>* branchname) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">static <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetBranchStyle">GetBranchStyle</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetCacheSize">GetCacheSize</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetChainEntryNumber">GetChainEntryNumber</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> entry) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetChainOffset">GetChainOffset</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TTree.html">TTree</a>::TClusterIterator</td><td class="funcname"><a class="funcname" href="#TTree:GetClusterIterator">GetClusterIterator</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry)</td></tr>
<tr class="func"><td class="funcret"><a href="./TFile.html">TFile</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetCurrentFile">GetCurrentFile</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetDebugMax">GetDebugMax</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetDebugMin">GetDebugMin</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetDefaultEntryOffsetLen">GetDefaultEntryOffsetLen</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./TDirectory.html">TDirectory</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetDirectory">GetDirectory</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Option_t">Option_t</a>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:GetDrawOption"><span class="baseclass">TObject::</span>GetDrawOption</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">static <a href="./ListOfTypes.html#Long_t">Long_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:GetDtorOnly"><span class="baseclass">TObject::</span>GetDtorOnly</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetEntries">GetEntries</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetEntries%1">GetEntries</a>(<span class="keyword">const</span> <span class="keyword">char</span>* selection)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetEntriesFast">GetEntriesFast</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetEntriesFriend">GetEntriesFriend</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetEntry">GetEntry</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> entry = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> getall = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TEntryList.html">TEntryList</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetEntryList">GetEntryList</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetEntryNumber">GetEntryNumber</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> entry) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetEntryNumberWithBestIndex">GetEntryNumberWithBestIndex</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> major, <a href="./ListOfTypes.html#Int_t">Int_t</a> minor = 0) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetEntryNumberWithIndex">GetEntryNumberWithIndex</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> major, <a href="./ListOfTypes.html#Int_t">Int_t</a> minor = 0) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetEntryWithIndex">GetEntryWithIndex</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> major, <a href="./ListOfTypes.html#Int_t">Int_t</a> minor = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetEstimate">GetEstimate</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetEvent">GetEvent</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> entry = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> getall = 0)</td></tr>
<tr class="func"><td class="funcret"><a href="./TEventList.html">TEventList</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetEventList">GetEventList</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetFileNumber">GetFileNumber</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Color_t">Color_t</a></td><td class="funcname"><a class="funcname" href="./TAttFill.html#TAttFill:GetFillColor"><span class="baseclass">TAttFill::</span>GetFillColor</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Style_t">Style_t</a></td><td class="funcname"><a class="funcname" href="./TAttFill.html#TAttFill:GetFillStyle"><span class="baseclass">TAttFill::</span>GetFillStyle</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TTree.html">TTree</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetFriend">GetFriend</a>(<span class="keyword">const</span> <span class="keyword">char</span>*) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">const</span> <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="#TTree:GetFriendAlias">GetFriendAlias</a>(<a href="./TTree.html">TTree</a>*) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./TH1.html">TH1</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetHistogram">GetHistogram</a>()</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">const</span> <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:GetIconName"><span class="baseclass">TObject::</span>GetIconName</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetIndex">GetIndex</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetIndexValues">GetIndexValues</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TIterator.html">TIterator</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetIteratorOnAllLeaves">GetIteratorOnAllLeaves</a>(<a href="./ListOfTypes.html#Bool_t">Bool_t</a> <a href="./TString.html">dir</a> = <a href="./ListOfTypes.html#Bool_t">kIterForward</a>)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TLeaf.html">TLeaf</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetLeaf%1">GetLeaf</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TLeaf.html">TLeaf</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetLeaf">GetLeaf</a>(<span class="keyword">const</span> <span class="keyword">char</span>* branchname, <span class="keyword">const</span> <span class="keyword">char</span>* leafname)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Color_t">Color_t</a></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:GetLineColor"><span class="baseclass">TAttLine::</span>GetLineColor</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Style_t">Style_t</a></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:GetLineStyle"><span class="baseclass">TAttLine::</span>GetLineStyle</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Width_t">Width_t</a></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:GetLineWidth"><span class="baseclass">TAttLine::</span>GetLineWidth</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TList.html">TList</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetListOfAliases">GetListOfAliases</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TObjArray.html">TObjArray</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetListOfBranches">GetListOfBranches</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TList.html">TList</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetListOfClones">GetListOfClones</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TList.html">TList</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetListOfFriends">GetListOfFriends</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TObjArray.html">TObjArray</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetListOfLeaves">GetListOfLeaves</a>()</td></tr>
<tr class="func"><td class="funcret"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetMakeClass">GetMakeClass</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Color_t">Color_t</a></td><td class="funcname"><a class="funcname" href="./TAttMarker.html#TAttMarker:GetMarkerColor"><span class="baseclass">TAttMarker::</span>GetMarkerColor</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Size_t">Size_t</a></td><td class="funcname"><a class="funcname" href="./TAttMarker.html#TAttMarker:GetMarkerSize"><span class="baseclass">TAttMarker::</span>GetMarkerSize</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Style_t">Style_t</a></td><td class="funcname"><a class="funcname" href="./TAttMarker.html#TAttMarker:GetMarkerStyle"><span class="baseclass">TAttMarker::</span>GetMarkerStyle</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetMaxEntryLoop">GetMaxEntryLoop</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetMaximum">GetMaximum</a>(<span class="keyword">const</span> <span class="keyword">char</span>* columname)</td></tr>
<tr class="func"><td class="funcret">static <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetMaxTreeSize">GetMaxTreeSize</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetMaxVirtualSize">GetMaxVirtualSize</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetMinimum">GetMinimum</a>(<span class="keyword">const</span> <span class="keyword">char</span>* columname)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">const</span> <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:GetName"><span class="baseclass">TNamed::</span>GetName</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetNbranches">GetNbranches</a>()</td></tr>
<tr class="func"><td class="funcret"><a href="./TObject.html">TObject</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetNotify">GetNotify</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:GetObjectInfo"><span class="baseclass">TObject::</span>GetObjectInfo</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> px, <a href="./ListOfTypes.html#Int_t">Int_t</a> py) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">static <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:GetObjectStat"><span class="baseclass">TObject::</span>GetObjectStat</a>()</td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Option_t">Option_t</a>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:GetOption"><span class="baseclass">TObject::</span>GetOption</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetPacketSize">GetPacketSize</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./TVirtualTreePlayer.html">TVirtualTreePlayer</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetPlayer">GetPlayer</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetReadEntry">GetReadEntry</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetReadEvent">GetReadEvent</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetScanField">GetScanField</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./TTreeFormula.html">TTreeFormula</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetSelect">GetSelect</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetSelectedRows">GetSelectedRows</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetTimerInterval">GetTimerInterval</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">const</span> <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:GetTitle"><span class="baseclass">TNamed::</span>GetTitle</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetTotBytes">GetTotBytes</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./TBuffer.html">TBuffer</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetTransientBuffer">GetTransientBuffer</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> size)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TTree.html">TTree</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetTree">GetTree</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TVirtualIndex.html">TVirtualIndex</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetTreeIndex">GetTreeIndex</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetTreeNumber">GetTreeNumber</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#UInt_t">UInt_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:GetUniqueID"><span class="baseclass">TObject::</span>GetUniqueID</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetUpdate">GetUpdate</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TList.html">TList</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetUserInfo">GetUserInfo</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetV1">GetV1</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetV2">GetV2</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetV3">GetV3</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetV4">GetV4</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetVal">GetVal</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> i)</td></tr>
<tr class="func"><td class="funcret"><a href="./TTreeFormula.html">TTreeFormula</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetVar">GetVar</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> i)</td></tr>
<tr class="func"><td class="funcret"><a href="./TTreeFormula.html">TTreeFormula</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetVar1">GetVar1</a>()</td></tr>
<tr class="func"><td class="funcret"><a href="./TTreeFormula.html">TTreeFormula</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetVar2">GetVar2</a>()</td></tr>
<tr class="func"><td class="funcret"><a href="./TTreeFormula.html">TTreeFormula</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetVar3">GetVar3</a>()</td></tr>
<tr class="func"><td class="funcret"><a href="./TTreeFormula.html">TTreeFormula</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetVar4">GetVar4</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetW">GetW</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetWeight">GetWeight</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:GetZipBytes">GetZipBytes</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:HandleTimer"><span class="baseclass">TObject::</span>HandleTimer</a>(<a href="./TTimer.html">TTimer</a>* timer)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#ULong_t">ULong_t</a></td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:Hash"><span class="baseclass">TNamed::</span>Hash</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:IncrementTotalBuffers">IncrementTotalBuffers</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nbytes)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Info"><span class="baseclass">TObject::</span>Info</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* msgfmt) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:InheritsFrom"><span class="baseclass">TObject::</span>InheritsFrom</a>(<span class="keyword">const</span> <span class="keyword">char</span>* classname) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:InheritsFrom%1"><span class="baseclass">TObject::</span>InheritsFrom</a>(<span class="keyword">const</span> <a href="./TClass.html">TClass</a>* cl) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Inspect"><span class="baseclass">TObject::</span>Inspect</a>() <span class="keyword">const</span><span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:InvertBit"><span class="baseclass">TObject::</span>InvertBit</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> f)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TClass.html">TClass</a>*</td><td class="funcname"><a class="funcname" href="#TTree:IsA">IsA</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:IsEqual"><span class="baseclass">TObject::</span>IsEqual</a>(<span class="keyword">const</span> <a href="./TObject.html">TObject</a>* obj) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TTree:IsFolder">IsFolder</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:IsOnHeap"><span class="baseclass">TObject::</span>IsOnHeap</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:IsSortable"><span class="baseclass">TNamed::</span>IsSortable</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TAttFill.html#TAttFill:IsTransparent"><span class="baseclass">TAttFill::</span>IsTransparent</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:IsZombie"><span class="baseclass">TObject::</span>IsZombie</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:LoadBaskets">LoadBaskets</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> maxmemory = 2000000000)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:LoadTree">LoadTree</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> entry)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:LoadTreeFriend">LoadTreeFriend</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> entry, <a href="./TTree.html">TTree</a>* T)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:ls"><span class="baseclass">TNamed::</span>ls</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:MakeClass">MakeClass</a>(<span class="keyword">const</span> <span class="keyword">char</span>* classname = 0, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:MakeCode">MakeCode</a>(<span class="keyword">const</span> <span class="keyword">char</span>* filename = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:MakeProxy">MakeProxy</a>(<span class="keyword">const</span> <span class="keyword">char</span>* classname, <span class="keyword">const</span> <span class="keyword">char</span>* macrofilename = 0, <span class="keyword">const</span> <span class="keyword">char</span>* cutfilename = 0, <span class="keyword">const</span> <span class="keyword">char</span>* option = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> maxUnrolling = 3)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:MakeSelector">MakeSelector</a>(<span class="keyword">const</span> <span class="keyword">char</span>* selector = 0)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:MayNotUse"><span class="baseclass">TObject::</span>MayNotUse</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TTree:MemoryFull">MemoryFull</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nbytes)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:Merge">Merge</a>(<a href="./TCollection.html">TCollection</a>* list, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:Merge%1">Merge</a>(<a href="./TCollection.html">TCollection</a>* list, <a href="./TFileMergeInfo.html">TFileMergeInfo</a>* info)</td></tr>
<tr class="func"><td class="funcret">static <a href="./TTree.html">TTree</a>*</td><td class="funcname"><a class="funcname" href="#TTree:MergeTrees">MergeTrees</a>(<a href="./TList.html">TList</a>* list, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:Modify"><span class="baseclass">TAttLine::</span>Modify</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TTree:Notify">Notify</a>()</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Obsolete"><span class="baseclass">TObject::</span>Obsolete</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* asOfVers, <span class="keyword">const</span> <span class="keyword">char</span>* removedFromVers) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:operator_delete"><span class="baseclass">TObject::</span>operator delete</a>(<span class="keyword">void</span>* ptr)</td></tr>
<tr class="funcinh"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:operator_delete%1"><span class="baseclass">TObject::</span>operator delete</a>(<span class="keyword">void</span>* ptr, <span class="keyword">void</span>* vp)</td></tr>
<tr class="funcinh"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:operator_delete[]"><span class="baseclass">TObject::</span>operator delete[]</a>(<span class="keyword">void</span>* ptr)</td></tr>
<tr class="funcinh"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:operator_delete[]%1"><span class="baseclass">TObject::</span>operator delete[]</a>(<span class="keyword">void</span>* ptr, <span class="keyword">void</span>* vp)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:operator_new"><span class="baseclass">TObject::</span>operator new</a>(<a href="./ListOfTypes.html#size_t">size_t</a> sz)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:operator_new%1"><span class="baseclass">TObject::</span>operator new</a>(<a href="./ListOfTypes.html#size_t">size_t</a> sz, <span class="keyword">void</span>* vp)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:operator_new[]"><span class="baseclass">TObject::</span>operator new[]</a>(<a href="./ListOfTypes.html#size_t">size_t</a> sz)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span>*</td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:operator_new[]%1"><span class="baseclass">TObject::</span>operator new[]</a>(<a href="./ListOfTypes.html#size_t">size_t</a> sz, <span class="keyword">void</span>* vp)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:OptimizeBaskets">OptimizeBaskets</a>(<a href="./ListOfTypes.html#ULong64_t">ULong64_t</a> maxMemory = 10000000, <a href="./ListOfTypes.html#Float_t">Float_t</a> minComp = 1.1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Paint"><span class="baseclass">TObject::</span>Paint</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Pop"><span class="baseclass">TObject::</span>Pop</a>()</td></tr>
<tr class="func"><td class="funcret"><a href="./TPrincipal.html">TPrincipal</a>*</td><td class="funcname"><a class="funcname" href="#TTree:Principal">Principal</a>(<span class="keyword">const</span> <span class="keyword">char</span>* varexp = <span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span>* selection = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">"np"</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:Print">Print</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) <span class="keyword">const</span><span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:PrintCacheStats">PrintCacheStats</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:Process">Process</a>(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:Process%1">Process</a>(<span class="keyword">void</span>* selector, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:Project">Project</a>(<span class="keyword">const</span> <span class="keyword">char</span>* hname, <span class="keyword">const</span> <span class="keyword">char</span>* varexp, <span class="keyword">const</span> <span class="keyword">char</span>* selection = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TSQLResult.html">TSQLResult</a>*</td><td class="funcname"><a class="funcname" href="#TTree:Query">Query</a>(<span class="keyword">const</span> <span class="keyword">char</span>* varexp = <span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span>* selection = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Read"><span class="baseclass">TObject::</span>Read</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:ReadFile">ReadFile</a>(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">const</span> <span class="keyword">char</span>* branchDescriptor = <span class="string">""</span>, <span class="keyword">char</span> delimiter = <span class="string">' '</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:ReadStream">ReadStream</a>(<a href="./ListOfTypes.html#istream">istream</a>&amp; inputStream, <span class="keyword">const</span> <span class="keyword">char</span>* branchDescriptor = <span class="string">""</span>, <span class="keyword">char</span> delimiter = <span class="string">' '</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:RecursiveRemove">RecursiveRemove</a>(<a href="./TObject.html">TObject</a>* obj)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:Refresh">Refresh</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:RemoveFriend">RemoveFriend</a>(<a href="./TTree.html">TTree</a>*)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:Reset">Reset</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:ResetAfterMerge">ResetAfterMerge</a>(<a href="./TFileMergeInfo.html">TFileMergeInfo</a>*)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttFill.html#TAttFill:ResetAttFill"><span class="baseclass">TAttFill::</span>ResetAttFill</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:ResetAttLine"><span class="baseclass">TAttLine::</span>ResetAttLine</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttMarker.html#TAttMarker:ResetAttMarker"><span class="baseclass">TAttMarker::</span>ResetAttMarker</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* toption = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:ResetBit"><span class="baseclass">TObject::</span>ResetBit</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> f)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:ResetBranchAddress">ResetBranchAddress</a>(<a href="./TBranch.html">TBranch</a>*)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:ResetBranchAddresses">ResetBranchAddresses</a>()</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:SaveAs"><span class="baseclass">TObject::</span>SaveAs</a>(<span class="keyword">const</span> <span class="keyword">char</span>* filename = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) <span class="keyword">const</span><span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttFill.html#TAttFill:SaveFillAttributes"><span class="baseclass">TAttFill::</span>SaveFillAttributes</a>(<a href="./ListOfTypes.html#ostream">ostream</a>&amp; out, <span class="keyword">const</span> <span class="keyword">char</span>* name, <a href="./ListOfTypes.html#Int_t">Int_t</a> coldef = 1, <a href="./ListOfTypes.html#Int_t">Int_t</a> stydef = 1001)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:SaveLineAttributes"><span class="baseclass">TAttLine::</span>SaveLineAttributes</a>(<a href="./ListOfTypes.html#ostream">ostream</a>&amp; out, <span class="keyword">const</span> <span class="keyword">char</span>* name, <a href="./ListOfTypes.html#Int_t">Int_t</a> coldef = 1, <a href="./ListOfTypes.html#Int_t">Int_t</a> stydef = 1, <a href="./ListOfTypes.html#Int_t">Int_t</a> widdef = 1)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttMarker.html#TAttMarker:SaveMarkerAttributes"><span class="baseclass">TAttMarker::</span>SaveMarkerAttributes</a>(<a href="./ListOfTypes.html#ostream">ostream</a>&amp; out, <span class="keyword">const</span> <span class="keyword">char</span>* name, <a href="./ListOfTypes.html#Int_t">Int_t</a> coldef = 1, <a href="./ListOfTypes.html#Int_t">Int_t</a> stydef = 1, <a href="./ListOfTypes.html#Int_t">Int_t</a> sizdef = 1)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:SavePrimitive"><span class="baseclass">TObject::</span>SavePrimitive</a>(<a href="./ListOfTypes.html#ostream">ostream</a>&amp; out, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:Scan">Scan</a>(<span class="keyword">const</span> <span class="keyword">char</span>* varexp = <span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span>* selection = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TTree:SetAlias">SetAlias</a>(<span class="keyword">const</span> <span class="keyword">char</span>* aliasName, <span class="keyword">const</span> <span class="keyword">char</span>* aliasFormula)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetAutoFlush">SetAutoFlush</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> autof = 30000000)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetAutoSave">SetAutoSave</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> autos = 300000000)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetBasketSize">SetBasketSize</a>(<span class="keyword">const</span> <span class="keyword">char</span>* bname, <a href="./ListOfTypes.html#Int_t">Int_t</a> buffsize = 16000)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:SetBit%1"><span class="baseclass">TObject::</span>SetBit</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> f)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:SetBit"><span class="baseclass">TObject::</span>SetBit</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> f, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> set)</td></tr>
<tr class="func"><td class="funcret"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:SetBranchAddress%2">SetBranchAddress</a>(<span class="keyword">const</span> <span class="keyword">char</span>* bname, <span class="keyword">void</span>** add, <a href="./TBranch.html">TBranch</a>** ptr = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:SetBranchAddress">SetBranchAddress</a>(<span class="keyword">const</span> <span class="keyword">char</span>* bname, <span class="keyword">void</span>* add, <a href="./TClass.html">TClass</a>* realClass, EDataType datatype, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> isptr)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:SetBranchAddress%1">SetBranchAddress</a>(<span class="keyword">const</span> <span class="keyword">char</span>* bname, <span class="keyword">void</span>* add, <a href="./TBranch.html">TBranch</a>** ptr, <a href="./TClass.html">TClass</a>* realClass, EDataType datatype, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> isptr)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetBranchStatus">SetBranchStatus</a>(<span class="keyword">const</span> <span class="keyword">char</span>* bname, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> status = 1, <a href="./ListOfTypes.html#UInt_t">UInt_t</a>* found = 0)</td></tr>
<tr class="func"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetBranchStyle">SetBranchStyle</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> style = 1)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetCacheEntryRange">SetCacheEntryRange</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> first, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> last)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetCacheLearnEntries">SetCacheLearnEntries</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> n = 10)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetCacheSize">SetCacheSize</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> cachesize = -1)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetChainOffset">SetChainOffset</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> offset = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetCircular">SetCircular</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> maxEntries)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetDebug">SetDebug</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> level = 1, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> min = 0, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> max = 9999999)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetDefaultEntryOffsetLen">SetDefaultEntryOffsetLen</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> newdefault, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> updateExisting = <a href="./ListOfTypes.html#Bool_t">kFALSE</a>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetDirectory">SetDirectory</a>(<a href="./TDirectory.html">TDirectory</a>* <a href="./TString.html">dir</a>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:SetDrawOption"><span class="baseclass">TObject::</span>SetDrawOption</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:SetDtorOnly"><span class="baseclass">TObject::</span>SetDtorOnly</a>(<span class="keyword">void</span>* obj)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TTree:SetEntries">SetEntries</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> n = -1)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetEntryList">SetEntryList</a>(<a href="./TEntryList.html">TEntryList</a>* list, <a href="./ListOfTypes.html#Option_t">Option_t</a>* opt = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetEstimate">SetEstimate</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 10000)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetEventList">SetEventList</a>(<a href="./TEventList.html">TEventList</a>* list)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetFileNumber">SetFileNumber</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> number = 0)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttFill.html#TAttFill:SetFillAttributes"><span class="baseclass">TAttFill::</span>SetFillAttributes</a>()<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttFill.html#TAttFill:SetFillColor"><span class="baseclass">TAttFill::</span>SetFillColor</a>(<a href="./ListOfTypes.html#Color_t">Color_t</a> fcolor)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttFill.html#TAttFill:SetFillStyle"><span class="baseclass">TAttFill::</span>SetFillStyle</a>(<a href="./ListOfTypes.html#Style_t">Style_t</a> fstyle)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:SetLineAttributes"><span class="baseclass">TAttLine::</span>SetLineAttributes</a>()<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:SetLineColor"><span class="baseclass">TAttLine::</span>SetLineColor</a>(<a href="./ListOfTypes.html#Color_t">Color_t</a> lcolor)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:SetLineStyle"><span class="baseclass">TAttLine::</span>SetLineStyle</a>(<a href="./ListOfTypes.html#Style_t">Style_t</a> lstyle)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttLine.html#TAttLine:SetLineWidth"><span class="baseclass">TAttLine::</span>SetLineWidth</a>(<a href="./ListOfTypes.html#Width_t">Width_t</a> lwidth)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetMakeClass">SetMakeClass</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> make)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttMarker.html#TAttMarker:SetMarkerAttributes"><span class="baseclass">TAttMarker::</span>SetMarkerAttributes</a>()<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttMarker.html#TAttMarker:SetMarkerColor"><span class="baseclass">TAttMarker::</span>SetMarkerColor</a>(<a href="./ListOfTypes.html#Color_t">Color_t</a> tcolor = 1)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttMarker.html#TAttMarker:SetMarkerSize"><span class="baseclass">TAttMarker::</span>SetMarkerSize</a>(<a href="./ListOfTypes.html#Size_t">Size_t</a> msize = 1)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TAttMarker.html#TAttMarker:SetMarkerStyle"><span class="baseclass">TAttMarker::</span>SetMarkerStyle</a>(<a href="./ListOfTypes.html#Style_t">Style_t</a> mstyle = 1)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetMaxEntryLoop">SetMaxEntryLoop</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> maxev = 1000000000)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetMaxTreeSize">SetMaxTreeSize</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> maxsize = 1900000000)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetMaxVirtualSize">SetMaxVirtualSize</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> size = 0)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetName">SetName</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:SetNameTitle"><span class="baseclass">TNamed::</span>SetNameTitle</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* title)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetNotify">SetNotify</a>(<a href="./TObject.html">TObject</a>* obj)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetObject">SetObject</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* title)</td></tr>
<tr class="funcinh"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:SetObjectStat"><span class="baseclass">TObject::</span>SetObjectStat</a>(<a href="./ListOfTypes.html#Bool_t">Bool_t</a> stat)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetParallelUnzip">SetParallelUnzip</a>(<a href="./ListOfTypes.html#Bool_t">Bool_t</a> opt = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, <a href="./ListOfTypes.html#Float_t">Float_t</a> RelSize = -1)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetScanField">SetScanField</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> n = 50)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetTimerInterval">SetTimerInterval</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> msec = 333)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:SetTitle"><span class="baseclass">TNamed::</span>SetTitle</a>(<span class="keyword">const</span> <span class="keyword">char</span>* title = <span class="string">""</span>)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetTreeIndex">SetTreeIndex</a>(<a href="./TVirtualIndex.html">TVirtualIndex</a>* index)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:SetUniqueID"><span class="baseclass">TObject::</span>SetUniqueID</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> uid)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetUpdate">SetUpdate</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> freq = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:SetWeight">SetWeight</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> w = 1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:Show">Show</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> entry = -1, <a href="./ListOfTypes.html#Int_t">Int_t</a> lenmax = 20)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:ShowMembers">ShowMembers</a>(<a href="./TMemberInspector.html">TMemberInspector</a>&amp; insp)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="./TNamed.html#TNamed:Sizeof"><span class="baseclass">TNamed::</span>Sizeof</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:StartViewer">StartViewer</a>()<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:StopCacheLearningPhase">StopCacheLearningPhase</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:Streamer">Streamer</a>(<a href="./TBuffer.html">TBuffer</a>&amp; b)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:StreamerNVirtual">StreamerNVirtual</a>(<a href="./TBuffer.html">TBuffer</a>&amp; b)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:SysError"><span class="baseclass">TObject::</span>SysError</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* msgfmt) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:TestBit"><span class="baseclass">TObject::</span>TestBit</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> f) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:TestBits"><span class="baseclass">TObject::</span>TestBits</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> f) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:UnbinnedFit">UnbinnedFit</a>(<span class="keyword">const</span> <span class="keyword">char</span>* funcname, <span class="keyword">const</span> <span class="keyword">char</span>* varexp, <span class="keyword">const</span> <span class="keyword">char</span>* selection = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:UseCurrentStyle">UseCurrentStyle</a>()</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:Warning"><span class="baseclass">TObject::</span>Warning</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* msgfmt) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:Write">Write</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> option = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 0)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:Write%1">Write</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> option = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 0) <span class="keyword">const</span></td></tr>

</table></div>
<div class="access" id="funcprot"><b>protected:</b>
<table class="func" id="tabfuncprot" cellspacing="0">
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:AddClone">AddClone</a>(<a href="./TTree.html">TTree</a>*)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TBranch.html">TBranch</a>*</td><td class="funcname"><a class="funcname" href="#TTree:BranchImp%1">BranchImp</a>(<span class="keyword">const</span> <span class="keyword">char</span>* branchname, <a href="./TClass.html">TClass</a>* ptrClass, <span class="keyword">void</span>* addobj, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TBranch.html">TBranch</a>*</td><td class="funcname"><a class="funcname" href="#TTree:BranchImp">BranchImp</a>(<span class="keyword">const</span> <span class="keyword">char</span>* branchname, <span class="keyword">const</span> <span class="keyword">char</span>* classname, <a href="./TClass.html">TClass</a>* ptrClass, <span class="keyword">void</span>* addobj, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TBranch.html">TBranch</a>*</td><td class="funcname"><a class="funcname" href="#TTree:BranchImpRef">BranchImpRef</a>(<span class="keyword">const</span> <span class="keyword">char</span>* branchname, <span class="keyword">const</span> <span class="keyword">char</span>* classname, <a href="./TClass.html">TClass</a>* ptrClass, <span class="keyword">void</span>* addobj, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TBranch.html">TBranch</a>*</td><td class="funcname"><a class="funcname" href="#TTree:BranchImpRef%1">BranchImpRef</a>(<span class="keyword">const</span> <span class="keyword">char</span>* branchname, <a href="./TClass.html">TClass</a>* ptrClass, EDataType datatype, <span class="keyword">void</span>* addobj, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TBranch.html">TBranch</a>*</td><td class="funcname"><a class="funcname" href="#TTree:BronchExec">BronchExec</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* classname, <span class="keyword">void</span>* addobj, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> isptrptr, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:CheckBranchAddressType">CheckBranchAddressType</a>(<a href="./TBranch.html">TBranch</a>* branch, <a href="./TClass.html">TClass</a>* ptrClass, EDataType datatype, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> ptr)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:DoError"><span class="baseclass">TObject::</span>DoError</a>(<span class="keyword">int</span> level, <span class="keyword">const</span> <span class="keyword">char</span>* location, <span class="keyword">const</span> <span class="keyword">char</span>* fmt, va_list va) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./TLeaf.html">TLeaf</a>*</td><td class="funcname"><a class="funcname" href="#TTree:GetLeafImpl">GetLeafImpl</a>(<span class="keyword">const</span> <span class="keyword">char</span>* branchname, <span class="keyword">const</span> <span class="keyword">char</span>* leafname)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">char</span></td><td class="funcname"><a class="funcname" href="#TTree:GetNewlineValue">GetNewlineValue</a>(<a href="./ListOfTypes.html#istream">istream</a>&amp; inputStream)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:ImportClusterRanges">ImportClusterRanges</a>(<a href="./TTree.html">TTree</a>* fromtree)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TTree:KeepCircular">KeepCircular</a>()</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="./TObject.html#TObject:MakeZombie"><span class="baseclass">TObject::</span>MakeZombie</a>()</td></tr>
<tr class="func"><td class="funcret"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TTree:SetBranchAddressImp">SetBranchAddressImp</a>(<a href="./TBranch.html">TBranch</a>* branch, <span class="keyword">void</span>* addr, <a href="./TBranch.html">TBranch</a>** ptr)</td></tr>

</table></div>
<div class="access" id="funcpriv"><b>private:</b>
<table class="func" id="tabfuncpriv" cellspacing="0">
<tr class="func"><td class="funcret"></td><td class="funcname"><a class="funcname" href="#TTree:TTree">TTree</a>(<span class="keyword">const</span> <a href="./TTree.html">TTree</a>&amp; tt)</td></tr>
<tr class="func"><td class="funcret"><a href="./TTree.html">TTree</a>&amp;</td><td class="funcname"><a class="funcname" href="#TTree:operator_">operator=</a>(<span class="keyword">const</span> <a href="./TTree.html">TTree</a>&amp; tt)</td></tr>

</table></div>
</div>

<div id="datamembers">
<h2><a name="TTree:Data_Members"></a>Data Members</h2>
<div class="access" id="enumpubl"><b>public:</b>
<table class="data" id="tabenumpubl" cellspacing="0">
<tr class="data"><td class="datatype">enum ELockStatusBits { </td><td class="dataname"><a name="TTree:kFindBranch"></a>kFindBranch</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kFindLeaf"></a>kFindLeaf</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kGetAlias"></a>kGetAlias</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kGetBranch"></a>kGetBranch</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kGetEntry"></a>kGetEntry</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kGetEntryWithIndex"></a>kGetEntryWithIndex</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kGetFriend"></a>kGetFriend</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kGetFriendAlias"></a>kGetFriendAlias</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kGetLeaf"></a>kGetLeaf</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kLoadTree"></a>kLoadTree</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kPrint"></a>kPrint</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kRemoveFriend"></a>kRemoveFriend</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kSetBranchStatus"></a>kSetBranchStatus</td><td></td></tr>
<tr class="data"><td class="datatype">};</td><td></td><td></td></tr>
<tr class="data"><td class="datatype">enum SetBranchAddressStatus { </td><td class="dataname"><a name="TTree:kMissingBranch"></a>kMissingBranch</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kInternalError"></a>kInternalError</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kMissingCompiledCollectionProxy"></a>kMissingCompiledCollectionProxy</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kMismatch"></a>kMismatch</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kClassMismatch"></a>kClassMismatch</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kMatch"></a>kMatch</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kMatchConversion"></a>kMatchConversion</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kMatchConversionCollection"></a>kMatchConversionCollection</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kMakeClass"></a>kMakeClass</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kVoidPtr"></a>kVoidPtr</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kNoCheck"></a>kNoCheck</td><td></td></tr>
<tr class="data"><td class="datatype">};</td><td></td><td></td></tr>
<tr class="data"><td class="datatype">enum  { </td><td class="dataname"><a name="TTree:kForceRead"></a>kForceRead</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kCircular"></a>kCircular</td><td></td></tr>
<tr class="data"><td class="datatype"></td><td class="dataname"><a name="TTree:kSplitCollectionOfPointers"></a>kSplitCollectionOfPointers</td><td></td></tr>
<tr class="data"><td class="datatype">};</td><td></td><td></td></tr>
<tr class="datainh"><td class="datatype">enum <span class="baseclass">TObject::</span>EStatusBits { </td><td class="dataname"><a href="./TObject.html#TObject:kCanDelete">kCanDelete</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kMustCleanup">kMustCleanup</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kObjInCanvas">kObjInCanvas</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kIsReferenced">kIsReferenced</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kHasUUID">kHasUUID</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kCannotPick">kCannotPick</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kNoContextMenu">kNoContextMenu</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kInvalidObject">kInvalidObject</a></td><td></td></tr>
<tr class="datainh"><td class="datatype">};</td><td></td><td></td></tr>
<tr class="datainh"><td class="datatype">enum <span class="baseclass">TObject::</span><i>[unnamed]</i> { </td><td class="dataname"><a href="./TObject.html#TObject:kIsOnHeap">kIsOnHeap</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kNotDeleted">kNotDeleted</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kZombie">kZombie</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kBitMask">kBitMask</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kSingleKey">kSingleKey</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kOverwrite">kOverwrite</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="./TObject.html#TObject:kWriteDelete">kWriteDelete</a></td><td></td></tr>
<tr class="datainh"><td class="datatype">};</td><td></td><td></td></tr>

</table></div>
<div class="access" id="dataprot"><b>protected:</b>
<table class="data" id="tabdataprot" cellspacing="0">
<tr class="data"><td class="datatype"><a href="./TList.html">TList</a>*</td><td class="dataname"><a name="TTree:fAliases"></a>fAliases</td><td class="datadesc">List of aliases for expressions based on the tree branches.</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="dataname"><a name="TTree:fAutoFlush"></a>fAutoFlush</td><td class="datadesc">Autoflush tree when fAutoFlush entries written</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="dataname"><a name="TTree:fAutoSave"></a>fAutoSave</td><td class="datadesc">Autosave tree when fAutoSave bytes produced</td></tr>
<tr class="data"><td class="datatype"><a href="./TBranchRef.html">TBranchRef</a>*</td><td class="dataname"><a name="TTree:fBranchRef"></a>fBranchRef</td><td class="datadesc">Branch supporting the TRefTable (if any)</td></tr>
<tr class="data"><td class="datatype"><a href="./TObjArray.html">TObjArray</a></td><td class="dataname"><a name="TTree:fBranches"></a>fBranches</td><td class="datadesc">List of Branches</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="dataname"><a name="TTree:fCacheSize"></a>fCacheSize</td><td class="datadesc">! Maximum size of file buffers</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="dataname"><a name="TTree:fChainOffset"></a>fChainOffset</td><td class="datadesc">! Offset of 1st entry of this Tree in a TChain</td></tr>
<tr class="data"><td class="datatype"><a href="./TList.html">TList</a>*</td><td class="dataname"><a name="TTree:fClones"></a>fClones</td><td class="datadesc">! List of cloned trees which share our addresses</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Long64_t">Long64_t</a>*</td><td class="dataname"><a name="TTree:fClusterRangeEnd"></a>fClusterRangeEnd</td><td class="datadesc">[fNClusterRange] Last entry of a cluster range.</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Long64_t">Long64_t</a>*</td><td class="dataname"><a name="TTree:fClusterSize"></a>fClusterSize</td><td class="datadesc">[fNClusterRange] Number of entries in each cluster for a given range.</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="dataname"><a name="TTree:fDebug"></a>fDebug</td><td class="datadesc">! Debug level</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="dataname"><a name="TTree:fDebugMax"></a>fDebugMax</td><td class="datadesc">! Last entry number to debug</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="dataname"><a name="TTree:fDebugMin"></a>fDebugMin</td><td class="datadesc">! First entry number to debug</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="dataname"><a name="TTree:fDefaultEntryOffsetLen"></a>fDefaultEntryOffsetLen</td><td class="datadesc">Initial Length of fEntryOffset table in the basket buffers</td></tr>
<tr class="data"><td class="datatype"><a href="./TDirectory.html">TDirectory</a>*</td><td class="dataname"><a name="TTree:fDirectory"></a>fDirectory</td><td class="datadesc">! Pointer to directory holding this tree</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="dataname"><a name="TTree:fEntries"></a>fEntries</td><td class="datadesc">Number of entries</td></tr>
<tr class="data"><td class="datatype"><a href="./TEntryList.html">TEntryList</a>*</td><td class="dataname"><a name="TTree:fEntryList"></a>fEntryList</td><td class="datadesc">! Pointer to event selection list (if one)</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="dataname"><a name="TTree:fEstimate"></a>fEstimate</td><td class="datadesc">Number of entries to estimate histogram limits</td></tr>
<tr class="data"><td class="datatype"><a href="./TEventList.html">TEventList</a>*</td><td class="dataname"><a name="TTree:fEventList"></a>fEventList</td><td class="datadesc">! Pointer to event selection list (if one)</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="dataname"><a name="TTree:fFileNumber"></a>fFileNumber</td><td class="datadesc">! current file number (if file extensions)</td></tr>
<tr class="datainh"><td class="datatype"><a href="./ListOfTypes.html#Color_t">Color_t</a></td><td class="dataname"><a href="./TAttFill.html#TAttFill:fFillColor"><span class="baseclass">TAttFill::</span>fFillColor</a></td><td class="datadesc">fill area color</td></tr>
<tr class="datainh"><td class="datatype"><a href="./ListOfTypes.html#Style_t">Style_t</a></td><td class="dataname"><a href="./TAttFill.html#TAttFill:fFillStyle"><span class="baseclass">TAttFill::</span>fFillStyle</a></td><td class="datadesc">fill area style</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="dataname"><a name="TTree:fFlushedBytes"></a>fFlushedBytes</td><td class="datadesc">Number of autoflushed bytes</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#UInt_t">UInt_t</a></td><td class="dataname"><a name="TTree:fFriendLockStatus"></a>fFriendLockStatus</td><td class="datadesc">! Record which method is locking the friend recursion</td></tr>
<tr class="data"><td class="datatype"><a href="./TList.html">TList</a>*</td><td class="dataname"><a name="TTree:fFriends"></a>fFriends</td><td class="datadesc">pointer to list of friend elements</td></tr>
<tr class="data"><td class="datatype"><a href="./TArrayI.html">TArrayI</a></td><td class="dataname"><a name="TTree:fIndex"></a>fIndex</td><td class="datadesc">Index of sorted values</td></tr>
<tr class="data"><td class="datatype"><a href="./TArrayD.html">TArrayD</a></td><td class="dataname"><a name="TTree:fIndexValues"></a>fIndexValues</td><td class="datadesc">Sorted index values</td></tr>
<tr class="data"><td class="datatype"><a href="./TObjArray.html">TObjArray</a></td><td class="dataname"><a name="TTree:fLeaves"></a>fLeaves</td><td class="datadesc">Direct pointers to individual branch leaves</td></tr>
<tr class="datainh"><td class="datatype"><a href="./ListOfTypes.html#Color_t">Color_t</a></td><td class="dataname"><a href="./TAttLine.html#TAttLine:fLineColor"><span class="baseclass">TAttLine::</span>fLineColor</a></td><td class="datadesc">line color</td></tr>
<tr class="datainh"><td class="datatype"><a href="./ListOfTypes.html#Style_t">Style_t</a></td><td class="dataname"><a href="./TAttLine.html#TAttLine:fLineStyle"><span class="baseclass">TAttLine::</span>fLineStyle</a></td><td class="datadesc">line style</td></tr>
<tr class="datainh"><td class="datatype"><a href="./ListOfTypes.html#Width_t">Width_t</a></td><td class="dataname"><a href="./TAttLine.html#TAttLine:fLineWidth"><span class="baseclass">TAttLine::</span>fLineWidth</a></td><td class="datadesc">line width</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="dataname"><a name="TTree:fMakeClass"></a>fMakeClass</td><td class="datadesc">! not zero when processing code generated by MakeClass</td></tr>
<tr class="datainh"><td class="datatype"><a href="./ListOfTypes.html#Color_t">Color_t</a></td><td class="dataname"><a href="./TAttMarker.html#TAttMarker:fMarkerColor"><span class="baseclass">TAttMarker::</span>fMarkerColor</a></td><td class="datadesc">Marker color index</td></tr>
<tr class="datainh"><td class="datatype"><a href="./ListOfTypes.html#Size_t">Size_t</a></td><td class="dataname"><a href="./TAttMarker.html#TAttMarker:fMarkerSize"><span class="baseclass">TAttMarker::</span>fMarkerSize</a></td><td class="datadesc">Marker size</td></tr>
<tr class="datainh"><td class="datatype"><a href="./ListOfTypes.html#Style_t">Style_t</a></td><td class="dataname"><a href="./TAttMarker.html#TAttMarker:fMarkerStyle"><span class="baseclass">TAttMarker::</span>fMarkerStyle</a></td><td class="datadesc">Marker style</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="dataname"><a name="TTree:fMaxClusterRange"></a>fMaxClusterRange</td><td class="datadesc">! Memory allocated for the cluster range.</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="dataname"><a name="TTree:fMaxEntries"></a>fMaxEntries</td><td class="datadesc">Maximum number of entries in case of circular buffers</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="dataname"><a name="TTree:fMaxEntryLoop"></a>fMaxEntryLoop</td><td class="datadesc">Maximum number of entries to process</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="dataname"><a name="TTree:fMaxVirtualSize"></a>fMaxVirtualSize</td><td class="datadesc">Maximum total size of buffers kept in memory</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="dataname"><a name="TTree:fNClusterRange"></a>fNClusterRange</td><td class="datadesc">Number of Cluster range in addition to the one defined by 'AutoFlush'</td></tr>
<tr class="datainh"><td class="datatype"><a href="./TString.html">TString</a></td><td class="dataname"><a href="./TNamed.html#TNamed:fName"><span class="baseclass">TNamed::</span>fName</a></td><td class="datadesc">object identifier</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="dataname"><a name="TTree:fNfill"></a>fNfill</td><td class="datadesc">! Local for EntryLoop</td></tr>
<tr class="data"><td class="datatype"><a href="./TObject.html">TObject</a>*</td><td class="dataname"><a name="TTree:fNotify"></a>fNotify</td><td class="datadesc">! Object to be notified when loading a Tree</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="dataname"><a name="TTree:fPacketSize"></a>fPacketSize</td><td class="datadesc">! Number of entries in one packet for parallel root</td></tr>
<tr class="data"><td class="datatype"><a href="./TVirtualTreePlayer.html">TVirtualTreePlayer</a>*</td><td class="dataname"><a name="TTree:fPlayer"></a>fPlayer</td><td class="datadesc">! Pointer to current Tree player</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="dataname"><a name="TTree:fReadEntry"></a>fReadEntry</td><td class="datadesc">! Number of the entry being processed</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="dataname"><a name="TTree:fSavedBytes"></a>fSavedBytes</td><td class="datadesc">Number of autosaved bytes</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="dataname"><a name="TTree:fScanField"></a>fScanField</td><td class="datadesc">Number of runs before prompting in Scan</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="dataname"><a name="TTree:fTimerInterval"></a>fTimerInterval</td><td class="datadesc">Timer interval in milliseconds</td></tr>
<tr class="datainh"><td class="datatype"><a href="./TString.html">TString</a></td><td class="dataname"><a href="./TNamed.html#TNamed:fTitle"><span class="baseclass">TNamed::</span>fTitle</a></td><td class="datadesc">object title</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="dataname"><a name="TTree:fTotBytes"></a>fTotBytes</td><td class="datadesc">Total number of bytes in all branches before compression</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="dataname"><a name="TTree:fTotalBuffers"></a>fTotalBuffers</td><td class="datadesc">! Total number of bytes in branch buffers</td></tr>
<tr class="data"><td class="datatype"><a href="./TBuffer.html">TBuffer</a>*</td><td class="dataname"><a name="TTree:fTransientBuffer"></a>fTransientBuffer</td><td class="datadesc">! Pointer to the current transient buffer.</td></tr>
<tr class="data"><td class="datatype"><a href="./TVirtualIndex.html">TVirtualIndex</a>*</td><td class="dataname"><a name="TTree:fTreeIndex"></a>fTreeIndex</td><td class="datadesc">Pointer to the tree Index (if any)</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="dataname"><a name="TTree:fUpdate"></a>fUpdate</td><td class="datadesc">Update frequency for EntryLoop</td></tr>
<tr class="data"><td class="datatype"><a href="./TList.html">TList</a>*</td><td class="dataname"><a name="TTree:fUserInfo"></a>fUserInfo</td><td class="datadesc">pointer to a list of user objects associated to this Tree</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="dataname"><a name="TTree:fWeight"></a>fWeight</td><td class="datadesc">Tree weight (see TTree::SetWeight)</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="dataname"><a name="TTree:fZipBytes"></a>fZipBytes</td><td class="datadesc">Total number of bytes in all branches after compression</td></tr>
<tr class="data"><td class="datatype">static <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="dataname"><a name="TTree:fgBranchStyle"></a>fgBranchStyle</td><td class="datadesc">Old/New branch style</td></tr>
<tr class="data"><td class="datatype">static <a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="dataname"><a name="TTree:fgMaxTreeSize"></a>fgMaxTreeSize</td><td class="datadesc">Maximum size of a file containg a Tree</td></tr>

</table></div>
</div>
<h2><a id="TTree:Class_Charts"></a>Class Charts</h2>
<map name="MapTTree_Inh" id="MapTTree_Inh">
<area shape="rect" href="./TNamed.html" title="TNamed" alt="" coords="188,13,252,31"/>
<area shape="rect" href="./TAttLine.html" title="TAttLine" alt="" coords="189,34,251,52"/>
<area shape="rect" href="./TAttFill.html" title="TAttFill" alt="" coords="195,55,245,73"/>
<area shape="rect" href="./TAttMarker.html" title="TAttMarker" alt="" coords="179,76,261,94"/>
<area shape="rect" href="./TObject.html" title="TObject" alt="" coords="27,13,86,31"/>
<area shape="rect" href="./TChain.html" title="TChain" alt="" coords="522,3,574,21"/>
<area shape="rect" href="./THbookTree.html" title="THbookTree" alt="" coords="504,24,592,42"/>
<area shape="rect" href="./TNtuple.html" title="TNtuple" alt="" coords="518,45,578,62"/>
<area shape="rect" href="./TNtupleD.html" title="TNtupleD" alt="" coords="512,65,584,83"/>
<area shape="rect" href="./TTreeSQL.html" title="TTreeSQL" alt="" coords="513,86,583,104"/>
<area shape="rect" href="./TProofChain.html" title="TProofChain" alt="" coords="666,3,757,21"/>
</map>
<map name="MapTTree_InhMem" id="MapTTree_InhMem">
<area shape="rect" href="./TNamed.html" alt="" coords="344,60,629,109"/>
<area shape="rect" href="./TNamed.html" alt="" coords="541,120,629,297"/>
<area shape="rect" href="./TNamed.html" alt="" coords="443,120,531,297"/>
<area shape="rect" href="./TNamed.html" alt="" coords="344,120,432,297"/>
<area shape="rect" href="./TNamed.html" title="TNamed" alt="" coords="333,16,640,308"/>
<area shape="rect" href="./TAttLine.html" alt="" coords="541,407,629,471"/>
<area shape="rect" href="./TAttLine.html" alt="" coords="443,407,531,471"/>
<area shape="rect" href="./TAttLine.html" alt="" coords="376,407,400,441"/>
<area shape="rect" href="./TAttLine.html" alt="" coords="541,481,629,644"/>
<area shape="rect" href="./TAttLine.html" alt="" coords="443,481,531,644"/>
<area shape="rect" href="./TAttLine.html" alt="" coords="344,481,432,644"/>
<area shape="rect" href="./TAttLine.html" title="TAttLine" alt="" coords="333,363,640,655"/>
<area shape="rect" href="./TAttFill.html" alt="" coords="344,797,629,847"/>
<area shape="rect" href="./TAttFill.html" alt="" coords="541,857,629,991"/>
<area shape="rect" href="./TAttFill.html" alt="" coords="443,857,531,1020"/>
<area shape="rect" href="./TAttFill.html" alt="" coords="344,857,432,1020"/>
<area shape="rect" href="./TAttFill.html" title="TAttFill" alt="" coords="333,753,640,1031"/>
<area shape="rect" href="./TAttMarker.html" alt="" coords="541,1263,629,1327"/>
<area shape="rect" href="./TAttMarker.html" alt="" coords="443,1263,531,1327"/>
<area shape="rect" href="./TAttMarker.html" alt="" coords="376,1263,400,1297"/>
<area shape="rect" href="./TAttMarker.html" alt="" coords="541,1337,629,1485"/>
<area shape="rect" href="./TAttMarker.html" alt="" coords="443,1337,531,1500"/>
<area shape="rect" href="./TAttMarker.html" alt="" coords="344,1337,432,1500"/>
<area shape="rect" href="./TAttMarker.html" title="TAttMarker" alt="" coords="333,1219,640,1511"/>
<area shape="rect" href="./TObject.html" alt="" coords="224,60,312,183"/>
<area shape="rect" href="./TObject.html" alt="" coords="125,60,213,197"/>
<area shape="rect" href="./TObject.html" alt="" coords="27,60,115,197"/>
<area shape="rect" href="./TObject.html" alt="" coords="256,193,280,228"/>
<area shape="rect" href="./TObject.html" alt="" coords="224,239,312,665"/>
<area shape="rect" href="./TObject.html" alt="" coords="125,224,213,665"/>
<area shape="rect" href="./TObject.html" alt="" coords="27,224,115,665"/>
<area shape="rect" href="./TObject.html" title="TObject" alt="" coords="16,16,323,676"/>
</map>
<map name="MapTTree_Lib" id="MapTTree_Lib">
<area shape="rect" href="LibraryDependencies.html" title="All Libraries" alt="" coords="407,160,535,208"/>
</map>
<div class="tabs">
<a id="imgTTree_Inh" class="tabsel" href="inh/TTree_Inh.png" onclick="javascript:return SetImg('Charts','inh/TTree_Inh.png');">Inheritance</a>
<a id="imgTTree_InhMem" class="tab" href="inhmem/TTree_InhMem.png" onclick="javascript:return SetImg('Charts','inhmem/TTree_InhMem.png');">Inherited Members</a>
<a id="imgTTree_Incl" class="tab" href="incl/TTree_Incl.png" onclick="javascript:return SetImg('Charts','incl/TTree_Incl.png');">Includes</a>
<a id="imgTTree_Lib" class="tab" href="lib/TTree_Lib.png" onclick="javascript:return SetImg('Charts','lib/TTree_Lib.png');">Libraries</a><br/>
</div><div class="classcharts"><div class="classchartswidth"></div>
<img id="Charts" alt="Class Charts" class="classcharts" usemap="#MapTTree_Inh" src="inh/TTree_Inh.png"/></div>
<h2>Function documentation</h2>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="TTree:TTree%1" href="src/TTree.cxx.html#QLPEIC">TTree</a>()</span><br />
<div class="funccomm"><pre> Default constructor and I/O constructor.

 Note: We do *not* insert ourself into the current directory.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="TTree:TTree%2" href="src/TTree.cxx.html#cWH30C">TTree</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* title, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel = 99)</span><br />
<div class="funccomm"><pre> Normal tree constructor.

 The tree is created in the current directory.
 Use the various functions <a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> below to add branches to this tree.

 If the first character of title is a <span class="string">"/"</span>, the function assumes a folder name.
 In this case, it creates automatically branches following the folder hierarchy.
 splitlevel may be used in this case to control the split level.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="TTree:_TTree" href="src/TTree.cxx.html#kwsDFC">~TTree</a>()</span><br />
<div class="funccomm"><pre> Destructor.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TBuffer.html">TBuffer</a>* <a class="funcname" name="TTree:GetTransientBuffer" href="src/TTree.cxx.html#WDcK1B">GetTransientBuffer</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> size)</span><br />
<div class="funccomm"><pre> Returns the transient buffer currently used by this <a href="./TTree.html">TTree</a> for reading/writing baskets
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:AddBranchToCache" href="src/TTree.cxx.html#j2sTAD">AddBranchToCache</a>(<span class="keyword">const</span> <span class="keyword">char</span>* bname, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> subbranches = <a href="./ListOfTypes.html#Bool_t">kFALSE</a>)</span><br />
<div class="funccomm"><pre> Add branch with name bname to the Tree cache.
 If bname=<span class="string">"*"</span> all branches are added to the cache.
 if subbranches is <a href="./ListOfTypes.html#bool">true</a> all the branches of the subbranches are
 also put to the cache.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:AddBranchToCache%1" href="src/TTree.cxx.html#MJiOvD">AddBranchToCache</a>(<a href="./TBranch.html">TBranch</a>* branch, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> subbranches = <a href="./ListOfTypes.html#Bool_t">kFALSE</a>)</span><br />
<div class="funccomm"><pre> Add branch b to the Tree cache.
 if subbranches is <a href="./ListOfTypes.html#bool">true</a> all the branches of the subbranches are
 also put to the cache.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:DropBranchFromCache" href="src/TTree.cxx.html#vlClOC">DropBranchFromCache</a>(<span class="keyword">const</span> <span class="keyword">char</span>* bname, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> subbranches = <a href="./ListOfTypes.html#Bool_t">kFALSE</a>)</span><br />
<div class="funccomm"><pre> Add branch with name bname to the Tree cache.
 If bname=<span class="string">"*"</span> all branches are added to the cache.
 if subbranches is <a href="./ListOfTypes.html#bool">true</a> all the branches of the subbranches are
 also put to the cache.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:DropBranchFromCache%1" href="src/TTree.cxx.html#C9XmyE">DropBranchFromCache</a>(<a href="./TBranch.html">TBranch</a>* branch, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> subbranches = <a href="./ListOfTypes.html#Bool_t">kFALSE</a>)</span><br />
<div class="funccomm"><pre> Add branch b to the Tree cache.
 if subbranches is <a href="./ListOfTypes.html#bool">true</a> all the branches of the subbranches are
 also put to the cache.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:AddClone" href="src/TTree.cxx.html#adLhwC">AddClone</a>(<a href="./TTree.html">TTree</a>* )</span><br />
<div class="funccomm"><pre> Add a cloned tree to our list of trees to be notified whenever we change
 our branch addresses or when we are deleted.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TFriendElement.html">TFriendElement</a>* <a class="funcname" name="TTree:AddFriend" href="src/TTree.cxx.html#aFzOcC">AddFriend</a>(<span class="keyword">const</span> <span class="keyword">char</span>* treename, <span class="keyword">const</span> <span class="keyword">char</span>* filename = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre> Add a <a href="./TFriendElement.html">TFriendElement</a> to the list of friends.

 This function:
   -opens a file if filename is specified
   -reads a Tree with name treename from the file (current directory)
   -adds the Tree to the list of friends
 see other <a href="./TTree.html#TTree:AddFriend" title="TFriendElement* TTree::AddFriend(const char* treename,const char* filename=&quot;&quot;) or overloads">AddFriend</a> functions

 A <a href="./TFriendElement.html">TFriendElement</a> TF describes a <a href="./TTree.html">TTree</a> object TF in a file.
 When a <a href="./TFriendElement.html">TFriendElement</a> TF is added to the the list of friends of an
 existing <a href="./TTree.html">TTree</a> T, any variable from TF can be referenced in a query
 to T.

   A tree keeps a list of friends. In the context of a tree (or a chain),
 friendship means unrestricted access to the friends data. In this way
 it is much like adding another branch to the tree without taking the risk
 of damaging it. To add a friend to the list, you can use the <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:AddFriend" title="TFriendElement* TTree::AddFriend(const char* treename,const char* filename=&quot;&quot;) or overloads">AddFriend</a>
 method.  The tree in the diagram below has two friends (friend_tree1 and
 friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m.


</pre><!-- TDocHtmlDirective start -->   /*
   <img src="gif/tree_friend1.gif">
   */
<!-- TDocHtmlDirective end --><pre>

 The <a href="./TTree.html#TTree:AddFriend" title="TFriendElement* TTree::AddFriend(const char* treename,const char* filename=&quot;&quot;) or overloads">AddFriend</a> method has two parameters, the first is the tree name and the
 second is the name of the <a href="./ROOT.html">ROOT</a> file where the friend tree is saved.
 <a href="./TTree.html#TTree:AddFriend" title="TFriendElement* TTree::AddFriend(const char* treename,const char* filename=&quot;&quot;) or overloads">AddFriend</a> automatically opens the friend file. If no file name is given,
 the tree called ft1 is assumed to be in the same file as the original tree.

 tree.<a href="./TTree.html#TTree:AddFriend" title="TFriendElement* TTree::AddFriend(const char* treename,const char* filename=&quot;&quot;) or overloads">AddFriend</a>(<span class="string">"ft1"</span>,<span class="string">"friendfile1.root"</span>);
 If the friend tree has the same name as the original tree, you can give it
 an alias sin the context of the friendship:

 tree.<a href="./TTree.html#TTree:AddFriend" title="TFriendElement* TTree::AddFriend(const char* treename,const char* filename=&quot;&quot;) or overloads">AddFriend</a>(<span class="string">"tree1 = tree"</span>,<span class="string">"friendfile1.root"</span>);
 Once the tree has friends, we can use <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> as if the friend's
 variables were in the original tree. To specify which tree to use in
 the <a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> method, use the syntax:

 &lt;treeName&gt;.&lt;branchname&gt;.&lt;varname&gt;
 If the variablename is enough to uniquely identify the variable, you can
 leave out the tree and/or branch name.
 For example, these commands generate a 3-d scatter plot of variable <span class="string">"var"</span>
 in the <a href="./TTree.html">TTree</a> tree versus variable v1 in <a href="./TTree.html">TTree</a> ft1 versus variable v2 in
 <a href="./TTree.html">TTree</a> ft2.

 tree.<a href="./TTree.html#TTree:AddFriend" title="TFriendElement* TTree::AddFriend(const char* treename,const char* filename=&quot;&quot;) or overloads">AddFriend</a>(<span class="string">"ft1"</span>,<span class="string">"friendfile1.root"</span>);
 tree.<a href="./TTree.html#TTree:AddFriend" title="TFriendElement* TTree::AddFriend(const char* treename,const char* filename=&quot;&quot;) or overloads">AddFriend</a>(<span class="string">"ft2"</span>,<span class="string">"friendfile2.root"</span>);
 tree.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"var:ft1.v1:ft2.v2"</span>);


</pre><!-- TDocHtmlDirective start -->   /*
   <img src="gif/tree_friend2.gif">
   */
<!-- TDocHtmlDirective end --><pre>

 The picture illustrates the access of the tree and its friends with a
 <a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> command.
 When <a href="./TTree.html#TTree:AddFriend" title="TFriendElement* TTree::AddFriend(const char* treename,const char* filename=&quot;&quot;) or overloads">AddFriend</a> is called, the <a href="./ROOT.html">ROOT</a> file is automatically opened and the
 friend tree (ft1) is read into memory. The new friend (ft1) is added to
 the list of friends of tree.
 The number of entries in the friend must be equal or greater to the number
 of entries of the original tree. If the friend tree has fewer entries a
 warning is given and the missing entries are not included in the histogram.
 To retrieve the list of friends from a tree use <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:GetListOfFriends" title="TList* TTree::GetListOfFriends()">GetListOfFriends</a>.
 When the tree is written to file (<a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Write" title="Int_t TTree::Write(const char* name=0,Int_t option=0,Int_t bufsize=0) or overloads">Write</a>), the friends list is saved
 with it. And when the tree is retrieved, the trees on the friends list are
 also retrieved and the friendship restored.
 When a tree is deleted, the elements of the friend list are also deleted.
 It is possible to declare a friend tree that has the same internal
 structure (same branches and leaves) as the original tree, and compare the
 same values by specifying the tree.

  tree.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"var:ft1.var:ft2.var"</span>)
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TFriendElement.html">TFriendElement</a>* <a class="funcname" name="TTree:AddFriend%1" href="src/TTree.cxx.html#ETMTS">AddFriend</a>(<span class="keyword">const</span> <span class="keyword">char</span>* treename, <a href="./TFile.html">TFile</a>* file)</span><br />
<div class="funccomm"><pre> Add a <a href="./TFriendElement.html">TFriendElement</a> to the list of friends.

 The <a href="./TFile.html">TFile</a> is managed by the user (e.g. the user must delete the file).
 For complete description see <a href="./TTree.html#TTree:AddFriend" title="TFriendElement* TTree::AddFriend(const char* treename,const char* filename=&quot;&quot;) or overloads">AddFriend</a>(const <a href="./ListOfTypes.html#char">char</a> *, const <a href="./ListOfTypes.html#char">char</a> *).
 This function:
   -reads a Tree with name treename from the file
   -adds the Tree to the list of friends
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TFriendElement.html">TFriendElement</a>* <a class="funcname" name="TTree:AddFriend%2" href="src/TTree.cxx.html#hHj_jD">AddFriend</a>(<a href="./TTree.html">TTree</a>* tree, <span class="keyword">const</span> <span class="keyword">char</span>* alias = <span class="string">""</span>, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> warn = <a href="./ListOfTypes.html#Bool_t">kFALSE</a>)</span><br />
<div class="funccomm"><pre> Add a <a href="./TFriendElement.html">TFriendElement</a> to the list of friends.

 The <a href="./TTree.html">TTree</a> is managed by the user (e.g., the user must delete the file).
 For a complete description see <a href="./TTree.html#TTree:AddFriend" title="TFriendElement* TTree::AddFriend(const char* treename,const char* filename=&quot;&quot;) or overloads">AddFriend</a>(const <a href="./ListOfTypes.html#char">char</a> *, const <a href="./ListOfTypes.html#char">char</a> *).
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:AutoSave" href="src/TTree.cxx.html#I65KDD">AutoSave</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre> <a href="./TTree.html#TTree:AutoSave" title="Long64_t TTree::AutoSave(Option_t* option=&quot;&quot;)">AutoSave</a> tree header every <a href="./TTree.html#TTree:fAutoSave" title="Long64_t TTree::fAutoSave">fAutoSave</a> bytes.

   When large Trees are produced, it is safe to activate the <a href="./TTree.html#TTree:AutoSave" title="Long64_t TTree::AutoSave(Option_t* option=&quot;&quot;)">AutoSave</a>
   procedure. Some branches may have buffers holding many entries.
   <a href="./TTree.html#TTree:AutoSave" title="Long64_t TTree::AutoSave(Option_t* option=&quot;&quot;)">AutoSave</a> is automatically called by <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a> when the number of bytes
   generated since the previous <a href="./TTree.html#TTree:AutoSave" title="Long64_t TTree::AutoSave(Option_t* option=&quot;&quot;)">AutoSave</a> is greater than <a href="./TTree.html#TTree:fAutoSave" title="Long64_t TTree::fAutoSave">fAutoSave</a> bytes.
   This function may also be invoked by the user, for example every
   N entries.
   Each <a href="./TTree.html#TTree:AutoSave" title="Long64_t TTree::AutoSave(Option_t* option=&quot;&quot;)">AutoSave</a> generates a new key on the file.
   Once the key with the tree header has been written, the previous cycle
   (if any) is deleted.

   Note that calling <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:AutoSave" title="Long64_t TTree::AutoSave(Option_t* option=&quot;&quot;)">AutoSave</a> too frequently (or similarly calling
   <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:SetAutoSave" title="void TTree::SetAutoSave(Long64_t autos=300000000)">SetAutoSave</a> with a small value) is an expensive operation.
   You should make tests for your own application to find a compromise
   between speed and the quantity of information you may loose in case of
   a job crash.

   In case your program crashes before closing the file holding this tree,
   the file will be automatically recovered when you will connect the file
   in UPDATE mode.
   The Tree will be recovered at the status corresponding to the last <a href="./TTree.html#TTree:AutoSave" title="Long64_t TTree::AutoSave(Option_t* option=&quot;&quot;)">AutoSave</a>.

   if option contains <span class="string">"SaveSelf"</span>, gDirectory-&gt;SaveSelf() is called.
   This allows another process to analyze the Tree while the Tree is being filled.

   if option contains <span class="string">"FlushBaskets"</span>, <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:FlushBaskets" title="Int_t TTree::FlushBaskets()">FlushBaskets</a> is called and all
   the current basket are closed-out and written to disk individually.

   By default the previous header is deleted after having written the new header.
   if option contains <span class="string">"Overwrite"</span>, the previous Tree header is deleted
   before written the new header. This option is slightly faster, but
   the default option is safer in case of a problem (disk quota exceeded)
   when writing the new header.

   The function returns the number of bytes written to the file.
   if the number of bytes is null, an error has occurred while writing
   the header to the file.

   How to write a Tree in one process and view it from another process

   The following two scripts illustrate how to do this.
   The script treew.C is executed by process1, treer.C by process2

   ----- script treew.C
   <a href="./ListOfTypes.html#void">void</a> treew() {
     <a href="./TFile.html">TFile</a> f(<span class="string">"test.root"</span>,<span class="string">"recreate"</span>);
     <a href="./TNtuple.html">TNtuple</a> *ntuple = new <a href="./TNtuple.html">TNtuple</a>(<span class="string">"ntuple"</span>,<span class="string">"Demo"</span>,<span class="string">"px:py:pz:random:i"</span>);
     <a href="./ListOfTypes.html#Float_t">Float_t</a> px, py, pz;
     for ( <a href="./ListOfTypes.html#Int_t">Int_t</a> i=0; i&lt;10000000; i++) {
        <a href="./TRandom.html">gRandom</a>-><a href="./TRandom.html#TRandom:Rannor" title="void TRandom::Rannor(Float_t&amp; a,Float_t&amp; b) or overloads">Rannor</a>(px,py);
        pz = px*px + py*py;
        <a href="./ListOfTypes.html#Float_t">Float_t</a> random = <a href="./TRandom.html">gRandom</a>-><a href="./TRandom.html#TRandom:Rndm" title="Double_t TRandom::Rndm(Int_t i=0)">Rndm</a>(1);
        ntuple-&gt;<a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a>(px,py,pz,random,i);
        if (i%1000 == 1) ntuple-&gt;<a href="./TTree.html#TTree:AutoSave" title="Long64_t TTree::AutoSave(Option_t* option=&quot;&quot;)">AutoSave</a>(<span class="string">"SaveSelf"</span>);
     }
   }

   ----- script treer.C
   <a href="./ListOfTypes.html#void">void</a> treer() {
      <a href="./TFile.html">TFile</a> f(<span class="string">"test.root"</span>);
      <a href="./TTree.html">TTree</a> *ntuple = (<a href="./TTree.html">TTree</a>*)f.Get(<span class="string">"ntuple"</span>);
      <a href="./TCanvas.html">TCanvas</a> c1;
      <a href="./ListOfTypes.html#Int_t">Int_t</a> first = 0;
      while(1) {
         if (first == 0) ntuple-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"px&gt;&gt;hpx"</span>, <span class="string">""</span>,<span class="string">""</span>,10000000,first);
         else            ntuple-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"px&gt;&gt;+hpx"</span>,<span class="string">""</span>,<span class="string">""</span>,10000000,first);
         first = (<a href="./ListOfTypes.html#Int_t">Int_t</a>)ntuple-&gt;<a href="./TTree.html#TTree:GetEntries" title="Long64_t TTree::GetEntries() or overloads">GetEntries</a>();
         c1.Update();
         <a href="./TSystem.html">gSystem</a>-><a href="./TSystem.html#TSystem:Sleep" title="void TSystem::Sleep(UInt_t milliSec)">Sleep</a>(1000); //sleep 1 second
         ntuple-&gt;<a href="./TTree.html#TTree:Refresh" title="void TTree::Refresh()">Refresh</a>();
      }
   }
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TBranch.html">TBranch</a>* <a class="funcname" name="TTree:BranchImp" href="src/TTree.cxx.html#jIE2_B">BranchImp</a>(<span class="keyword">const</span> <span class="keyword">char</span>* branchname, <span class="keyword">const</span> <span class="keyword">char</span>* classname, <a href="./TClass.html">TClass</a>* ptrClass, <span class="keyword">void</span>* addobj, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel)</span><br />
<div class="funccomm"><pre> Same as <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>() with added check that addobj matches className.

 See <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>() for other details.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TBranch.html">TBranch</a>* <a class="funcname" name="TTree:BranchImp%1" href="src/TTree.cxx.html#gFSHGC">BranchImp</a>(<span class="keyword">const</span> <span class="keyword">char</span>* branchname, <a href="./TClass.html">TClass</a>* ptrClass, <span class="keyword">void</span>* addobj, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel)</span><br />
<div class="funccomm"><pre> Same as <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> but automatic detection of the class name.
 See <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> for other details.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TBranch.html">TBranch</a>* <a class="funcname" name="TTree:BranchImpRef" href="src/TTree.cxx.html#DoHzrB">BranchImpRef</a>(<span class="keyword">const</span> <span class="keyword">char</span>* branchname, <span class="keyword">const</span> <span class="keyword">char</span>* classname, <a href="./TClass.html">TClass</a>* ptrClass, <span class="keyword">void</span>* addobj, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel)</span><br />
<div class="funccomm"><pre> Same as <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> but automatic detection of the class name.
 See <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> for other details.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TBranch.html">TBranch</a>* <a class="funcname" name="TTree:BranchImpRef%1" href="src/TTree.cxx.html#SvnaVB">BranchImpRef</a>(<span class="keyword">const</span> <span class="keyword">char</span>* branchname, <a href="./TClass.html">TClass</a>* ptrClass, EDataType datatype, <span class="keyword">void</span>* addobj, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel)</span><br />
<div class="funccomm"><pre> Same as <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> but automatic detection of the class name.
 See <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> for other details.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:Branch%1" href="src/TTree.cxx.html#ACSoLE">Branch</a>(<a href="./TList.html">TList</a>* list, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel = 99)</span><br />
<div class="funccomm"><pre> Deprecated function. Use next function instead.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:Branch" href="src/TTree.cxx.html#NWuSmD">Branch</a>(<a href="./TCollection.html">TCollection</a>* list, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel = 99, <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre> Create one branch for each element in the collection.

   Each entry in the collection becomes a top level branch if the
   corresponding class is not a collection. If it is a collection, the entry
   in the collection becomes in turn top level branches, etc.
   The splitlevel is decreased by 1 every time a new collection is found.
   For example if list is a <a href="./TObjArray.html">TObjArray</a>*
     - if splitlevel = 1, one top level branch is created for each element
        of the <a href="./TObjArray.html">TObjArray</a>.
     - if splitlevel = 2, one top level branch is created for each array element.
       if, in turn, one of the array elements is a <a href="./TCollection.html">TCollection</a>, one top level
       branch will be created for each element of this collection.

   In case a collection element is a <a href="./TClonesArray.html">TClonesArray</a>, the special Tree constructor
   for <a href="./TClonesArray.html">TClonesArray</a> is called.
   The collection itself cannot be a <a href="./TClonesArray.html">TClonesArray</a>.

   The function returns the total number of branches created.

   If name is given, all branch names will be prefixed with name_.

 IMPORTANT NOTE1: This function should not be called with splitlevel &lt; 1.

 IMPORTANT NOTE2: The branches created by this function will have names
 corresponding to the collection or object names. It is important
 to give names to collections to avoid misleading branch names or
 identical branch names. By default collections have a name equal to
 the corresponding class name, e.g. the default name for a <a href="./TList.html">TList</a> is <span class="string">"TList"</span>.

 Example--------------------------------------------------------------:

   {
         <a href="./TTree.html">TTree</a> T(<span class="string">"T"</span>,<span class="string">"test list"</span>);
         <a href="./TList.html">TList</a> *list = new <a href="./TList.html">TList</a>();

         <a href="./TObjArray.html">TObjArray</a> *a1 = new <a href="./TObjArray.html">TObjArray</a>();
         a1-&gt;<a href="./TTree.html#TTree:SetName" title="void TTree::SetName(const char* name)">SetName</a>(<span class="string">"a1"</span>);
         list-&gt;Add(a1);
         <a href="./TH1F.html">TH1F</a> *ha1a = new <a href="./TH1F.html">TH1F</a>(<span class="string">"ha1a"</span>,<span class="string">"ha1"</span>,100,0,1);
         <a href="./TH1F.html">TH1F</a> *ha1b = new <a href="./TH1F.html">TH1F</a>(<span class="string">"ha1b"</span>,<span class="string">"ha1"</span>,100,0,1);
         a1-&gt;Add(ha1a);
         a1-&gt;Add(ha1b);
         <a href="./TObjArray.html">TObjArray</a> *b1 = new <a href="./TObjArray.html">TObjArray</a>();
         b1-&gt;<a href="./TTree.html#TTree:SetName" title="void TTree::SetName(const char* name)">SetName</a>(<span class="string">"b1"</span>);
         list-&gt;Add(b1);
         <a href="./TH1F.html">TH1F</a> *hb1a = new <a href="./TH1F.html">TH1F</a>(<span class="string">"hb1a"</span>,<span class="string">"hb1"</span>,100,0,1);
         <a href="./TH1F.html">TH1F</a> *hb1b = new <a href="./TH1F.html">TH1F</a>(<span class="string">"hb1b"</span>,<span class="string">"hb1"</span>,100,0,1);
         b1-&gt;Add(hb1a);
         b1-&gt;Add(hb1b);

         <a href="./TObjArray.html">TObjArray</a> *a2 = new <a href="./TObjArray.html">TObjArray</a>();
         a2-&gt;<a href="./TTree.html#TTree:SetName" title="void TTree::SetName(const char* name)">SetName</a>(<span class="string">"a2"</span>);
         list-&gt;Add(a2);
         <a href="./TH1S.html">TH1S</a> *ha2a = new <a href="./TH1S.html">TH1S</a>(<span class="string">"ha2a"</span>,<span class="string">"ha2"</span>,100,0,1);
         <a href="./TH1S.html">TH1S</a> *ha2b = new <a href="./TH1S.html">TH1S</a>(<span class="string">"ha2b"</span>,<span class="string">"ha2"</span>,100,0,1);
         a2-&gt;Add(ha2a);
         a2-&gt;Add(ha2b);

         T.<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>(list,16000,2);
         T.<a href="./TTree.html#TTree:Print" title="void TTree::Print(Option_t* option=&quot;&quot;)">Print</a>();
   }


</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:Branch%2" href="src/TTree.cxx.html#WlTL8D">Branch</a>(<span class="keyword">const</span> <span class="keyword">char</span>* folder, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel = 99)</span><br />
<div class="funccomm"><pre> Create one branch for each element in the folder.
 Returns the total number of branches created.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TBranch.html">TBranch</a>* <a class="funcname" name="TTree:Branch%3" href="src/TTree.cxx.html#nsV.s">Branch</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">void</span>* address, <span class="keyword">const</span> <span class="keyword">char</span>* leaflist, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000)</span><br />
<div class="funccomm"><pre> Create a new <a href="./TTree.html">TTree</a> <a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>.

    This <a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> constructor is provided to support non-objects in
    a Tree. The variables described in leaflist may be simple
    variables or structures.  // See the two following
    constructors for writing objects in a Tree.

    By default the branch buffers are stored in the same file as the Tree.
    use <a href="./TBranch.html">TBranch</a>::<a href="./TBranch.html#TBranch:SetFile" title="void TBranch::SetFile(TFile* file=0) or overloads">SetFile</a> to specify a different file

       * address is the address of the first item of a structure.
       * leaflist is the concatenation of all the variable names and types
         separated by a colon character :
         The variable name and the variable type are separated by a slash (/).
         The variable type may be 0,1 or 2 characters. If no type is given,
         the type of the variable is assumed to be the same as the previous
         variable. If the first variable does not have a type, it is assumed
         of type F by default. The list of currently supported types is given below:
            - C : a character string terminated by the 0 character
            - B : an 8 bit signed integer (<a href="./ListOfTypes.html#Char_t">Char_t</a>)
            - b : an 8 bit <a href="./ListOfTypes.html#unsigned">unsigned</a> integer (<a href="./ListOfTypes.html#UChar_t">UChar_t</a>)
            - S : a 16 bit signed integer (<a href="./ListOfTypes.html#Short_t">Short_t</a>)
            - s : a 16 bit <a href="./ListOfTypes.html#unsigned">unsigned</a> integer (<a href="./ListOfTypes.html#UShort_t">UShort_t</a>)
            - I : a 32 bit signed integer (<a href="./ListOfTypes.html#Int_t">Int_t</a>)
            - i : a 32 bit <a href="./ListOfTypes.html#unsigned">unsigned</a> integer (<a href="./ListOfTypes.html#UInt_t">UInt_t</a>)
            - F : a 32 bit floating point (<a href="./ListOfTypes.html#Float_t">Float_t</a>)
            - D : a 64 bit floating point (<a href="./ListOfTypes.html#Double_t">Double_t</a>)
            - L : a 64 bit signed integer (<a href="./ListOfTypes.html#Long64_t">Long64_t</a>)
            - l : a 64 bit <a href="./ListOfTypes.html#unsigned">unsigned</a> integer (<a href="./ListOfTypes.html#ULong64_t">ULong64_t</a>)
            - O : [the letter <span class="string">'o'</span>, not a zero] a boolean (<a href="./ListOfTypes.html#Bool_t">Bool_t</a>)

         Arrays of values are supported with the following syntax:
         If leaf name has the form var[nelem], where nelem is alphanumeric, then
            if nelem is a leaf name, it is used as the variable size of the array,
            otherwise return 0.
         If leaf name has the form var[nelem], where nelem is a non-negative integer, then
            it is used as the fixed size of the array.
         If leaf name has the form of a multi-dimensional array (e.g. var[nelem][nelem2])
            where nelem and nelem2 are non-negative integer) then
            it is used as a 2 dimensional array of fixed size.
         Any of other form is not supported.

    Note that the <a href="./TTree.html">TTree</a> will assume that all the item are contiguous in memory.
    On some platform, this is not always <a href="./ListOfTypes.html#bool">true</a> of the member of a struct or a class,
    due to padding and alignment.  Sorting your data member in order of decreasing
    sizeof usually leads to their being contiguous in memory.

       * bufsize is the buffer size in bytes for this branch
         The default value is 32000 bytes and should be ok for most cases.
         You can specify a larger value (e.g. 256000) if your Tree is not split
         and each entry is large (Megabytes)
         A small value for bufsize is optimum if you intend to access
         the entries in the Tree randomly and your Tree is in split mode.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TBranch.html">TBranch</a>* <a class="funcname" name="TTree:Branch%7" href="src/TTree.cxx.html#jOSXhE">Branch</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* classname, <span class="keyword">void</span>** obj, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel = 99)</span><br />
<div class="funccomm"><pre> Create a new branch with the object of class classname at address addobj.

 WARNING:
 Starting with Root version 3.01, the <a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> function uses the new style
 branches (<a href="./TBranchElement.html">TBranchElement</a>). To get the old behaviour, you can:
   - call <a href="./TTree.html#TTree:BranchOld" title="TBranch* TTree::BranchOld(const char* name,const char* classname,void* addobj,Int_t bufsize=32000,Int_t splitlevel=1)">BranchOld</a> or
   - call <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:SetBranchStyle" title="void TTree::SetBranchStyle(Int_t style=1)">SetBranchStyle</a>(0)

 Note that with the new style, classname does not need to derive from <a href="./TObject.html">TObject</a>.
 It must derived from <a href="./TObject.html">TObject</a> if the branch style has been set to 0 (old)

 Note: See the comments in <a href="./TBranchElement.html">TBranchElement</a>::<a href="./TBranchElement.html#TBranchElement:SetAddress" title="void TBranchElement::SetAddress(void* addobj)">SetAddress</a>() for a more
       detailed discussion of the meaning of the addobj parameter in
       the case of new-style branches.

 Use splitlevel &lt; 0 instead of splitlevel=0 when the class
 has a custom <a href="./TTree.html#TTree:Streamer" title="void TTree::Streamer(TBuffer&amp; b)">Streamer</a>

 Note: if the split level is set to the default (99),  <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> will
 not issue a warning if the class can not be split.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TBranch.html">TBranch</a>* <a class="funcname" name="TTree:BranchOld" href="src/TTree.cxx.html#nbMnRC">BranchOld</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* classname, <span class="keyword">void</span>* addobj, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel = 1)</span><br />
<div class="funccomm"><pre> Create a new <a href="./TTree.html">TTree</a> BranchObject.

    Build a <a href="./TBranchObject.html">TBranchObject</a> for an object of class classname.
    addobj is the address of a pointer to an object of class classname.
    IMPORTANT: classname must derive from <a href="./TObject.html">TObject</a>.
    The class dictionary must be available (ClassDef in class header).

    This option requires access to the library where the corresponding class
    is defined. Accessing one single data member in the object implies
    reading the full object.
    See the next <a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> constructor for a more efficient storage
    in case the entry consists of arrays of identical objects.

    By default the branch buffers are stored in the same file as the Tree.
    use <a href="./TBranch.html">TBranch</a>::<a href="./TBranch.html#TBranch:SetFile" title="void TBranch::SetFile(TFile* file=0) or overloads">SetFile</a> to specify a different file

      IMPORTANT NOTE about branch names
    In case two or more master branches contain subbranches with
    identical names, one must add a <span class="string">"."</span> (dot) character at the end
    of the master branch name. This will force the name of the subbranch
    to be master.subbranch instead of simply subbranch.
    This situation happens when the top level object (say event)
    has two or more members referencing the same class.
    For example, if a Tree has two branches B1 and B2 corresponding
    to objects of the same class MyClass, one can do:
       tree.<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>(<span class="string">"B1."</span>,<span class="string">"MyClass"</span>,&amp;b1,8000,1);
       tree.<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>(<span class="string">"B2."</span>,<span class="string">"MyClass"</span>,&amp;b2,8000,1);
    if MyClass has 3 members a,b,c, the two instructions above will generate
    subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c

    bufsize is the buffer size in bytes for this branch
    The default value is 32000 bytes and should be ok for most cases.
    You can specify a larger value (e.g. 256000) if your Tree is not split
    and each entry is large (Megabytes)
    A small value for bufsize is optimum if you intend to access
    the entries in the Tree randomly and your Tree is in split mode.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TBranch.html">TBranch</a>* <a class="funcname" name="TTree:BranchRef" href="src/TTree.cxx.html#z7tO.C">BranchRef</a>()</span><br />
<div class="funccomm"><pre> Build the optional branch supporting the <a href="./TRefTable.html">TRefTable</a>.
 This branch will keep all the information to find the branches
 containing referenced objects.

 At each Tree::<a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a>, the branch numbers containing the
 referenced objects are saved to the <a href="./TBranchRef.html">TBranchRef</a> basket.
 When the Tree header is saved (via <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Write" title="Int_t TTree::Write(const char* name=0,Int_t option=0,Int_t bufsize=0) or overloads">Write</a>), the branch
 is saved keeping the information with the pointers to the branches
 having referenced objects.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TBranch.html">TBranch</a>* <a class="funcname" name="TTree:Bronch" href="src/TTree.cxx.html#EVG5JC">Bronch</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* classname, <span class="keyword">void</span>* addobj, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel = 99)</span><br />
<div class="funccomm"><pre> Create a new <a href="./TTree.html">TTree</a> BranchElement.

    WARNING about this new function

    This function is designed to replace the function <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> above.
    This function is far more powerful than the <a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> function.
    It supports the full C++, including STL and has the same behaviour
    in split or non-split mode. classname does not have to derive from <a href="./TObject.html">TObject</a>.
    The function is based on the new <a href="./TStreamerInfo.html">TStreamerInfo</a>.

    Build a <a href="./TBranchElement.html">TBranchElement</a> for an object of class classname.

    addr is the address of a pointer to an object of class classname.
    The class dictionary must be available (ClassDef in class header).

    Note: See the comments in <a href="./TBranchElement.html">TBranchElement</a>::<a href="./TBranchElement.html#TBranchElement:SetAddress" title="void TBranchElement::SetAddress(void* addobj)">SetAddress</a>() for a more
          detailed discussion of the meaning of the addr parameter.

    This option requires access to the library where the corresponding class
    is defined. Accessing one single data member in the object implies
    reading the full object.

    By default the branch buffers are stored in the same file as the Tree.
    use <a href="./TBranch.html">TBranch</a>::<a href="./TBranch.html#TBranch:SetFile" title="void TBranch::SetFile(TFile* file=0) or overloads">SetFile</a> to specify a different file

      IMPORTANT NOTE about branch names
    In case two or more master branches contain subbranches with
    identical names, one must add a <span class="string">"."</span> (dot) character at the end
    of the master branch name. This will force the name of the subbranch
    to be master.subbranch instead of simply subbranch.
    This situation happens when the top level object (say event)
    has two or more members referencing the same class.
    For example, if a Tree has two branches B1 and B2 corresponding
    to objects of the same class MyClass, one can do:
       tree.<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>(<span class="string">"B1."</span>,<span class="string">"MyClass"</span>,&amp;b1,8000,1);
       tree.<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>(<span class="string">"B2."</span>,<span class="string">"MyClass"</span>,&amp;b2,8000,1);
    if MyClass has 3 members a,b,c, the two instructions above will generate
    subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c

    bufsize is the buffer size in bytes for this branch
    The default value is 32000 bytes and should be ok for most cases.
    You can specify a larger value (e.g. 256000) if your Tree is not split
    and each entry is large (Megabytes)
    A small value for bufsize is optimum if you intend to access
    the entries in the Tree randomly and your Tree is in split mode.

    Use splitlevel &lt; 0 instead of splitlevel=0 when the class
    has a custom <a href="./TTree.html#TTree:Streamer" title="void TTree::Streamer(TBuffer&amp; b)">Streamer</a>

    Note: if the split level is set to the default (99),  <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> will
    not issue a warning if the class can not be split.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TBranch.html">TBranch</a>* <a class="funcname" name="TTree:BronchExec" href="src/TTree.cxx.html#aRKvIC">BronchExec</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* classname, <span class="keyword">void</span>* addobj, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> isptrptr, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel)</span><br />
<div class="funccomm"><pre> Helper function implementing <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Bronch" title="TBranch* TTree::Bronch(const char* name,const char* classname,void* addobj,Int_t bufsize=32000,Int_t splitlevel=99)">Bronch</a> and <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>(const <a href="./ListOfTypes.html#char">char</a> *name, T &amp;obj);
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:Browse" href="src/TTree.cxx.html#rO9YU">Browse</a>(<a href="./TBrowser.html">TBrowser</a>* )</span><br />
<div class="funccomm"><pre> <a href="./TTree.html#TTree:Browse" title="void TTree::Browse(TBrowser* )">Browse</a> content of the <a href="./TTree.html">TTree</a>.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:BuildIndex" href="src/TTree.cxx.html#PxHPmD">BuildIndex</a>(<span class="keyword">const</span> <span class="keyword">char</span>* majorname, <span class="keyword">const</span> <span class="keyword">char</span>* minorname = <span class="string">"0"</span>)</span><br />
<div class="funccomm"><pre> Build a Tree Index (default is <a href="./TTreeIndex.html">TTreeIndex</a>).
 See a description of the parameters and functionality in
 <a href="./TTreeIndex.html">TTreeIndex</a>::<a href="./TTreeIndex.html#TTreeIndex:TTreeIndex" title="TTreeIndex TTreeIndex::TTreeIndex() or overloads">TTreeIndex</a>().

 The return value is the number of entries in the Index (&lt; 0 indicates failure).

 A <a href="./TTreeIndex.html">TTreeIndex</a> object pointed by <a href="./TTree.html#TTree:fTreeIndex" title="TVirtualIndex* TTree::fTreeIndex">fTreeIndex</a> is created.
 This object will be automatically deleted by the <a href="./TTree.html">TTree</a> destructor.
 See also comments in <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:SetTreeIndex" title="void TTree::SetTreeIndex(TVirtualIndex* index)">SetTreeIndex</a>().
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TStreamerInfo.html">TStreamerInfo</a>* <a class="funcname" name="TTree:BuildStreamerInfo" href="src/TTree.cxx.html#dI0pTD">BuildStreamerInfo</a>(<a href="./TClass.html">TClass</a>* cl, <span class="keyword">void</span>* pointer = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> canOptimize = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</span><br />
<div class="funccomm"><pre> Build StreamerInfo for class cl.
 pointer is an optional argument that may contain a pointer to an object of cl.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TFile.html">TFile</a>* <a class="funcname" name="TTree:ChangeFile" href="src/TTree.cxx.html#gKKsuD">ChangeFile</a>(<a href="./TFile.html">TFile</a>* file)</span><br />
<div class="funccomm"><pre> Called by <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a>() when file has reached its maximum <a href="./TTree.html#TTree:fgMaxTreeSize" title="Long64_t TTree::fgMaxTreeSize">fgMaxTreeSize</a>.
 Create a new file. If the original file is named <span class="string">"myfile.root"</span>,
 subsequent files are named <span class="string">"myfile_1.root"</span>, <span class="string">"myfile_2.root"</span>, etc.

 Returns a pointer to the new file.

 Currently, the automatic change of file is restricted
 to the case where the tree is in the top level directory.
 The file should not contain sub-directories.

 Before switching to a new file, the tree header is written
 to the current file, then the current file is closed.

 To process the multiple files created by <a href="./TTree.html#TTree:ChangeFile" title="TFile* TTree::ChangeFile(TFile* file)">ChangeFile</a>, one must use
 a <a href="./TChain.html">TChain</a>.

 The new file name has a suffix <span class="string">"_N"</span> where N is equal to <a href="./TTree.html#TTree:fFileNumber" title="Int_t TTree::fFileNumber">fFileNumber</a>+1.
 By default a Root session starts with <a href="./TTree.html#TTree:fFileNumber" title="Int_t TTree::fFileNumber">fFileNumber</a>=0. One can set
 <a href="./TTree.html#TTree:fFileNumber" title="Int_t TTree::fFileNumber">fFileNumber</a> to a different value via <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:SetFileNumber" title="void TTree::SetFileNumber(Int_t number=0)">SetFileNumber</a>.
 In case a file named <span class="string">"_N"</span> already exists, the function will try
 a file named <span class="string">"__N"</span>, then <span class="string">"___N"</span>, etc.

 <a href="./TTree.html#TTree:fgMaxTreeSize" title="Long64_t TTree::fgMaxTreeSize">fgMaxTreeSize</a> can be set via the static function <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:SetMaxTreeSize" title="void TTree::SetMaxTreeSize(Long64_t maxsize=1900000000)">SetMaxTreeSize</a>.
 The default value of <a href="./TTree.html#TTree:fgMaxTreeSize" title="Long64_t TTree::fgMaxTreeSize">fgMaxTreeSize</a> is 100 Gigabytes.

 If the current file contains other objects like <a href="./TH1.html">TH1</a> and <a href="./TTree.html">TTree</a>,
 these objects are automatically moved to the new file.

 IMPORTANT NOTE:
 Be careful when writing the final Tree header to the file!
 Don't do:
  <a href="./TFile.html">TFile</a> *file = new <a href="./TFile.html">TFile</a>(<span class="string">"myfile.root"</span>,<span class="string">"recreate"</span>);
  <a href="./TTree.html">TTree</a> *T = new <a href="./TTree.html">TTree</a>(<span class="string">"T"</span>,<span class="string">"title"</span>);
  T-&gt;<a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a>(); //loop
  file-&gt;<a href="./TTree.html#TTree:Write" title="Int_t TTree::Write(const char* name=0,Int_t option=0,Int_t bufsize=0) or overloads">Write</a>();
  file-&gt;Close();
 but do the following:
  <a href="./TFile.html">TFile</a> *file = new <a href="./TFile.html">TFile</a>(<span class="string">"myfile.root"</span>,<span class="string">"recreate"</span>);
  <a href="./TTree.html">TTree</a> *T = new <a href="./TTree.html">TTree</a>(<span class="string">"T"</span>,<span class="string">"title"</span>);
  T-&gt;<a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a>(); //loop
  file = T-&gt;<a href="./TTree.html#TTree:GetCurrentFile" title="TFile* TTree::GetCurrentFile()">GetCurrentFile</a>(); //to get the pointer to the current file
  file-&gt;<a href="./TTree.html#TTree:Write" title="Int_t TTree::Write(const char* name=0,Int_t option=0,Int_t bufsize=0) or overloads">Write</a>();
  file-&gt;Close();
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:CheckBranchAddressType" href="src/TTree.cxx.html#FEwM8D">CheckBranchAddressType</a>(<a href="./TBranch.html">TBranch</a>* branch, <a href="./TClass.html">TClass</a>* ptrClass, EDataType datatype, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> ptr)</span><br />
<div class="funccomm"><pre> Check whether or not the address described by the last 3 parameters
 matches the content of the branch. If a Data Model Evolution conversion
 is involved, reset the fInfo of the branch.
 The return values are:
  <a href="./TTree.html#TTree:kMissingBranch" title="const TTree::SetBranchAddressStatus TTree::kMissingBranch">kMissingBranch</a> (-5) : Missing branch
  <a href="./TTree.html#TTree:kInternalError" title="const TTree::SetBranchAddressStatus TTree::kInternalError">kInternalError</a> (-4) : Internal error (could not find the type corresponding to a data type number)
  <a href="./TTree.html#TTree:kMissingCompiledCollectionProxy" title="const TTree::SetBranchAddressStatus TTree::kMissingCompiledCollectionProxy">kMissingCompiledCollectionProxy</a> (-3) : Missing compiled collection proxy for a compiled collection
  <a href="./TTree.html#TTree:kMismatch" title="const TTree::SetBranchAddressStatus TTree::kMismatch">kMismatch</a> (-2) : Non-<a href="./TTree.html#TTree:Class" title="TClass* TTree::Class()">Class</a> Pointer type given does not match the type expected by the branch
  <a href="./TTree.html#TTree:kClassMismatch" title="const TTree::SetBranchAddressStatus TTree::kClassMismatch">kClassMismatch</a> (-1) : <a href="./TTree.html#TTree:Class" title="TClass* TTree::Class()">Class</a> Pointer type given does not match the type expected by the branch
  <a href="./TTree.html#TTree:kMatch" title="const TTree::SetBranchAddressStatus TTree::kMatch">kMatch</a> (0) : perfect match
  <a href="./TTree.html#TTree:kMatchConversion" title="const TTree::SetBranchAddressStatus TTree::kMatchConversion">kMatchConversion</a> (1) : match with (I/O) conversion
  <a href="./TTree.html#TTree:kMatchConversionCollection" title="const TTree::SetBranchAddressStatus TTree::kMatchConversionCollection">kMatchConversionCollection</a> (2) : match with (I/O) conversion of the content of a collection
  <a href="./TTree.html#TTree:kMakeClass" title="const TTree::SetBranchAddressStatus TTree::kMakeClass">kMakeClass</a> (3) : <a href="./TTree.html#TTree:MakeClass" title="Int_t TTree::MakeClass(const char* classname=0,Option_t* option=&quot;&quot;)">MakeClass</a> mode so we can not check.
  <a href="./TTree.html#TTree:kVoidPtr" title="const TTree::SetBranchAddressStatus TTree::kVoidPtr">kVoidPtr</a> (4) : <a href="./ListOfTypes.html#void">void</a>* passed so no check was made.
  <a href="./TTree.html#TTree:kNoCheck" title="const TTree::SetBranchAddressStatus TTree::kNoCheck">kNoCheck</a> (5) : Underlying <a href="./TBranch.html">TBranch</a> not yet available so no check was made.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TTree.html">TTree</a>* <a class="funcname" name="TTree:CloneTree" href="src/TTree.cxx.html#AKvpTD">CloneTree</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = -1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre> Create a clone of this tree and copy nentries.

 By default copy all entries.
 Note that only active branches are copied.
 The compression level of the cloned tree is set to the destination file's
 compression level.

 IMPORTANT: The cloned tree stays connected with this tree until this tree
            is deleted.  In particular, any changes in branch addresses
            in this tree are forwarded to the clone trees, unless a branch
            in a clone tree has had its address changed, in which case
            that change stays in effect.  When this tree is deleted, all the
            addresses of the cloned tree are reset to their default values.

 If 'option' contains the word 'fast' and nentries is -1, the cloning will be
 done without unzipping or unstreaming the baskets (i.e., a direct copy of the
 raw bytes on disk).

 When 'fast' is specified, 'option' can also contains a
 sorting order for the baskets in the output file.

 There are currently 3 supported sorting order:
    SortBasketsByOffset (the default)
    SortBasketsByBranch
    SortBasketsByEntry

 When using SortBasketsByOffset the baskets are written in
 the output file in the same order as in the original file
 (i.e. the basket are sorted on their offset in the original
 file; Usually this also means that the baskets are sorted
 on the index/number of the _last_ entry they contain)

 When using SortBasketsByBranch all the baskets of each
 individual branches are stored contiguously.  This tends to
 optimize reading speed when reading a small number (1-&gt;5) of
 branches, since all their baskets will be clustered together
 instead of being spread across the file.  However it might
 decrease the performance when reading more branches (or the full
 entry).

 When using SortBasketsByEntry the baskets with the lowest
 starting entry are written first.  (i.e. the baskets are
 sorted on the index/number of the first entry they contain).
 This means that on the file the baskets will be in the order
 in which they will be needed when reading the whole tree
 sequentially.

 For examples of <a href="./TTree.html#TTree:CloneTree" title="TTree* TTree::CloneTree(Long64_t nentries=-1,Option_t* option=&quot;&quot;)">CloneTree</a>, see tutorials:

  -- copytree

     A macro to copy a subset of a <a href="./TTree.html">TTree</a> to a new <a href="./TTree.html">TTree</a>.

     The input file has been generated by the program in $ROOTSYS/test/Event
     with:  Event 1000 1 1 1

  -- copytree2

     A macro to copy a subset of a <a href="./TTree.html">TTree</a> to a new <a href="./TTree.html">TTree</a>.

     One branch of the new Tree is written to a separate file.

     The input file has been generated by the program in $ROOTSYS/test/Event
     with:  Event 1000 1 1 1

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:CopyAddresses" href="src/TTree.cxx.html#h77UnD">CopyAddresses</a>(<a href="./TTree.html">TTree</a>* , <a href="./ListOfTypes.html#Bool_t">Bool_t</a> undo = <a href="./ListOfTypes.html#Bool_t">kFALSE</a>)</span><br />
<div class="funccomm"><pre> Set branch addresses of passed tree equal to ours.
 If undo is <a href="./ListOfTypes.html#bool">true</a>, reset the branch address instead of copying them.
    This insures 'separation' of a cloned tree from its original
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:CopyEntries" href="src/TTree.cxx.html#qzzbT">CopyEntries</a>(<a href="./TTree.html">TTree</a>* tree, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = -1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre> <a href="./TNamed.html#TNamed:Copy" title="void TNamed::Copy(TObject&amp; named)">Copy</a> nentries from given tree to this tree.
 This routines assumes that the branches that intended to be copied are
 already connected.   The typical case is that this tree was created using
 tree-&gt;<a href="./TTree.html#TTree:CloneTree" title="TTree* TTree::CloneTree(Long64_t nentries=-1,Option_t* option=&quot;&quot;)">CloneTree</a>(0).

 By default copy all entries.

 Returns number of bytes copied to this tree.

 If 'option' contains the word 'fast' and nentries is -1, the cloning will be
 done without unzipping or unstreaming the baskets (i.e., a direct copy of the
 raw bytes on disk).

 When 'fast' is specified, 'option' can also contains a sorting order for the
 baskets in the output file.

 There are currently 3 supported sorting order:
    SortBasketsByOffset (the default)
    SortBasketsByBranch
    SortBasketsByEntry

 See <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:CloneTree" title="TTree* TTree::CloneTree(Long64_t nentries=-1,Option_t* option=&quot;&quot;)">CloneTree</a> for a detailed explanation of the semantics of these 3 options.

 If the tree or any of the underlying tree of the chain has an index, that index and any
 index in the subsequent underlying <a href="./TTree.html">TTree</a> objects will be merged.

 There are currently three 'options' to control this merging:
    NoIndex             : all the <a href="./TTreeIndex.html">TTreeIndex</a> object are dropped.
    DropIndexOnError    : if any of the underlying <a href="./TTree.html">TTree</a> object do no have a <a href="./TTreeIndex.html">TTreeIndex</a>,
                          they are all dropped.
    AsIsIndexOnError [default]: In case of missing <a href="./TTreeIndex.html">TTreeIndex</a>, the resulting <a href="./TTree.html">TTree</a> index has gaps.
    BuildIndexOnError : If any of the underlying <a href="./TTree.html">TTree</a> object do no have a <a href="./TTreeIndex.html">TTreeIndex</a>,
                          all <a href="./TTreeIndex.html">TTreeIndex</a> are 'ignored' and the mising piece are rebuilt.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TTree.html">TTree</a>* <a class="funcname" name="TTree:CopyTree" href="src/TTree.cxx.html#zixzPD">CopyTree</a>(<span class="keyword">const</span> <span class="keyword">char</span>* selection, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)</span><br />
<div class="funccomm"><pre> <a href="./TNamed.html#TNamed:Copy" title="void TNamed::Copy(TObject&amp; named)">Copy</a> a tree with selection.

 IMPORTANT:

   The returned copied tree stays connected with the original tree
   until the original tree is deleted.  In particular, any changes
   to the branch addresses in the original tree are also made to
   the copied tree.  Any changes made to the branch addresses of the
   copied tree are overridden anytime the original tree changes its
   branch addresses.  When the original tree is deleted, all the
   branch addresses of the copied tree are set to zero.

 For examples of <a href="./TTree.html#TTree:CopyTree" title="TTree* TTree::CopyTree(const char* selection,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0)">CopyTree</a>, see the tutorials:

 copytree

 Example macro to copy a subset of a tree to a new tree.

 The input file was generated by running the program in
 $ROOTSYS/test/Event in this way:

      ./Event 1000 1 1 1

 copytree2

 Example macro to copy a subset of a tree to a new tree.

 One branch of the new tree is written to a separate file.

 The input file was generated by running the program in
 $ROOTSYS/test/Event in this way:

      ./Event 1000 1 1 1

 copytree3

 Example macro to copy a subset of a tree to a new tree.

 Only selected entries are copied to the new tree.
 NOTE that only the active branches are copied.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TBasket.html">TBasket</a>* <a class="funcname" name="TTree:CreateBasket" href="src/TTree.cxx.html#LQP6wB">CreateBasket</a>(<a href="./TBranch.html">TBranch</a>* )</span><br />
<div class="funccomm"><pre> Create a basket for this tree and given branch.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:Delete" href="src/TTree.cxx.html#aZnKyD">Delete</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre> <a href="./TTree.html#TTree:Delete" title="void TTree::Delete(Option_t* option=&quot;&quot;)">Delete</a> this tree from memory or/and disk.

  if option == <span class="string">"all"</span> delete Tree object from memory AND from disk
                     all baskets on disk are deleted. All keys with same name
                     are deleted.
  if option ==<span class="string">""</span> only Tree object in memory is deleted.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:DirectoryAutoAdd" href="src/TTree.cxx.html#v.DyeB">DirectoryAutoAdd</a>(<a href="./TDirectory.html">TDirectory</a>* )</span><br />
<div class="funccomm"><pre> Called by <a href="./TKey.html">TKey</a> and <a href="./TObject.html">TObject</a>::<a href="./TObject.html#TObject:Clone" title="TObject* TObject::Clone(const char* newname=&quot;&quot;)">Clone</a> to automatically add us to a directory
 when we are read from a file.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:Draw%1" href="src/TTree.cxx.html#w.GR.D">Draw</a>(<span class="keyword">const</span> <span class="keyword">char</span>* varexp, <span class="keyword">const</span> <a href="./TCut.html">TCut</a>&amp; selection, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)</span><br />
<div class="funccomm"><pre> <a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> expression varexp for specified entries.
 Returns -1 in case of error or number of selected events in case of success.

      This function accepts <a href="./TCut.html">TCut</a> objects as arguments.
      Useful to use the string operator +
         example:
            ntuple.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"x"</span>,cut1+cut2+cut3);

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:Draw%2" href="src/TTree.cxx.html#olnuUC">Draw</a>(<span class="keyword">const</span> <span class="keyword">char</span>* varexp, <span class="keyword">const</span> <span class="keyword">char</span>* selection, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)</span><br />
<div class="funccomm"><pre> <a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> expression varexp for specified entries.
 Returns -1 in case of error or number of selected events in case of success.

  varexp is an expression of the general form
   - <span class="string">"e1"</span>           produces a 1-d histogram (<a href="./TH1F.html">TH1F</a>) of expression <span class="string">"e1"</span>
   - <span class="string">"e1:e2"</span>        produces an unbinned 2-d scatter-plot (<a href="./TGraph.html">TGraph</a>) of <span class="string">"e1"</span> versus <span class="string">"e2"</span>
   - <span class="string">"e1:e2:e3"</span>     produces an unbinned 3-d scatter-plot (<a href="./TPolyMarker3D.html">TPolyMarker3D</a>) of <span class="string">"e1"</span>
                    versus <span class="string">"e2"</span> versus <span class="string">"e3"</span>
   - <span class="string">"e1:e2:e3:e4"</span>  produces an unbinned 3-d scatter-plot (<a href="./TPolyMarker3D.html">TPolyMarker3D</a>) of <span class="string">"e1"</span>
                    versus <span class="string">"e2"</span> versus <span class="string">"e3"</span> and <span class="string">"e4"</span> mapped on the color number.
  (to create histograms in the 2, 3, and 4 dimesional case, see section <span class="string">"Saving</span>
  the result of <a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> to an histogram<span class="string">")</span>

  Example:
     varexp = x     simplest case: draw a 1-Dim distribution of column named x
            = sqrt(x)            : draw distribution of sqrt(x)
            = x*y/z
            = y:sqrt(x) 2-Dim distribution of y versus sqrt(x)
            = px:py:pz:2.5*E  produces a 3-d scatter-plot of px vs py ps pz
              and the color number of each marker will be 2.5*E.
              If the color number is negative it is set to 0.
              If the color number is greater than the current number of colors
                 it is set to the highest color number.
              The default number of colors is 50.
              see <a href="./TStyle.html">TStyle</a>::<a href="./TStyle.html#TStyle:SetPalette" title="void TStyle::SetPalette(Int_t ncolors=0,Int_t* colors=0)">SetPalette</a> for setting a new color palette.

  Note that the variables e1, e2 or e3 may contain a selection.
  example, if e1= x*(y&lt;0), the value histogrammed will be x if y&lt;0
  and will be 0 otherwise.

  The expressions can use all the operations and build-in functions
  supported by <a href="./TFormula.html">TFormula</a> (See <a href="./TFormula.html">TFormula</a>::<a href="./TFormula.html#TFormula:Analyze" title="void TFormula::Analyze(const char* schain,Int_t&amp; err,Int_t offset=0)">Analyze</a>), including free
  standing function taking numerical arguments (<a href="./TMath.html">TMath</a>::Bessel).
  In addition, you can call member functions taking numerical
  arguments. For example:
      - <span class="string">"TMath::BreitWigner(fPx,3,2)"</span>
      - <span class="string">"event.GetHistogram().GetXaxis().GetXmax()"</span>
  Note: You can only pass expression that depend on the <a href="./TTree.html">TTree</a>'s data
  to static functions and you can only call non-static member function
  with 'fixed' parameters.

  selection is an expression with a combination of the columns.
  In a selection all the C++ operators are authorized.
  The value corresponding to the selection expression is used as a weight
  to fill the histogram.
  If the expression includes only boolean operations, the result
  is 0 or 1. If the result is 0, the histogram is not filled.
  In general, the expression may be of the form:
      value*(boolean expression)
  if boolean expression is <a href="./ListOfTypes.html#bool">true</a>, the histogram is filled with
  a weight = value.
  Examples:
      selection1 = <span class="string">"x&lt;y &amp;&amp; sqrt(z)&gt;3.2"</span>
      selection2 = <span class="string">"(x+y)*(sqrt(z)&gt;3.2)"</span>
  selection1 returns a weigth = 0 or 1
  selection2 returns a weight = x+y if sqrt(z)&gt;3.2
             returns a weight = 0 otherwise.

  option is the drawing option.
    - See <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Draw" title="void TH1::Draw(Option_t* option=&quot;&quot;)">Draw</a> for the list of all drawing options.
    - If option COL is specified when varexp has three fields:
            tree.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"e1:e2:e3"</span>,<span class="string">""</span>,<span class="string">"col"</span>);
      a 2D scatter is produced with e1 vs e2, and e3 is mapped on the color
      table.
    - If option contains the string <span class="string">"goff"</span>, no graphics is generated.

  nentries is the number of entries to process (default is all)
  first is the first entry to process (default is 0)

  This function returns the number of selected entries. It returns -1
  if an error occurs.

     Drawing expressions using arrays and array elements

 Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array,
 or a <a href="./TClonesArray.html">TClonesArray</a>.
 In a <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> expression you can now access fMatrix using the following
 syntaxes:

   String passed    What is used for each entry of the tree

   <span class="string">"fMatrix"</span>       the 9 elements of fMatrix
   <span class="string">"fMatrix[][]"</span>   the 9 elements of fMatrix
   <span class="string">"fMatrix[2][2]"</span> only the elements fMatrix[2][2]
   <span class="string">"fMatrix[1]"</span>    the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]
   <span class="string">"fMatrix[1][]"</span>  the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]
   <span class="string">"fMatrix[][0]"</span>  the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0]

   <span class="string">"fEvent.fMatrix...."</span> same as <span class="string">"fMatrix..."</span> (unless there is more than one leaf named fMatrix!).

 In summary, if a specific index is not specified for a dimension, <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>
 will loop through all the indices along this dimension.  Leaving off the
 last (right most) dimension of specifying then with the two characters '[]'
 is equivalent.  For variable size arrays (and <a href="./TClonesArray.html">TClonesArray</a>) the range
 of the first dimension is recalculated for each entry of the tree.
 You can also specify the index as an expression of any other variables from the
 tree.

 <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> also now properly handling operations involving 2 or more arrays.

 Let assume a second matrix fResults[5][2], here are a sample of some
 of the possible combinations, the number of elements they produce and
 the loop used:

  expression                       element(s)  Loop

  <span class="string">"fMatrix[2][1] - fResults[5][2]"</span>   one     no loop
  <span class="string">"fMatrix[2][]  - fResults[5][2]"</span>   three   on 2nd dim fMatrix
  <span class="string">"fMatrix[2][]  - fResults[5][]"</span>    two     on both 2nd dimensions
  <span class="string">"fMatrix[][2]  - fResults[][1]"</span>    three   on both 1st dimensions
  <span class="string">"fMatrix[][2]  - fResults[][]"</span>     six     on both 1st and 2nd dimensions of
                                             fResults
  <span class="string">"fMatrix[][2]  - fResults[3][]"</span>    two     on 1st dim of fMatrix and 2nd of
                                             fResults (at the same time)
  <span class="string">"fMatrix[][]   - fResults[][]"</span>     six     on 1st dim then on  2nd dim

  <span class="string">"fMatrix[][fResult[][]]"</span>           30      on 1st dim of fMatrix then on both
                                             dimensions of fResults.  The value
                                             if fResults[j][k] is used as the second
                                             index of fMatrix.


 In summary, <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> loops through all un-specified dimensions.  To
 figure out the range of each loop, we match each unspecified dimension
 from left to right (ignoring ALL dimensions for which an index has been
 specified), in the equivalent loop matched dimensions use the same index
 and are restricted to the smallest range (of only the matched dimensions).
 When involving variable arrays, the range can of course be different
 for each entry of the tree.

 So the loop equivalent to <span class="string">"fMatrix[][2] - fResults[3][]"</span> is:

    for (<a href="./ListOfTypes.html#Int_t">Int_t</a> i0; i &lt; min(3,2); i++) {
       use the value of (fMatrix[i0][2] - fMatrix[3][i0])
    }

 So the loop equivalent to <span class="string">"fMatrix[][2] - fResults[][]"</span> is:

    for (<a href="./ListOfTypes.html#Int_t">Int_t</a> i0; i &lt; min(3,5); i++) {
       for (<a href="./ListOfTypes.html#Int_t">Int_t</a> i1; i1 &lt; 2; i1++) {
          use the value of (fMatrix[i0][2] - fMatrix[i0][i1])
       }
    }

 So the loop equivalent to <span class="string">"fMatrix[][] - fResults[][]"</span> is:

    for (<a href="./ListOfTypes.html#Int_t">Int_t</a> i0; i &lt; min(3,5); i++) {
       for (<a href="./ListOfTypes.html#Int_t">Int_t</a> i1; i1 &lt; min(3,2); i1++) {
          use the value of (fMatrix[i0][i1] - fMatrix[i0][i1])
       }
    }

 So the loop equivalent to <span class="string">"fMatrix[][fResults[][]]"</span> is:

    for (<a href="./ListOfTypes.html#Int_t">Int_t</a> i0; i0 &lt; 3; i0++) {
       for (<a href="./ListOfTypes.html#Int_t">Int_t</a> j2; j2 &lt; 5; j2++) {
          for (<a href="./ListOfTypes.html#Int_t">Int_t</a> j3; j3 &lt; 2; j3++) {
             i1 = fResults[j2][j3];
             use the value of fMatrix[i0][i1]
       }
    }

     Retrieving the result of <a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>


  By default the temporary histogram created is called <span class="string">"htemp"</span>, but only in
  the one dimensional <a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"e1"</span>) it contains the <a href="./TTree.html">TTree</a>'s data points. For
  a two dimensional <a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>, the data is filled into a <a href="./TGraph.html">TGraph</a> which is named
  <span class="string">"Graph"</span>. They can be retrieved by calling
    <a href="./TH1F.html">TH1F</a> *htemp = (<a href="./TH1F.html">TH1F</a>*)gPad-&gt;GetPrimitive(<span class="string">"htemp"</span>); // 1D
    <a href="./TGraph.html">TGraph</a> *graph = (<a href="./TGraph.html">TGraph</a>*)gPad-&gt;GetPrimitive(<span class="string">"Graph"</span>); // 2D

  For a three and four dimensional <a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> the TPloyMarker3D is unnamed, and
  cannot be retrieved.

  gPad always contains a <a href="./TH1.html">TH1</a> derived object called <span class="string">"htemp"</span> which allows to
  access the axes:
    <a href="./TGraph.html">TGraph</a> *graph = (<a href="./TGraph.html">TGraph</a>*)gPad-&gt;GetPrimitive(<span class="string">"Graph"</span>); // 2D
    <a href="./TH2F.html">TH2F</a>   *htemp = (<a href="./TH2F.html">TH2F</a>*)gPad-&gt;GetPrimitive(<span class="string">"htemp"</span>); // empty, but has axes
    <a href="./TAxis.html">TAxis</a>  *xaxis = htemp-&gt;GetXaxis();

     Saving the result of <a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> to an histogram


  If varexp0 contains &gt;&gt;hnew (following the variable(s) name(s),
  the new histogram created is called hnew and it is kept in the current
  directory (and also the current pad). This works for all dimensions.
  Example:
    tree.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"sqrt(x)&gt;&gt;hsqrt"</span>,<span class="string">"y&gt;0"</span>)
    will draw sqrt(x) and save the histogram as <span class="string">"hsqrt"</span> in the current
    directory.  To retrieve it do:
    <a href="./TH1F.html">TH1F</a> *hsqrt = (<a href="./TH1F.html">TH1F</a>*)gDirectory-&gt;Get(<span class="string">"hsqrt"</span>);

  The binning information is taken from the environment variables

     Hist.Binning.?D.?

  In addition, the name of the histogram can be followed by up to 9
  numbers between <span class="string">'('</span> and <span class="string">')'</span>, where the numbers describe the
  following:

   1 - bins in x-direction
   2 - lower limit in x-direction
   3 - upper limit in x-direction
   4-6 same for y-direction
   7-9 same for z-direction

   When a new binning is used the new value will become the default.
   Values can be skipped.
  Example:
    tree.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"sqrt(x)&gt;&gt;hsqrt(500,10,20)"</span>)
          // plot sqrt(x) between 10 and 20 using 500 bins
    tree.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"sqrt(x):sin(y)&gt;&gt;hsqrt(100,10,60,50,.1,.5)"</span>)
          // plot sqrt(x) against sin(y)
          // 100 bins in x-direction; lower limit on x-axis is 10; upper limit is 60
          //  50 bins in y-direction; lower limit on y-axis is .1; upper limit is .5

  By default, the specified histogram is reset.
  To continue to append data to an existing histogram, use <span class="string">"+"</span> in front
  of the histogram name.
  A <span class="string">'+'</span> in front of the histogram name is ignored, when the name is followed by
  binning information as described in the previous paragraph.
    tree.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"sqrt(x)&gt;&gt;+hsqrt"</span>,<span class="string">"y&gt;0"</span>)
      will not reset hsqrt, but will continue filling.
  This works for 1-D, 2-D and 3-D histograms.

     Accessing collection objects


  <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> default's handling of collections is to assume that any
  request on a collection pertain to it content.  For example, if fTracks
  is a collection of Track objects, the following:
      tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"event.fTracks.fPx"</span>);
  will plot the value of fPx for each Track objects inside the collection.
  Also
     tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"event.fTracks.size()"</span>);
  would plot the result of the member function Track::size() for each
  Track object inside the collection.
  To access information about the collection itself, <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> support
  the <span class="string">'@'</span> notation.  If a variable which points to a collection is prefixed
  or postfixed with <span class="string">'@'</span>, the next part of the expression will pertain to
  the collection object.  For example:
     tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"event.@fTracks.size()"</span>);
  will plot the size of the collection refered to by fTracks (i.e the number
  of Track objects).

     Drawing 'objects'


  When a class has a member function named AsDouble or AsString, requesting
  to directly draw the object will imply a call to one of the 2 functions.
  If both AsDouble and AsString are present, AsDouble will be used.
  AsString can return either a <a href="./ListOfTypes.html#char">char</a>*, a std::string or a <a href="./TString.html">TString</a>.s
  For example, the following
     tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"event.myTTimeStamp"</span>);
  will draw the same histogram as
     tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"event.myTTimeStamp.AsDouble()"</span>);
  In addition, when the object is a type <a href="./TString.html">TString</a> or std::string, <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>
  will call respectively <a href="./TString.html">TString</a>::<a href="./TString.html#TString:Data" title="const char* TString::Data()">Data</a> and std::string::c_str()

  If the object is a <a href="./TBits.html">TBits</a>, the histogram will contain the index of the bit
  that are turned on.

     Retrieving  information about the tree itself.


  You can refer to the tree (or chain) containing the data by using the
  string 'This'.
  You can then could any <a href="./TTree.html">TTree</a> methods.  For example:
     tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"This-&gt;GetReadEntry()"</span>);
  will display the local entry numbers be read.
     tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"This-&gt;GetUserInfo()-&gt;At(0)-&gt;GetName()"</span>);
  will display the name of the first 'user info' object.

     Special functions and variables


  Entry$:  A <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> formula can use the special variable Entry$
  to access the entry number being read.  For example to draw every
  other entry use:
    tree.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"myvar"</span>,<span class="string">"Entry$%2==0"</span>);

  Entry$      : return the current entry number (== <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:GetReadEntry" title="Long64_t TTree::GetReadEntry()">GetReadEntry</a>())
  LocalEntry$ : return the current entry number in the current tree of a
                chain (== <a href="./TTree.html#TTree:GetTree" title="TTree* TTree::GetTree()">GetTree</a>()-><a href="./TTree.html#TTree:GetReadEntry" title="Long64_t TTree::GetReadEntry()">GetReadEntry</a>())
  Entries$    : return the total number of entries (== <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:GetEntries" title="Long64_t TTree::GetEntries() or overloads">GetEntries</a>())
  Length$     : return the total number of element of this formula for this
                 entry (==<a href="./TTreeFormula.html">TTreeFormula</a>::<a href="./TTreeFormula.html#TTreeFormula:GetNdata" title="Int_t TTreeFormula::GetNdata()">GetNdata</a>())
  Iteration$: return the current iteration over this formula for this
                 entry (i.e. varies from 0 to Length$).

  Length$(formula): return the total number of element of the formula given as a
                    parameter.
  Sum$(formula): return the sum of the value of the elements of the formula given
                    as a parameter.  For example the mean for all the elements in
                    one entry can be calculated with:
                Sum$(formula)/Length$(formula)
  Min$(formula): return the minimun (within one <a href="./TTree.html">TTree</a> entry) of the value of the
                    elements of the formula given as a parameter.
  Max$(formula): return the maximum (within one <a href="./TTree.html">TTree</a> entry) of the value of the
                    elements of the formula given as a parameter.
  MinIf$(formula,condition)
  MaxIf$(formula,condition): return the minimum (maximum) (within one <a href="./TTree.html">TTree</a> entry)
                    of the value of the elements of the formula given as a parameter
                    if they match the condition. If no element matches the condition,
                    the result is zero.  To avoid the resulting peak at zero, use the
                    pattern:
    tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"MinIf$(formula,condition)"</span>,<span class="string">"condition"</span>);
                    which will avoid calculation MinIf$ for the entries that have no match
                    for the condition.

  Alt$(primary,alternate) : return the value of <span class="string">"primary"</span> if it is available
                 for the current iteration otherwise return the value of <span class="string">"alternate"</span>.
                 For example, with arr1[3] and arr2[2]
    tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"arr1+Alt$(arr2,0)"</span>);
                 will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0
                 Or with a variable size array arr3
    tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"</span>);
                 will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1)
                 As a comparison
    tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"arr3[0]+arr3[1]+arr3[2]"</span>);
                 will draw the sum arr3 for the index 0 to 2 only if the
                 actual_size_of_arr3 is greater or equal to 3.
                 Note that the array in 'primary' is flatened/linearilized thus using
                 Alt$ with multi-dimensional arrays of different dimensions in unlikely
                 to yield the expected results.  To visualize a bit more what elements
                 would be matched by <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>, <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Scan" title="Long64_t TTree::Scan(const char* varexp=&quot;&quot;,const char* selection=&quot;&quot;,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0)">Scan</a> can be used:
    tree-&gt;<a href="./TTree.html#TTree:Scan" title="Long64_t TTree::Scan(const char* varexp=&quot;&quot;,const char* selection=&quot;&quot;,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0)">Scan</a>(<span class="string">"arr1:Alt$(arr2,0)"</span>);
                 will print on one line the value of arr1 and (arr2,0) that will be
                 matched by
    tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"arr1-Alt$(arr2,0)"</span>);

  The ternary operator is not directly support in <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> however, to plot the
  equivalent of 'var2&lt;20 ? -99 : var1', you can use:
     tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"(var2&lt;20)*99+(var2&gt;=20)*var1"</span>,<span class="string">""</span>);

     Drawing a user function accessing the <a href="./TTree.html">TTree</a> data directly


  If the formula contains  a file name, <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:MakeProxy" title="Int_t TTree::MakeProxy(const char* classname,const char* macrofilename=0,const char* cutfilename=0,const char* option=0,Int_t maxUnrolling=3)">MakeProxy</a> will be used
  to load and execute this file.   In particular it will draw the
  result of a function with the same name as the file.  The function
  will be executed in a context where the name of the branches can
  be used as a C++ variable.

  For example draw px using the file hsimple.root (generated by the
  hsimple.C tutorial), we need a file named hsimple.cxx:

     <a href="./ListOfTypes.html#double">double</a> hsimple() {
        return px;
     }

  <a href="./TTree.html#TTree:MakeProxy" title="Int_t TTree::MakeProxy(const char* classname,const char* macrofilename=0,const char* cutfilename=0,const char* option=0,Int_t maxUnrolling=3)">MakeProxy</a> can then be used indirectly via the <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> interface
  as follow:
     new <a href="./TFile.html">TFile</a>(<span class="string">"hsimple.root"</span>)
     ntuple-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"hsimple.cxx"</span>);

  A more complete example is available in the tutorials directory:
    h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C
  which reimplement the selector found in h1analysis.C

  The main features of this facility are:

    * on-demand loading of branches
    * ability to use the 'branchname' as if it was a data member
    * protection against array out-of-bound
    * ability to use the branch data as object (when the user code is available)

  See <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:MakeProxy" title="Int_t TTree::MakeProxy(const char* classname,const char* macrofilename=0,const char* cutfilename=0,const char* option=0,Int_t maxUnrolling=3)">MakeProxy</a> for more details.

     Making a Profile histogram

  In case of a 2-Dim expression, one can generate a <a href="./TProfile.html">TProfile</a> histogram
  instead of a <a href="./TH2F.html">TH2F</a> histogram by specyfying option=prof or option=profs.
  The option=prof is automatically selected in case of y:x&gt;&gt;pf
  where pf is an existing <a href="./TProfile.html">TProfile</a> histogram.

     Making a 2D Profile histogram

  In case of a 3-Dim expression, one can generate a <a href="./TProfile2D.html">TProfile2D</a> histogram
  instead of a <a href="./TH3F.html">TH3F</a> histogram by specifying option=prof or option=profs.
  The option=prof is automatically selected in case of z:y:x&gt;&gt;pf
  where pf is an existing <a href="./TProfile2D.html">TProfile2D</a> histogram.

     Making a 5D plot using GL

  If option GL5D is specified together with 5 variables, a 5D plot is drawn
  using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example.

     Making a parallel coordinates plot

  In case of a 2-Dim or more expression with the option=para, one can generate
  a parallel coordinates plot. With that option, the number of dimensions is
  arbitrary. Giving more than 4 variables without the option=para or
  option=candle or option=goff will produce an error.

     Making a candle sticks chart

  In case of a 2-Dim or more expression with the option=candle, one can generate
  a candle sticks chart. With that option, the number of dimensions is
  arbitrary. Giving more than 4 variables without the option=para or
  option=candle or option=goff will produce an error.

     Normalizing the ouput histogram to 1

  When option contains <span class="string">"norm"</span> the output histogram is normalized to 1.

     Saving the result of <a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> to a <a href="./TEventList.html">TEventList</a>, a <a href="./TEntryList.html">TEntryList</a> or a <a href="./TEntryListArray.html">TEntryListArray</a>

  <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> can be used to fill a <a href="./TEventList.html">TEventList</a> object (list of entry numbers)
  instead of histogramming one variable.
  If varexp0 has the form &gt;&gt;elist , a <a href="./TEventList.html">TEventList</a> object named <span class="string">"elist"</span>
  is created in the current directory. elist will contain the list
  of entry numbers satisfying the current selection.
  If option <span class="string">"entrylist"</span> is used, a <a href="./TEntryList.html">TEntryList</a> object is created
  If the selection contains arrays, vectors or any container class and option
  <span class="string">"entrylistarray"</span> is used, a <a href="./TEntryListArray.html">TEntryListArray</a> object is created
  containing also the subentries satisfying the selection, i.e. the indices of
  the branches which hold containers classes.
  Example:
    tree.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"&gt;&gt;yplus"</span>,<span class="string">"y&gt;0"</span>)
    will create a <a href="./TEventList.html">TEventList</a> object named <span class="string">"yplus"</span> in the current directory.
    In an interactive session, one can type (after <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>)
       yplus.<a href="./TTree.html#TTree:Print" title="void TTree::Print(Option_t* option=&quot;&quot;)">Print</a>(<span class="string">"all"</span>)
    to print the list of entry numbers in the list.
    tree.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"&gt;&gt;yplus"</span>, <span class="string">"y&gt;0"</span>, <span class="string">"entrylist"</span>)
    will create a <a href="./TEntryList.html">TEntryList</a> object names <span class="string">"yplus"</span> in the current directory
    tree.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"&gt;&gt;yplus"</span>, <span class="string">"y&gt;0"</span>, <span class="string">"entrylistarray"</span>)
    will create a <a href="./TEntryListArray.html">TEntryListArray</a> object names <span class="string">"yplus"</span> in the current directory

  By default, the specified entry list is reset.
  To continue to append data to an existing list, use <span class="string">"+"</span> in front
  of the list name;
    tree.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"&gt;&gt;+yplus"</span>,<span class="string">"y&gt;0"</span>)
      will not reset yplus, but will enter the selected entries at the end
      of the existing list.

      Using a <a href="./TEventList.html">TEventList</a>, <a href="./TEntryList.html">TEntryList</a> or <a href="./TEntryListArray.html">TEntryListArray</a> as Input

  Once a <a href="./TEventList.html">TEventList</a> or a <a href="./TEntryList.html">TEntryList</a> object has been generated, it can be used as input
  for <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>. Use <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:SetEventList" title="void TTree::SetEventList(TEventList* list)">SetEventList</a> or <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:SetEntryList" title="void TTree::SetEntryList(TEntryList* list,Option_t* opt=&quot;&quot;)">SetEntryList</a> to set the
  current event list
  Example1:
     <a href="./TEventList.html">TEventList</a> *elist = (<a href="./TEventList.html">TEventList</a>*)gDirectory-&gt;Get(<span class="string">"yplus"</span>);
     tree-&gt;<a href="./TTree.html#TTree:SetEventList" title="void TTree::SetEventList(TEventList* list)">SetEventList</a>(elist);
     tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"py"</span>);
  Example2:
     <a href="./TEntryList.html">TEntryList</a> *elist = (<a href="./TEntryList.html">TEntryList</a>*)gDirectory-&gt;Get(<span class="string">"yplus"</span>);
     tree-&gt;<a href="./TTree.html#TTree:SetEntryList" title="void TTree::SetEntryList(TEntryList* list,Option_t* opt=&quot;&quot;)">SetEntryList</a>(elist);
     tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"py"</span>);
  If a <a href="./TEventList.html">TEventList</a> object is used as input, a new <a href="./TEntryList.html">TEntryList</a> object is created
  inside the <a href="./TTree.html#TTree:SetEventList" title="void TTree::SetEventList(TEventList* list)">SetEventList</a> function. In case of a <a href="./TChain.html">TChain</a>, all tree headers are loaded
  for this transformation. This new object is owned by the chain and is deleted
  with it, unless the user extracts it by calling <a href="./TTree.html#TTree:GetEntryList" title="TEntryList* TTree::GetEntryList()">GetEntryList</a>() function.
  See also comments to <a href="./TTree.html#TTree:SetEventList" title="void TTree::SetEventList(TEventList* list)">SetEventList</a>() function of <a href="./TTree.html">TTree</a> and <a href="./TChain.html">TChain</a>.

  If arrays are used in the selection criteria and <a href="./TEntryListArray.html">TEntryListArray</a> is not used,
  all the entries that have at least one element of the array that satisfy the selection
  are entered in the list.
  Example:
      tree.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"&gt;&gt;pyplus"</span>,<span class="string">"fTracks.fPy&gt;0"</span>);
      tree-&gt;<a href="./TTree.html#TTree:SetEventList" title="void TTree::SetEventList(TEventList* list)">SetEventList</a>(pyplus);
      tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"fTracks.fPy"</span>);
  will draw the fPy of ALL tracks in event with at least one track with
  a positive fPy.

  To select only the elements that did match the original selection
  use <a href="./TEventList.html">TEventList</a>::<a href="./TEventList.html#TEventList:SetReapplyCut" title="void TEventList::SetReapplyCut(Bool_t apply=kFALSE)">SetReapplyCut</a> or <a href="./TEntryList.html">TEntryList</a>::<a href="./TEntryList.html#TEntryList:SetReapplyCut" title="void TEntryList::SetReapplyCut(Bool_t apply=kFALSE)">SetReapplyCut</a>.
  Example:
      tree.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"&gt;&gt;pyplus"</span>,<span class="string">"fTracks.fPy&gt;0"</span>);
      pyplus-&gt;SetReapplyCut(<a href="./ListOfTypes.html#Bool_t">kTRUE</a>);
      tree-&gt;<a href="./TTree.html#TTree:SetEventList" title="void TTree::SetEventList(TEventList* list)">SetEventList</a>(pyplus);
      tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"fTracks.fPy"</span>);
  will draw the fPy of only the tracks that have a positive fPy.

  To draw only the elements that match a selection in case of arrays,
  you can also use <a href="./TEntryListArray.html">TEntryListArray</a> (faster in case of a more general selection).
  Example:
      tree.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"&gt;&gt;pyplus"</span>,<span class="string">"fTracks.fPy&gt;0"</span>, <span class="string">"entrylistarray"</span>);
      tree-&gt;<a href="./TTree.html#TTree:SetEntryList" title="void TTree::SetEntryList(TEntryList* list,Option_t* opt=&quot;&quot;)">SetEntryList</a>(pyplus);
      tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"fTracks.fPy"</span>);

  will draw the fPy of only the tracks that have a positive fPy,
  but without redoing the selection.

  Note: Use tree-&gt;<a href="./TTree.html#TTree:SetEventList" title="void TTree::SetEventList(TEventList* list)">SetEventList</a>(0) if you do not want use the list as input.

      How to obtain more info from <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>


  Once <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> has been called, it is possible to access useful
  information still stored in the <a href="./TTree.html">TTree</a> object via the following functions:
    -<a href="./TTree.html#TTree:GetSelectedRows" title="Long64_t TTree::GetSelectedRows()">GetSelectedRows</a>()    //return the number of values accepted by the
                          //selection expression. In case where no selection
                          //was specified, returns the number of values processed.
    -<a href="./TTree.html#TTree:GetV1" title="Double_t* TTree::GetV1()">GetV1</a>()              //returns a pointer to the <a href="./ListOfTypes.html#double">double</a> array of V1
    -<a href="./TTree.html#TTree:GetV2" title="Double_t* TTree::GetV2()">GetV2</a>()              //returns a pointer to the <a href="./ListOfTypes.html#double">double</a> array of V2
    -<a href="./TTree.html#TTree:GetV3" title="Double_t* TTree::GetV3()">GetV3</a>()              //returns a pointer to the <a href="./ListOfTypes.html#double">double</a> array of V3
    -<a href="./TTree.html#TTree:GetV4" title="Double_t* TTree::GetV4()">GetV4</a>()              //returns a pointer to the <a href="./ListOfTypes.html#double">double</a> array of V4
    -<a href="./TTree.html#TTree:GetW" title="Double_t* TTree::GetW()">GetW</a>()               //returns a pointer to the <a href="./ListOfTypes.html#double">double</a> array of Weights
                          //where weight equal the result of the selection expression.
   where V1,V2,V3 correspond to the expressions in
   <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"V1:V2:V3:V4"</span>,selection);
   If the expression has more than 4 component use <a href="./TTree.html#TTree:GetVal" title="Double_t* TTree::GetVal(Int_t i)">GetVal</a>(index)

   Example:
    Root &gt; ntuple-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"py:px"</span>,<span class="string">"pz&gt;4"</span>);
    Root &gt; <a href="./TGraph.html">TGraph</a> *gr = new <a href="./TGraph.html">TGraph</a>(ntuple-&gt;<a href="./TTree.html#TTree:GetSelectedRows" title="Long64_t TTree::GetSelectedRows()">GetSelectedRows</a>(),
                                   ntuple-&gt;<a href="./TTree.html#TTree:GetV2" title="Double_t* TTree::GetV2()">GetV2</a>(), ntuple-&gt;<a href="./TTree.html#TTree:GetV1" title="Double_t* TTree::GetV1()">GetV1</a>());
    Root &gt; gr-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"ap"</span>); //draw graph in current pad
    creates a <a href="./TGraph.html">TGraph</a> object with a number of points corresponding to the
    number of entries selected by the expression <span class="string">"pz&gt;4"</span>, the x points of the graph
    being the px values of the Tree and the y points the py values.

    Important note: By default <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> creates the arrays obtained
    with <a href="./TTree.html#TTree:GetW" title="Double_t* TTree::GetW()">GetW</a>, <a href="./TTree.html#TTree:GetV1" title="Double_t* TTree::GetV1()">GetV1</a>, <a href="./TTree.html#TTree:GetV2" title="Double_t* TTree::GetV2()">GetV2</a>, <a href="./TTree.html#TTree:GetV3" title="Double_t* TTree::GetV3()">GetV3</a>, <a href="./TTree.html#TTree:GetV4" title="Double_t* TTree::GetV4()">GetV4</a>, <a href="./TTree.html#TTree:GetVal" title="Double_t* TTree::GetVal(Int_t i)">GetVal</a> with a length corresponding
    to the parameter <a href="./TTree.html#TTree:fEstimate" title="Long64_t TTree::fEstimate">fEstimate</a>.  The content will be the last
            <a href="./TTree.html#TTree:GetSelectedRows" title="Long64_t TTree::GetSelectedRows()">GetSelectedRows</a>() % <a href="./TTree.html#TTree:GetEstimate" title="Long64_t TTree::GetEstimate()">GetEstimate</a>()
    values calculated.
    By default <a href="./TTree.html#TTree:fEstimate" title="Long64_t TTree::fEstimate">fEstimate</a>=10000 and can be modified
    via <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:SetEstimate" title="void TTree::SetEstimate(Long64_t nentries=10000)">SetEstimate</a>. A possible recipee is to do
       tree-&gt;<a href="./TTree.html#TTree:SetEstimate" title="void TTree::SetEstimate(Long64_t nentries=10000)">SetEstimate</a>(tree-&gt;<a href="./TTree.html#TTree:GetEntries" title="Long64_t TTree::GetEntries() or overloads">GetEntries</a>());
    You must call <a href="./TTree.html#TTree:SetEstimate" title="void TTree::SetEstimate(Long64_t nentries=10000)">SetEstimate</a> if the expected number of selected rows
    is greater than 10000.

    You can use the option <span class="string">"goff"</span> to turn off the graphics output
    of <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> in the above example.

           Automatic interface to <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> via the <a href="./TTreeViewer.html">TTreeViewer</a>


    A complete graphical interface to this function is implemented
    in the class <a href="./TTreeViewer.html">TTreeViewer</a>.
    To start the <a href="./TTreeViewer.html">TTreeViewer</a>, three possibilities:
       - select <a href="./TTree.html">TTree</a> context menu item <span class="string">"StartViewer"</span>
       - type the command  <span class="string">"TTreeViewer TV(treeName)"</span>
       - execute statement <span class="string">"tree-&gt;StartViewer();"</span>

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:DropBaskets" href="src/TTree.cxx.html#NAhBuE">DropBaskets</a>()</span><br />
<div class="funccomm"><pre> Remove some baskets from memory.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:DropBuffers" href="src/TTree.cxx.html#uiVM2D">DropBuffers</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nbytes)</span><br />
<div class="funccomm"><pre> Drop branch buffers to accomodate nbytes below MaxVirtualsize.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:Fill" href="src/TTree.cxx.html#NJdO5D">Fill</a>()</span><br />
<div class="funccomm"><pre> <a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a> all branches.

   This function loops on all the branches of this tree.  For
   each branch, it copies to the branch buffer (basket) the current
   values of the leaves data types. If a leaf is a simple data type,
   a simple conversion to a machine independent format has to be done.

   This machine independent version of the data is copied into a
   basket (each branch has its own basket).  When a basket is full
   (32k worth of data by default), it is then optionally compressed
   and written to disk (this operation is also called comitting or
   'flushing' the basket).  The committed baskets are then
   immediately removed from memory.

   The function returns the number of bytes committed to the
   individual branches.

   If a write error occurs, the number of bytes returned is -1.

   If no data are written, because, e.g., the branch is disabled,
   the number of bytes returned is 0.

        The baskets are flushed and the Tree header saved at regular intervals

   At regular intervals, when the amount of data written so far is
   greater than <a href="./TTree.html#TTree:fAutoFlush" title="Long64_t TTree::fAutoFlush">fAutoFlush</a> (see <a href="./TTree.html#TTree:SetAutoFlush" title="void TTree::SetAutoFlush(Long64_t autof=30000000)">SetAutoFlush</a>) all the baskets are flushed to disk.
   This makes future reading faster as it guarantees that baskets belonging to nearby
   entries will be on the same disk region.
   When the first call to flush the baskets happen, we also take this opportunity
   to optimize the baskets buffers.
   We also check if the amount of data written is greater than <a href="./TTree.html#TTree:fAutoSave" title="Long64_t TTree::fAutoSave">fAutoSave</a> (see <a href="./TTree.html#TTree:SetAutoSave" title="void TTree::SetAutoSave(Long64_t autos=300000000)">SetAutoSave</a>).
   In this case we also write the Tree header. This makes the Tree recoverable up to this point
   in case the program writing the Tree crashes.
   The decisions to <a href="./TTree.html#TTree:FlushBaskets" title="Int_t TTree::FlushBaskets()">FlushBaskets</a> and Auto Save can be made based either on the number
   of bytes written (<a href="./TTree.html#TTree:fAutoFlush" title="Long64_t TTree::fAutoFlush">fAutoFlush</a> and <a href="./TTree.html#TTree:fAutoSave" title="Long64_t TTree::fAutoSave">fAutoSave</a> negative) or on the number of entries
   written (<a href="./TTree.html#TTree:fAutoFlush" title="Long64_t TTree::fAutoFlush">fAutoFlush</a> and <a href="./TTree.html#TTree:fAutoSave" title="Long64_t TTree::fAutoSave">fAutoSave</a> positive).
   Note that the user can decide to call <a href="./TTree.html#TTree:FlushBaskets" title="Int_t TTree::FlushBaskets()">FlushBaskets</a> and <a href="./TTree.html#TTree:AutoSave" title="Long64_t TTree::AutoSave(Option_t* option=&quot;&quot;)">AutoSave</a> in her event loop
   base on the number of events written instead of the number of bytes written.

   Note that calling <a href="./TTree.html#TTree:FlushBaskets" title="Int_t TTree::FlushBaskets()">FlushBaskets</a> too often increases the IO time.
   Note that calling <a href="./TTree.html#TTree:AutoSave" title="Long64_t TTree::AutoSave(Option_t* option=&quot;&quot;)">AutoSave</a> too often increases the IO time and also the file size.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TBranch.html">TBranch</a>* <a class="funcname" name="TTree:FindBranch" href="src/TTree.cxx.html#SOGbyD">FindBranch</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span><br />
<div class="funccomm"><pre> Return the branch that correspond to the path 'branchname', which can
 include the name of the tree or the ommited name of the parent branches.
 In case of ambiguity, returns the first match.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TLeaf.html">TLeaf</a>* <a class="funcname" name="TTree:FindLeaf" href="src/TTree.cxx.html#ZkfY8B">FindLeaf</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span><br />
<div class="funccomm"><pre> FIXME: Describe this function.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:Fit" href="src/TTree.cxx.html#lGlGqB">Fit</a>(<span class="keyword">const</span> <span class="keyword">char</span>* funcname, <span class="keyword">const</span> <span class="keyword">char</span>* varexp, <span class="keyword">const</span> <span class="keyword">char</span>* selection = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* goption = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)</span><br />
<div class="funccomm"><pre> <a href="./TTree.html#TTree:Fit" title="Int_t TTree::Fit(const char* funcname,const char* varexp,const char* selection=&quot;&quot;,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0)">Fit</a>  a projected item(s) from a tree.

  funcname is a <a href="./TF1.html">TF1</a> function.

  See <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>() for explanations of the other parameters.

  By default the temporary histogram created is called htemp.
  If varexp contains &gt;&gt;hnew , the new histogram created is called hnew
  and it is kept in the current directory.

  The function returns the number of selected entries.

  Example:
    tree.<a href="./TTree.html#TTree:Fit" title="Int_t TTree::Fit(const char* funcname,const char* varexp,const char* selection=&quot;&quot;,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0)">Fit</a>(pol4,sqrt(x)&gt;&gt;hsqrt,y&gt;0)
    will fit sqrt(x) and save the histogram as <span class="string">"hsqrt"</span> in the current
    directory.

   See also <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:UnbinnedFit" title="Int_t TTree::UnbinnedFit(const char* funcname,const char* varexp,const char* selection=&quot;&quot;,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0)">UnbinnedFit</a>

   Return status

  The function returns the status of the histogram fit (see <a href="./TH1.html">TH1</a>::<a href="./TH1.html#TH1:Fit" title="TFitResultPtr TH1::Fit(const char* formula,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Double_t xmin=0,Double_t xmax=0) or overloads">Fit</a>)
  If no entries were selected, the function returns -1;
   (ie fitResult is null is the fit is OK)
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:FlushBaskets" href="src/TTree.cxx.html#nbgDJE">FlushBaskets</a>() const</span><br />
<div class="funccomm"><pre> <a href="./TTree.html#TTree:Write" title="Int_t TTree::Write(const char* name=0,Int_t option=0,Int_t bufsize=0) or overloads">Write</a> to disk all the basket that have not yet been individually written.

 Return the number of bytes written or -1 in case of write error.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">const</span> <span class="keyword">char</span>* <a class="funcname" name="TTree:GetAlias" href="src/TTree.cxx.html#S7YOfD">GetAlias</a>(<span class="keyword">const</span> <span class="keyword">char</span>* aliasName) const</span><br />
<div class="funccomm"><pre> Returns the expanded value of the alias.  Search in the friends if any.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TBranch.html">TBranch</a>* <a class="funcname" name="TTree:GetBranch" href="src/TTree.cxx.html#g6ibgD">GetBranch</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span><br />
<div class="funccomm"><pre> Return pointer to the branch with the given name in this tree or its friends.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Bool_t">Bool_t</a> <a class="funcname" name="TTree:GetBranchStatus" href="src/TTree.cxx.html#Px50PB">GetBranchStatus</a>(<span class="keyword">const</span> <span class="keyword">char</span>* branchname) const</span><br />
<div class="funccomm"><pre> Return status of branch with name branchname.
 0 if branch is not activated
 1 if branch is activated
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:GetBranchStyle" href="src/TTree.cxx.html#AtpHfC">GetBranchStyle</a>()</span><br />
<div class="funccomm"><pre> Static function returning the current branch style.
 style = 0 old <a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>
 style = 1 new <a href="./TTree.html#TTree:Bronch" title="TBranch* TTree::Bronch(const char* name,const char* classname,void* addobj,Int_t bufsize=32000,Int_t splitlevel=99)">Bronch</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TFile.html">TFile</a>* <a class="funcname" name="TTree:GetCurrentFile" href="src/TTree.cxx.html#eZpcC">GetCurrentFile</a>() const</span><br />
<div class="funccomm"><pre> Return pointer to the current file.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetEntries%1" href="src/TTree.cxx.html#PFcfD">GetEntries</a>(<span class="keyword">const</span> <span class="keyword">char</span>* selection)</span><br />
<div class="funccomm"><pre> Return the number of entries matching the selection.
 Return -1 in case of errors.

 If the selection uses any arrays or containers, we return the number
 of entries where at least one element match the selection.
 <a href="./TTree.html#TTree:GetEntries" title="Long64_t TTree::GetEntries() or overloads">GetEntries</a> is implemented using the selector class <a href="./TSelectorEntries.html">TSelectorEntries</a>,
 which can be used directly (see code in <a href="./TTreePlayer.html">TTreePlayer</a>::<a href="./TTreePlayer.html#TTreePlayer:GetEntries" title="Long64_t TTreePlayer::GetEntries(const char* selection)">GetEntries</a>) for
 additional option.
 If <a href="./TTree.html#TTree:SetEventList" title="void TTree::SetEventList(TEventList* list)">SetEventList</a> was used on the <a href="./TTree.html">TTree</a> or <a href="./TChain.html">TChain</a>, only that subset
 of entries will be considered.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetEntriesFriend" href="src/TTree.cxx.html#z.Wmb">GetEntriesFriend</a>() const</span><br />
<div class="funccomm"><pre> Return pointer to the 1st Leaf named name in any <a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> of this Tree or
 any branch in the list of friend trees.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:GetEntry" href="src/TTree.cxx.html#OGvVlC">GetEntry</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> entry = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> getall = 0)</span><br />
<div class="funccomm"><pre> <a href="./TObject.html#TObject:Read" title="Int_t TObject::Read(const char* name)">Read</a> all branches of entry and return total number of bytes read.

     getall = 0 : get only active branches
     getall = 1 : get all branches

  The function returns the number of bytes read from the input buffer.
  If entry does not exist the function returns 0.
  If an I/O error occurs, the function returns -1.

  If the Tree has friends, also read the friends entry.

  To activate/deactivate one or more branches, use <a href="./TBranch.html">TBranch</a>::SetBranchStatus
  For example, if you have a Tree with several hundred branches, and you
  are interested only by branches named <span class="string">"a"</span> and <span class="string">"b"</span>, do
     mytree.<a href="./TTree.html#TTree:SetBranchStatus" title="void TTree::SetBranchStatus(const char* bname,Bool_t status=1,UInt_t* found=0)">SetBranchStatus</a>(<span class="string">"*"</span>,0); //disable all branches
     mytree.<a href="./TTree.html#TTree:SetBranchStatus" title="void TTree::SetBranchStatus(const char* bname,Bool_t status=1,UInt_t* found=0)">SetBranchStatus</a>(<span class="string">"a"</span>,1);
     mytree.<a href="./TTree.html#TTree:SetBranchStatus" title="void TTree::SetBranchStatus(const char* bname,Bool_t status=1,UInt_t* found=0)">SetBranchStatus</a>(<span class="string">"b"</span>,1);
  when calling mytree.<a href="./TTree.html#TTree:GetEntry" title="Int_t TTree::GetEntry(Long64_t entry=0,Int_t getall=0)">GetEntry</a>(i); only branches <span class="string">"a"</span> and <span class="string">"b"</span> will be read.

  WARNING!!
  If your Tree has been created in split mode with a parent branch <span class="string">"parent"</span>,
     mytree.<a href="./TTree.html#TTree:SetBranchStatus" title="void TTree::SetBranchStatus(const char* bname,Bool_t status=1,UInt_t* found=0)">SetBranchStatus</a>(<span class="string">"parent"</span>,1);
  will not activate the sub-branches of <span class="string">"parent"</span>. You should do:
     mytree.<a href="./TTree.html#TTree:SetBranchStatus" title="void TTree::SetBranchStatus(const char* bname,Bool_t status=1,UInt_t* found=0)">SetBranchStatus</a>(<span class="string">"parent*"</span>,1);

  An alternative is to call directly
     brancha.<a href="./TTree.html#TTree:GetEntry" title="Int_t TTree::GetEntry(Long64_t entry=0,Int_t getall=0)">GetEntry</a>(i)
     branchb.<a href="./TTree.html#TTree:GetEntry" title="Int_t TTree::GetEntry(Long64_t entry=0,Int_t getall=0)">GetEntry</a>(i);

  IMPORTANT NOTE

 By default, <a href="./TTree.html#TTree:GetEntry" title="Int_t TTree::GetEntry(Long64_t entry=0,Int_t getall=0)">GetEntry</a> reuses the space allocated by the previous object
 for each branch. You can force the previous object to be automatically
 deleted if you call mybranch.SetAutoDelete(<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) (default is <a href="./ListOfTypes.html#Bool_t">kFALSE</a>).
 Example:
 Consider the example in $ROOTSYS/test/Event.h
 The top level branch in the tree T is declared with:
    Event *event = 0;  //event must be null or point to a valid object
                       //it must be initialized
    T.<a href="./TTree.html#TTree:SetBranchAddress" title="Int_t TTree::SetBranchAddress(const char* bname,void* add,TClass* realClass,EDataType datatype,Bool_t isptr) or overloads">SetBranchAddress</a>(<span class="string">"event"</span>,&amp;event);
 When reading the Tree, one can choose one of these 3 options:

   OPTION 1


    for (<a href="./ListOfTypes.html#Long64_t">Long64_t</a> i=0;i&lt;nentries;i++) {
       T.<a href="./TTree.html#TTree:GetEntry" title="Int_t TTree::GetEntry(Long64_t entry=0,Int_t getall=0)">GetEntry</a>(i);
       // the object event has been filled at this point
    }
   The default (recommended). At the first entry an object of the class
   Event will be created and pointed by event. At the following entries,
   event will be overwritten by the new data. All internal members that are
   <a href="./TObject.html">TObject</a>* are automatically deleted. It is important that these members
   be in a valid state when <a href="./TTree.html#TTree:GetEntry" title="Int_t TTree::GetEntry(Long64_t entry=0,Int_t getall=0)">GetEntry</a> is called. Pointers must be correctly
   initialized. However these internal members will not be deleted if the
   characters <span class="string">"-&gt;"</span> are specified as the first characters in the comment
   field of the data member declaration.

   If <span class="string">"-&gt;"</span> is specified, the pointer member is read via pointer-&gt;<a href="./TTree.html#TTree:Streamer" title="void TTree::Streamer(TBuffer&amp; b)">Streamer</a>(buf).
   In this case, it is assumed that the pointer is never null (case of
   pointer <a href="./TClonesArray.html">TClonesArray</a> *fTracks in the Event example). If <span class="string">"-&gt;"</span> is not
   specified, the pointer member is read via buf &gt;&gt; pointer. In this case
   the pointer may be null. Note that the option with <span class="string">"-&gt;"</span> is faster to
   read or write and it also consumes less space in the file.

   OPTION 2

  The option AutoDelete is set
   <a href="./TBranch.html">TBranch</a> *branch = T.<a href="./TTree.html#TTree:GetBranch" title="TBranch* TTree::GetBranch(const char* name)">GetBranch</a>(<span class="string">"event"</span>);
   branch-&gt;SetAddress(&amp;event);
   branch-&gt;SetAutoDelete(<a href="./ListOfTypes.html#Bool_t">kTRUE</a>);
    for (<a href="./ListOfTypes.html#Long64_t">Long64_t</a> i=0;i&lt;nentries;i++) {
       T.<a href="./TTree.html#TTree:GetEntry" title="Int_t TTree::GetEntry(Long64_t entry=0,Int_t getall=0)">GetEntry</a>(i);
       // the object event has been filled at this point
    }
   In this case, at each iteration, the object event is deleted by <a href="./TTree.html#TTree:GetEntry" title="Int_t TTree::GetEntry(Long64_t entry=0,Int_t getall=0)">GetEntry</a>
   and a new instance of Event is created and filled.

   OPTION 3

   Same as option 1, but you delete yourself the event.
    for (<a href="./ListOfTypes.html#Long64_t">Long64_t</a> i=0;i&lt;nentries;i++) {
       delete event;
       event = 0;  // EXTREMELY IMPORTANT
       T.<a href="./TTree.html#TTree:GetEntry" title="Int_t TTree::GetEntry(Long64_t entry=0,Int_t getall=0)">GetEntry</a>(i);
       // the object event has been filled at this point
    }

  It is strongly recommended to use the default option 1. It has the
  additional advantage that functions like <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> (internally calling
  <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:GetEntry" title="Int_t TTree::GetEntry(Long64_t entry=0,Int_t getall=0)">GetEntry</a>) will be functional even when the classes in the file are
  not available.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TEntryList.html">TEntryList</a>* <a class="funcname" name="TTree:GetEntryList" href="src/TTree.cxx.html#j.6PdD">GetEntryList</a>()</span><br />
<div class="funccomm"><pre>Returns the entry list, set to this tree
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetEntryNumber" href="src/TTree.cxx.html#fGXjs">GetEntryNumber</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> entry) const</span><br />
<div class="funccomm"><pre> Return entry number corresponding to entry.

 if no <a href="./TEntryList.html">TEntryList</a> set returns entry
 else returns the entry number corresponding to the list index=entry
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetEntryNumberWithBestIndex" href="src/TTree.cxx.html#CDBHqE">GetEntryNumberWithBestIndex</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> major, <a href="./ListOfTypes.html#Int_t">Int_t</a> minor = 0) const</span><br />
<div class="funccomm"><pre> Return entry number corresponding to major and minor number.
 Note that this function returns only the entry number, not the data
 To read the data corresponding to an entry number, use <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:GetEntryWithIndex" title="Int_t TTree::GetEntryWithIndex(Int_t major,Int_t minor=0)">GetEntryWithIndex</a>
 the <a href="./TTree.html#TTree:BuildIndex" title="Int_t TTree::BuildIndex(const char* majorname,const char* minorname=&quot;0&quot;)">BuildIndex</a> function has created a table of <a href="./ListOfTypes.html#Long64_t">Long64_t</a>* of sorted values
 corresponding to val = major&lt;&lt;31 + minor;
 The function performs binary search in this sorted table.
 If it finds a pair that maches val, it returns directly the
 index in the table.
 If an entry corresponding to major and minor is not found, the function
 returns the index of the major,minor pair immediatly lower than the
 requested value, ie it will return -1 if the pair is lower than
 the first entry in the index.

 See also <a href="./TTree.html#TTree:GetEntryNumberWithIndex" title="Long64_t TTree::GetEntryNumberWithIndex(Int_t major,Int_t minor=0)">GetEntryNumberWithIndex</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetEntryNumberWithIndex" href="src/TTree.cxx.html#QT_CQC">GetEntryNumberWithIndex</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> major, <a href="./ListOfTypes.html#Int_t">Int_t</a> minor = 0) const</span><br />
<div class="funccomm"><pre> Return entry number corresponding to major and minor number.
 Note that this function returns only the entry number, not the data
 To read the data corresponding to an entry number, use <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:GetEntryWithIndex" title="Int_t TTree::GetEntryWithIndex(Int_t major,Int_t minor=0)">GetEntryWithIndex</a>
 the <a href="./TTree.html#TTree:BuildIndex" title="Int_t TTree::BuildIndex(const char* majorname,const char* minorname=&quot;0&quot;)">BuildIndex</a> function has created a table of <a href="./ListOfTypes.html#Long64_t">Long64_t</a>* of sorted values
 corresponding to val = major&lt;&lt;31 + minor;
 The function performs binary search in this sorted table.
 If it finds a pair that maches val, it returns directly the
 index in the table, otherwise it returns -1.

 See also <a href="./TTree.html#TTree:GetEntryNumberWithBestIndex" title="Long64_t TTree::GetEntryNumberWithBestIndex(Int_t major,Int_t minor=0)">GetEntryNumberWithBestIndex</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:GetEntryWithIndex" href="src/TTree.cxx.html#IDxzy">GetEntryWithIndex</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> major, <a href="./ListOfTypes.html#Int_t">Int_t</a> minor = 0)</span><br />
<div class="funccomm"><pre> <a href="./TObject.html#TObject:Read" title="Int_t TObject::Read(const char* name)">Read</a> entry corresponding to major and minor number.

  The function returns the total number of bytes read.
  If the Tree has friend trees, the corresponding entry with
  the index values (major,minor) is read. Note that the master Tree
  and its friend may have different entry serial numbers corresponding
  to (major,minor).
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TTree.html">TTree</a>* <a class="funcname" name="TTree:GetFriend" href="src/TTree.cxx.html#JXlDmE">GetFriend</a>(<span class="keyword">const</span> <span class="keyword">char</span>* ) const</span><br />
<div class="funccomm"><pre> Return a pointer to the <a href="./TTree.html">TTree</a> friend whose name or alias is 'friendname.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">const</span> <span class="keyword">char</span>* <a class="funcname" name="TTree:GetFriendAlias" href="src/TTree.cxx.html#RcAHW">GetFriendAlias</a>(<a href="./TTree.html">TTree</a>* ) const</span><br />
<div class="funccomm"><pre> If the the 'tree' is a friend, this method returns its alias name.

 This alias is an alternate name for the tree.

 It can be used in conjunction with a branch or leaf name in a <a href="./TTreeFormula.html">TTreeFormula</a>,
 to specify in which particular tree the branch or leaf can be found if
 the friend trees have branches or leaves with the same name as the master
 tree.

 It can also be used in conjunction with an alias created using
 <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:SetAlias" title="Bool_t TTree::SetAlias(const char* aliasName,const char* aliasFormula)">SetAlias</a> in a <a href="./TTreeFormula.html">TTreeFormula</a>, e.g.:

      maintree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"treealias.fPx - treealias.myAlias"</span>);

 where fPx is a branch of the friend tree aliased as 'treealias' and 'myAlias'
 was created using <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:SetAlias" title="Bool_t TTree::SetAlias(const char* aliasName,const char* aliasFormula)">SetAlias</a> on the friend tree.

 However, note that 'treealias.myAlias' will be expanded literally,
 without remembering that it comes from the aliased friend and thus
 the branch name might not be disambiguated properly, which means
 that you may not be able to take advantage of this feature.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TIterator.html">TIterator</a>* <a class="funcname" name="TTree:GetIteratorOnAllLeaves" href="src/TTree.cxx.html#gXH8O">GetIteratorOnAllLeaves</a>(<a href="./ListOfTypes.html#Bool_t">Bool_t</a> <a href="./TString.html">dir</a> = <a href="./ListOfTypes.html#Bool_t">kIterForward</a>)</span><br />
<div class="funccomm"><pre> Creates a new iterator that will go through all the leaves on the tree itself and its friend.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TLeaf.html">TLeaf</a>* <a class="funcname" name="TTree:GetLeafImpl" href="src/TTree.cxx.html#UhQ1bB">GetLeafImpl</a>(<span class="keyword">const</span> <span class="keyword">char</span>* branchname, <span class="keyword">const</span> <span class="keyword">char</span>* leafname)</span><br />
<div class="funccomm"><pre> Return pointer to the 1st Leaf named name in any <a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> of this
 Tree or any branch in the list of friend trees.

 The leaf name can contain the name of a friend tree with the
 syntax: friend_dir_and_tree.full_leaf_name
 the friend_dir_and_tree can be of the form
    TDirectoryName/TreeName
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TLeaf.html">TLeaf</a>* <a class="funcname" name="TTree:GetLeaf" href="src/TTree.cxx.html#yc0tnD">GetLeaf</a>(<span class="keyword">const</span> <span class="keyword">char</span>* branchname, <span class="keyword">const</span> <span class="keyword">char</span>* leafname)</span><br />
<div class="funccomm"><pre> Return pointer to the 1st Leaf named name in any <a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> of this
 Tree or any branch in the list of friend trees.

 The leaf name can contain the name of a friend tree with the
 syntax: friend_dir_and_tree.full_leaf_name
 the friend_dir_and_tree can be of the form
    TDirectoryName/TreeName
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TLeaf.html">TLeaf</a>* <a class="funcname" name="TTree:GetLeaf%1" href="src/TTree.cxx.html#MZibP">GetLeaf</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span><br />
<div class="funccomm"><pre> Return pointer to the 1st Leaf named name in any <a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> of this
 Tree or any branch in the list of friend trees.

 aname may be of the form branchname/leafname
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TTree:GetMaximum" href="src/TTree.cxx.html#PNz1z">GetMaximum</a>(<span class="keyword">const</span> <span class="keyword">char</span>* columname)</span><br />
<div class="funccomm"><pre> Return maximum of column with name columname.
 if the Tree has an associated <a href="./TEventList.html">TEventList</a> or <a href="./TEntryList.html">TEntryList</a>, the maximum
 is computed for the entries in this list.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetMaxTreeSize" href="src/TTree.cxx.html#MmrBBE">GetMaxTreeSize</a>()</span><br />
<div class="funccomm"><pre> Static function which returns the tree file size limit in bytes.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TTree:GetMinimum" href="src/TTree.cxx.html#Hnq1z">GetMinimum</a>(<span class="keyword">const</span> <span class="keyword">char</span>* columname)</span><br />
<div class="funccomm"><pre> Return minimum of column with name columname.
 if the Tree has an associated <a href="./TEventList.html">TEventList</a> or <a href="./TEntryList.html">TEntryList</a>, the minimum
 is computed for the entries in this list.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TVirtualTreePlayer.html">TVirtualTreePlayer</a>* <a class="funcname" name="TTree:GetPlayer" href="src/TTree.cxx.html#c4TEVE">GetPlayer</a>()</span><br />
<div class="funccomm"><pre> Load the <a href="./TTreePlayer.html">TTreePlayer</a> (if not already done).
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TList.html">TList</a>* <a class="funcname" name="TTree:GetUserInfo" href="src/TTree.cxx.html#N0uleB">GetUserInfo</a>()</span><br />
<div class="funccomm"><pre> Return a pointer to the list containing user objects associated to this tree.

 The list is automatically created if it does not exist.

 WARNING: By default the <a href="./TTree.html">TTree</a> destructor will delete all objects added
          to this list. If you do not want these objects to be deleted,
          call:

               mytree-&gt;<a href="./TTree.html#TTree:GetUserInfo" title="TList* TTree::GetUserInfo()">GetUserInfo</a>()-><a href="./TList.html#TList:Clear" title="void TList::Clear(Option_t* option=&quot;&quot;)">Clear</a>();

          before deleting the tree.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:ImportClusterRanges" href="src/TTree.cxx.html#APK5UC">ImportClusterRanges</a>(<a href="./TTree.html">TTree</a>* fromtree)</span><br />
<div class="funccomm"><pre> Appends the cluster range information stored in 'fromtree' to this tree,
 including the value of <a href="./TTree.html#TTree:fAutoFlush" title="Long64_t TTree::fAutoFlush">fAutoFlush</a>.

 This is used when doing a fast cloning (by <a href="./TTreeCloner.html">TTreeCloner</a>).
 See also <a href="./TTree.html#TTree:fAutoFlush" title="Long64_t TTree::fAutoFlush">fAutoFlush</a> and <a href="./TTree.html#TTree:fAutoSave" title="Long64_t TTree::fAutoSave">fAutoSave</a> if needed.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:KeepCircular" href="src/TTree.cxx.html#vPAFjD">KeepCircular</a>()</span><br />
<div class="funccomm"><pre> Keep a maximum of <a href="./TTree.html#TTree:fMaxEntries" title="Long64_t TTree::fMaxEntries">fMaxEntries</a> in memory.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:LoadBaskets" href="src/TTree.cxx.html#QuQ5.B">LoadBaskets</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> maxmemory = 2000000000)</span><br />
<div class="funccomm"><pre> <a href="./TObject.html#TObject:Read" title="Int_t TObject::Read(const char* name)">Read</a> in memory all baskets from all branches up to the limit of maxmemory bytes.

 If maxmemory is non null and positive <a href="./TTree.html#TTree:SetMaxVirtualSize" title="void TTree::SetMaxVirtualSize(Long64_t size=0)">SetMaxVirtualSize</a> is called
 with this value. Default for maxmemory is 2000000000 (2 Gigabytes).
 The function returns the total number of baskets read into memory
 if negative an error occurred while loading the branches.
 This method may be called to force branch baskets in memory
 when random access to branch entries is required.
 If random access to only a few branches is required, you should
 call directly <a href="./TBranch.html">TBranch</a>::<a href="./TBranch.html#TBranch:LoadBaskets" title="Int_t TBranch::LoadBaskets()">LoadBaskets</a>.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:LoadTree" href="src/TTree.cxx.html#cTxJ3B">LoadTree</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> entry)</span><br />
<div class="funccomm"><pre> Set current entry.

 Returns -2 if entry does not exist (just as <a href="./TChain.html">TChain</a>::<a href="./TChain.html#TChain:LoadTree" title="Long64_t TChain::LoadTree(Long64_t entry)">LoadTree</a>()).

 Note: This function is overloaded in <a href="./TChain.html">TChain</a>.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:LoadTreeFriend" href="src/TTree.cxx.html#olnbU">LoadTreeFriend</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> entry, <a href="./TTree.html">TTree</a>* T)</span><br />
<div class="funccomm"><pre> Load entry on behalf of our master tree, we may use an index.

 Called by <a href="./TTree.html#TTree:LoadTree" title="Long64_t TTree::LoadTree(Long64_t entry)">LoadTree</a>() when the masterTree looks for the entry
 number in a friend tree (us) corresponding to the passed entry
 number in the masterTree.

 If we have no index, our entry number and the masterTree entry
 number are the same.

 If we *do* have an index, we must find the (major, minor) value pair
 in masterTree to locate our corresponding entry.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:MakeClass" href="src/TTree.cxx.html#doYnvE">MakeClass</a>(<span class="keyword">const</span> <span class="keyword">char</span>* classname = 0, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre> Generate a skeleton analysis class for this tree.

 The following files are produced: classname.h and classname.C.
 If classname is 0, classname will be called <span class="string">"nameoftree"</span>.

 The generated code in classname.h includes the following:
    - Identification of the original tree and the input file name.
    - Definition of an analysis class (data members and member functions).
    - The following member functions:
       - constructor (by default opening the tree file),
       - <a href="./TTree.html#TTree:GetEntry" title="Int_t TTree::GetEntry(Long64_t entry=0,Int_t getall=0)">GetEntry</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> entry),
       - Init(<a href="./TTree.html">TTree</a>* tree) to initialize a new <a href="./TTree.html">TTree</a>,
       - <a href="./TTree.html#TTree:Show" title="void TTree::Show(Long64_t entry=-1,Int_t lenmax=20)">Show</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> entry) to read and dump entry.

 The generated code in classname.C includes only the main
 analysis function Loop.

 To use this function:
    - Open your tree file (eg: <a href="./TFile.html">TFile</a> f(<span class="string">"myfile.root"</span>);)
    - T-&gt;<a href="./TTree.html#TTree:MakeClass" title="Int_t TTree::MakeClass(const char* classname=0,Option_t* option=&quot;&quot;)">MakeClass</a>(<span class="string">"MyClass"</span>);
 where T is the name of the <a href="./TTree.html">TTree</a> in file myfile.root,
 and MyClass.h, MyClass.C the name of the files created by this function.
 In a <a href="./ROOT.html">ROOT</a> session, you can do:
    root &gt; .L MyClass.C
    root &gt; MyClass* t = new MyClass;
    root &gt; t-&gt;<a href="./TTree.html#TTree:GetEntry" title="Int_t TTree::GetEntry(Long64_t entry=0,Int_t getall=0)">GetEntry</a>(12); // <a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a> data members of t with entry number 12.
    root &gt; t-&gt;<a href="./TTree.html#TTree:Show" title="void TTree::Show(Long64_t entry=-1,Int_t lenmax=20)">Show</a>();       // <a href="./TTree.html#TTree:Show" title="void TTree::Show(Long64_t entry=-1,Int_t lenmax=20)">Show</a> values of entry 12.
    root &gt; t-&gt;<a href="./TTree.html#TTree:Show" title="void TTree::Show(Long64_t entry=-1,Int_t lenmax=20)">Show</a>(16);     // <a href="./TObject.html#TObject:Read" title="Int_t TObject::Read(const char* name)">Read</a> and show values of entry 16.
    root &gt; t-&gt;Loop();       // Loop on all entries.

  NOTE: Do not use the code generated for a single <a href="./TTree.html">TTree</a> which is part
        of a <a href="./TChain.html">TChain</a> to process that entire <a href="./TChain.html">TChain</a>.  The maximum dimensions
        calculated for arrays on the basis of a single <a href="./TTree.html">TTree</a> from the <a href="./TChain.html">TChain</a>
        might be (will be!) too small when processing all of the TTrees in
        the <a href="./TChain.html">TChain</a>.  You must use myChain.<a href="./TTree.html#TTree:MakeClass" title="Int_t TTree::MakeClass(const char* classname=0,Option_t* option=&quot;&quot;)">MakeClass</a>() to generate the code,
        not myTree.<a href="./TTree.html#TTree:MakeClass" title="Int_t TTree::MakeClass(const char* classname=0,Option_t* option=&quot;&quot;)">MakeClass</a>(...).

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:MakeCode" href="src/TTree.cxx.html#QLvPcD">MakeCode</a>(<span class="keyword">const</span> <span class="keyword">char</span>* filename = 0)</span><br />
<div class="funccomm"><pre> Generate a skeleton function for this tree.

 The function code is written on filename.
 If filename is 0, filename will be called nameoftree.C

 The generated code includes the following:
    - Identification of the original Tree and Input file name,
    - Opening the Tree file,
    - Declaration of Tree variables,
    - Setting of branches addresses,
    - A skeleton for the entry loop.

 To use this function:
    - Open your Tree file (eg: <a href="./TFile.html">TFile</a> f(<span class="string">"myfile.root"</span>);)
    - T-&gt;<a href="./TTree.html#TTree:MakeCode" title="Int_t TTree::MakeCode(const char* filename=0)">MakeCode</a>(<span class="string">"MyAnalysis.C"</span>);
 where T is the name of the <a href="./TTree.html">TTree</a> in file myfile.root
 and MyAnalysis.C the name of the file created by this function.

 NOTE: Since the implementation of this function, a new and better
       function <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:MakeClass" title="Int_t TTree::MakeClass(const char* classname=0,Option_t* option=&quot;&quot;)">MakeClass</a>() has been developed.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:MakeProxy" href="src/TTree.cxx.html#SYPmfB">MakeProxy</a>(<span class="keyword">const</span> <span class="keyword">char</span>* classname, <span class="keyword">const</span> <span class="keyword">char</span>* macrofilename = 0, <span class="keyword">const</span> <span class="keyword">char</span>* cutfilename = 0, <span class="keyword">const</span> <span class="keyword">char</span>* option = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> maxUnrolling = 3)</span><br />
<div class="funccomm"><pre> Generate a skeleton analysis class for this Tree using TBranchProxy.

 TBranchProxy is the base of a class hierarchy implementing an
 indirect access to the content of the branches of a <a href="./TTree.html">TTree</a>.

 <span class="string">"proxyClassname"</span> is expected to be of the form:
    [path/]fileprefix
 The skeleton will then be generated in the file:
    fileprefix.h
 located in the current directory or in 'path/' if it is specified.
 The class generated will be named 'fileprefix'

 <span class="string">"macrofilename"</span> and optionally <span class="string">"cutfilename"</span> are expected to point
 to source files which will be included by the generated skeleton.
 Method of the same name as the file(minus the extension and path)
 will be called by the generated skeleton's <a href="./TTree.html#TTree:Process" title="Long64_t TTree::Process(const char* filename,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0) or overloads">Process</a> method as follow:
    [if (cutfilename())] htemp-&gt;<a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a>(macrofilename());

 <span class="string">"option"</span> can be used select some of the optional features during
 the code generation.  The possible options are:
    nohist : indicates that the generated ProcessFill should not
             fill the histogram.

 'maxUnrolling' controls how deep in the class hierachy does the
 system 'unroll' classes that are not split.  Unrolling a class
 allows direct access to its data members (this emulates the behavior
 of <a href="./TTreeFormula.html">TTreeFormula</a>).

 The main features of this skeleton are:

    * on-demand loading of branches
    * ability to use the 'branchname' as if it was a data member
    * protection against array out-of-bounds errors
    * ability to use the branch data as an object (when the user code is available)

 For example with Event.root, if
    <a href="./ListOfTypes.html#Double_t">Double_t</a> somePx = fTracks.fPx[2];
 is executed by one of the method of the skeleton,
 somePx will updated with the current value of fPx of the 3rd track.

 Both macrofilename and the optional cutfilename are expected to be
 the name of source files which contain at least a free standing
 function with the signature:
     x_t macrofilename(); // i.e function with the same name as the file
 and
     y_t cutfilename();   // i.e function with the same name as the file

 x_t and y_t needs to be types that can convert respectively to a <a href="./ListOfTypes.html#double">double</a>
 and a <a href="./ListOfTypes.html#bool">bool</a> (because the skeleton uses:
     if (cutfilename()) htemp-&gt;<a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a>(macrofilename());

 These two functions are run in a context such that the branch names are
 available as local variables of the correct (read-only) type.

 Note that if you use the same 'variable' twice, it is more efficient
 to 'cache' the value. For example
   <a href="./ListOfTypes.html#Int_t">Int_t</a> n = fEventNumber; // <a href="./TObject.html#TObject:Read" title="Int_t TObject::Read(const char* name)">Read</a> fEventNumber
   if (n&lt;10 || n&gt;10) { ... }
 is more efficient than
   if (fEventNumber&lt;10 || fEventNumber&gt;10)

 Also, optionally, the generated selector will also call methods named
 macrofilename_methodname in each of 6 main selector methods if the method
 macrofilename_methodname exist (Where macrofilename is stripped of its
 extension).

 Concretely, with the script named h1analysisProxy.C,

 The method         calls the method (if it exist)
 Begin           -&gt; <a href="./ListOfTypes.html#void">void</a> h1analysisProxy_Begin(<a href="./TTree.html">TTree</a>*);
 SlaveBegin      -&gt; <a href="./ListOfTypes.html#void">void</a> h1analysisProxy_SlaveBegin(<a href="./TTree.html">TTree</a>*);
 <a href="./TTree.html#TTree:Notify" title="Bool_t TTree::Notify()">Notify</a>          -&gt; <a href="./ListOfTypes.html#Bool_t">Bool_t</a> h1analysisProxy_Notify();
 <a href="./TTree.html#TTree:Process" title="Long64_t TTree::Process(const char* filename,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0) or overloads">Process</a>         -&gt; <a href="./ListOfTypes.html#Bool_t">Bool_t</a> h1analysisProxy_Process(<a href="./ListOfTypes.html#Long64_t">Long64_t</a>);
 SlaveTerminate  -&gt; <a href="./ListOfTypes.html#void">void</a> h1analysisProxy_SlaveTerminate();
 Terminate       -&gt; <a href="./ListOfTypes.html#void">void</a> h1analysisProxy_Terminate();

 If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist
 it is included before the declaration of the proxy class.  This can
 be used in particular to insure that the include files needed by
 the macro file are properly loaded.

 The default histogram is accessible via the variable named 'htemp'.

 If the library of the classes describing the data in the branch is
 loaded, the skeleton will add the needed #include statements and
 give the ability to access the object stored in the branches.

 To draw px using the file hsimple.root (generated by the
 hsimple.C tutorial), we need a file named hsimple.cxx:

     <a href="./ListOfTypes.html#double">double</a> hsimple() {
        return px;
     }

 <a href="./TTree.html#TTree:MakeProxy" title="Int_t TTree::MakeProxy(const char* classname,const char* macrofilename=0,const char* cutfilename=0,const char* option=0,Int_t maxUnrolling=3)">MakeProxy</a> can then be used indirectly via the <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> interface
 as follow:
     new <a href="./TFile.html">TFile</a>(<span class="string">"hsimple.root"</span>)
     ntuple-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"hsimple.cxx"</span>);

 A more complete example is available in the tutorials directory:
   h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C
 which reimplement the selector found in h1analysis.C
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:MakeSelector" href="src/TTree.cxx.html#R5QBmC">MakeSelector</a>(<span class="keyword">const</span> <span class="keyword">char</span>* selector = 0)</span><br />
<div class="funccomm"><pre> Generate skeleton selector class for this tree.

 The following files are produced: selector.h and selector.C.
 If selector is 0, the selector will be called <span class="string">"nameoftree"</span>.

 The generated code in selector.h includes the following:
    - Identification of the original Tree and Input file name
    - Definition of selector class (data and functions)
    - The following class functions:
       - constructor and destructor
       - <a href="./ListOfTypes.html#void">void</a>    Begin(<a href="./TTree.html">TTree</a> *tree)
       - <a href="./ListOfTypes.html#void">void</a>    SlaveBegin(<a href="./TTree.html">TTree</a> *tree)
       - <a href="./ListOfTypes.html#void">void</a>    Init(<a href="./TTree.html">TTree</a> *tree)
       - <a href="./ListOfTypes.html#Bool_t">Bool_t</a>  <a href="./TTree.html#TTree:Notify" title="Bool_t TTree::Notify()">Notify</a>()
       - <a href="./ListOfTypes.html#Bool_t">Bool_t</a>  <a href="./TTree.html#TTree:Process" title="Long64_t TTree::Process(const char* filename,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0) or overloads">Process</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> entry)
       - <a href="./ListOfTypes.html#void">void</a>    Terminate()
       - <a href="./ListOfTypes.html#void">void</a>    SlaveTerminate()

 The class selector derives from <a href="./TSelector.html">TSelector</a>.
 The generated code in selector.C includes empty functions defined above.

 To use this function:
    - connect your Tree file (eg: <a href="./TFile.html">TFile</a> f(<span class="string">"myfile.root"</span>);)
    - T-&gt;<a href="./TTree.html#TTree:MakeSelector" title="Int_t TTree::MakeSelector(const char* selector=0)">MakeSelector</a>(<span class="string">"myselect"</span>);
 where T is the name of the Tree in file myfile.root
 and myselect.h, myselect.C the name of the files created by this function.
 In a <a href="./ROOT.html">ROOT</a> session, you can do:
    root &gt; T-&gt;<a href="./TTree.html#TTree:Process" title="Long64_t TTree::Process(const char* filename,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0) or overloads">Process</a>(<span class="string">"myselect.C"</span>)
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Bool_t">Bool_t</a> <a class="funcname" name="TTree:MemoryFull" href="src/TTree.cxx.html#HAE3zE">MemoryFull</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nbytes)</span><br />
<div class="funccomm"><pre> Check if adding nbytes to memory we are still below MaxVirtualsize.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TTree.html">TTree</a>* <a class="funcname" name="TTree:MergeTrees" href="src/TTree.cxx.html#Y.Vs6E">MergeTrees</a>(<a href="./TList.html">TList</a>* list, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre> Static function merging the trees in the <a href="./TList.html">TList</a> into a new tree.

 Trees in the list can be memory or disk-resident trees.
 The new tree is created in the current directory (memory if <a href="./TROOT.html">gROOT</a>).

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:Merge" href="src/TTree.cxx.html#Q_hy5C">Merge</a>(<a href="./TCollection.html">TCollection</a>* list, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre> <a href="./TTree.html#TTree:Merge" title="Long64_t TTree::Merge(TCollection* list,Option_t* option=&quot;&quot;) or overloads">Merge</a> the trees in the <a href="./TList.html">TList</a> into this tree.

 Returns the total number of entries in the merged tree.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:Merge%1" href="src/TTree.cxx.html#SHSrOE">Merge</a>(<a href="./TCollection.html">TCollection</a>* list, <a href="./TFileMergeInfo.html">TFileMergeInfo</a>* info)</span><br />
<div class="funccomm"><pre> <a href="./TTree.html#TTree:Merge" title="Long64_t TTree::Merge(TCollection* list,Option_t* option=&quot;&quot;) or overloads">Merge</a> the trees in the <a href="./TList.html">TList</a> into this tree.
 If info-&gt;fIsFirst is <a href="./ListOfTypes.html#bool">true</a>, first we clone this <a href="./TTree.html">TTree</a> info the directory
 info-&gt;fOutputDirectory and then overlay the new <a href="./TTree.html">TTree</a> information onto
 this <a href="./TTree.html">TTree</a> object (so that this <a href="./TTree.html">TTree</a> object is now the appropriate to
 use for further merging).

 Returns the total number of entries in the merged tree.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Bool_t">Bool_t</a> <a class="funcname" name="TTree:Notify" href="src/TTree.cxx.html#NCFoiE">Notify</a>()</span><br />
<div class="funccomm"><pre> Function called when loading a new class library.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:OptimizeBaskets" href="src/TTree.cxx.html#XF7z9D">OptimizeBaskets</a>(<a href="./ListOfTypes.html#ULong64_t">ULong64_t</a> maxMemory = 10000000, <a href="./ListOfTypes.html#Float_t">Float_t</a> minComp = 1.1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre>This function may be called after having filled some entries in a Tree
Using the information in the existing branch buffers, it will reassign
new branch buffer sizes to optimize time and memory.

The function computes the best values for branch buffer sizes such that
the total buffer sizes is less than maxMemory and nearby entries written
at the same time.
In case the branch compression factor for the data written so far is less
than compMin, the compression is disabled.

if option =<span class="string">"d"</span> an analysis report is printed.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TPrincipal.html">TPrincipal</a>* <a class="funcname" name="TTree:Principal" href="src/TTree.cxx.html#ANNKfC">Principal</a>(<span class="keyword">const</span> <span class="keyword">char</span>* varexp = <span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span>* selection = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">"np"</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)</span><br />
<div class="funccomm"><pre> Interface to the <a href="./TTree.html#TTree:Principal" title="TPrincipal* TTree::Principal(const char* varexp=&quot;&quot;,const char* selection=&quot;&quot;,Option_t* option=&quot;np&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0)">Principal</a> Components Analysis class.

   Create an instance of <a href="./TPrincipal.html">TPrincipal</a>
   <a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a> it with the selected variables
   if option <span class="string">"n"</span> is specified, the <a href="./TPrincipal.html">TPrincipal</a> object is filled with
                 normalized variables.
   If option <span class="string">"p"</span> is specified, compute the principal components
   If option <span class="string">"p"</span> and <span class="string">"d"</span> print results of analysis
   If option <span class="string">"p"</span> and <span class="string">"h"</span> generate standard histograms
   If option <span class="string">"p"</span> and <span class="string">"c"</span> generate code of conversion functions
   return a pointer to the <a href="./TPrincipal.html">TPrincipal</a> object. It is the user responsability
   to delete this object.
   The option default value is <span class="string">"np"</span>

   see <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> for explanation of the other parameters.

   The created object is  named <span class="string">"principal"</span> and a reference to it
   is added to the list of specials Root objects.
   you can retrieve a pointer to the created object via:
      <a href="./TPrincipal.html">TPrincipal</a> *principal =
        (<a href="./TPrincipal.html">TPrincipal</a>*)<a href="./TROOT.html">gROOT</a>-><a href="./TROOT.html#TROOT:GetListOfSpecials" title="TSeqCollection* TROOT::GetListOfSpecials()">GetListOfSpecials</a>()-><a href="./TCollection.html#TCollection:FindObject" title="TObject* TCollection::FindObject(const char* name) or overloads">FindObject</a>(<span class="string">"principal"</span>);

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:Print" href="src/TTree.cxx.html#KZpm1">Print</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) const</span><br />
<div class="funccomm"><pre> <a href="./TTree.html#TTree:Print" title="void TTree::Print(Option_t* option=&quot;&quot;)">Print</a> a summary of the tree contents.

 If option contains <span class="string">"all"</span> friend trees are also printed.
 If option contains <span class="string">"toponly"</span> only the top level branches are printed.
 If option contains <span class="string">"clusters"</span> information about the cluster of baskets is printed.

 Wildcarding can be used to print only a subset of the branches, e.g.,
 T.<a href="./TTree.html#TTree:Print" title="void TTree::Print(Option_t* option=&quot;&quot;)">Print</a>(<span class="string">"Elec*"</span>) will print all branches with name starting with <span class="string">"Elec"</span>.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:PrintCacheStats" href="src/TTree.cxx.html#ea0l4E">PrintCacheStats</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) const</span><br />
<div class="funccomm"><pre> print statistics about the TreeCache for this tree, like
   ******TreeCache statistics for file: cms2.root ******
   Reading 73921562 bytes in 716 transactions
   Average transaction = 103.242405 Kbytes
   Number of blocks in current cache: 202, total size : 6001193

 if option = <span class="string">"a"</span> the list of blocks in the cache is printed
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:Process" href="src/TTree.cxx.html#JWuGQE">Process</a>(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)</span><br />
<div class="funccomm"><pre> <a href="./TTree.html#TTree:Process" title="Long64_t TTree::Process(const char* filename,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0) or overloads">Process</a> this tree executing the <a href="./TSelector.html">TSelector</a> code in the specified filename.
 The return value is -1 in case of error and <a href="./TSelector.html">TSelector</a>::<a href="./TSelector.html#TSelector:GetStatus" title="Long64_t TSelector::GetStatus()">GetStatus</a>() in
 in case of success.

 The code in filename is loaded (interpreted or compiled, see below),
 filename must contain a valid class implementation derived from <a href="./TSelector.html">TSelector</a>,
 where <a href="./TSelector.html">TSelector</a> has the following member functions:

    Begin():        called everytime a loop on the tree starts,
                    a convenient place to create your histograms.
    SlaveBegin():   called after Begin(), when on PROOF called only on the
                    slave servers.
    <a href="./TTree.html#TTree:Process" title="Long64_t TTree::Process(const char* filename,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0) or overloads">Process</a>():      called for each event, in this function you decide what
                    to read and fill your histograms.
    SlaveTerminate: called at the end of the loop on the tree, when on PROOF
                    called only on the slave servers.
    Terminate():    called at the end of the loop on the tree,
                    a convenient place to draw/fit your histograms.

 If filename is of the form file.C, the file will be interpreted.
 If filename is of the form file.C++, the file file.C will be compiled
 and dynamically loaded.
 If filename is of the form file.C+, the file file.C will be compiled
 and dynamically loaded. At next call, if file.C is older than file.o
 and file.so, the file.C is not compiled, only file.so is loaded.

  NOTE1
  It may be more interesting to invoke directly the other <a href="./TTree.html#TTree:Process" title="Long64_t TTree::Process(const char* filename,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0) or overloads">Process</a> function
  accepting a <a href="./TSelector.html">TSelector</a>* as argument.eg
     MySelector *selector = (MySelector*)<a href="./TSelector.html">TSelector</a>::<a href="./TSelector.html#TSelector:GetSelector" title="TSelector* TSelector::GetSelector(const char* filename)">GetSelector</a>(filename);
     selector-&gt;CallSomeFunction(..);
     mytree.<a href="./TTree.html#TTree:Process" title="Long64_t TTree::Process(const char* filename,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0) or overloads">Process</a>(selector,..);

  NOTE2
  One should not call this function twice with the same selector file
  in the same script. If this is required, proceed as indicated in NOTE1,
  by getting a pointer to the corresponding <a href="./TSelector.html">TSelector</a>,eg
    workaround 1

<a href="./ListOfTypes.html#void">void</a> stubs1() {
   <a href="./TSelector.html">TSelector</a> *selector = <a href="./TSelector.html">TSelector</a>::<a href="./TSelector.html#TSelector:GetSelector" title="TSelector* TSelector::GetSelector(const char* filename)">GetSelector</a>(<span class="string">"h1test.C"</span>);
   <a href="./TFile.html">TFile</a> *f1 = new <a href="./TFile.html">TFile</a>(<span class="string">"stubs_nood_le1.root"</span>);
   <a href="./TTree.html">TTree</a> *h1 = (<a href="./TTree.html">TTree</a>*)f1-&gt;Get(<span class="string">"h1"</span>);
   h1-&gt;<a href="./TTree.html#TTree:Process" title="Long64_t TTree::Process(const char* filename,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0) or overloads">Process</a>(selector);
   <a href="./TFile.html">TFile</a> *f2 = new <a href="./TFile.html">TFile</a>(<span class="string">"stubs_nood_le1_coarse.root"</span>);
   <a href="./TTree.html">TTree</a> *h2 = (<a href="./TTree.html">TTree</a>*)f2-&gt;Get(<span class="string">"h1"</span>);
   h2-&gt;<a href="./TTree.html#TTree:Process" title="Long64_t TTree::Process(const char* filename,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0) or overloads">Process</a>(selector);
}
  or use ACLIC to compile the selector
   workaround 2

<a href="./ListOfTypes.html#void">void</a> stubs2() {
   <a href="./TFile.html">TFile</a> *f1 = new <a href="./TFile.html">TFile</a>(<span class="string">"stubs_nood_le1.root"</span>);
   <a href="./TTree.html">TTree</a> *h1 = (<a href="./TTree.html">TTree</a>*)f1-&gt;Get(<span class="string">"h1"</span>);
   h1-&gt;<a href="./TTree.html#TTree:Process" title="Long64_t TTree::Process(const char* filename,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0) or overloads">Process</a>(<span class="string">"h1test.C+"</span>);
   <a href="./TFile.html">TFile</a> *f2 = new <a href="./TFile.html">TFile</a>(<span class="string">"stubs_nood_le1_coarse.root"</span>);
   <a href="./TTree.html">TTree</a> *h2 = (<a href="./TTree.html">TTree</a>*)f2-&gt;Get(<span class="string">"h1"</span>);
   h2-&gt;<a href="./TTree.html#TTree:Process" title="Long64_t TTree::Process(const char* filename,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0) or overloads">Process</a>(<span class="string">"h1test.C+"</span>);
}
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:Process%1" href="src/TTree.cxx.html#EtPe3C">Process</a>(<span class="keyword">void</span>* selector, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)</span><br />
<div class="funccomm"><pre> <a href="./TTree.html#TTree:Process" title="Long64_t TTree::Process(const char* filename,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0) or overloads">Process</a> this tree executing the code in the specified selector.
 The return value is -1 in case of error and <a href="./TSelector.html">TSelector</a>::<a href="./TSelector.html#TSelector:GetStatus" title="Long64_t TSelector::GetStatus()">GetStatus</a>() in
 in case of success.

   The <a href="./TSelector.html">TSelector</a> class has the following member functions:

    Begin():        called everytime a loop on the tree starts,
                    a convenient place to create your histograms.
    SlaveBegin():   called after Begin(), when on PROOF called only on the
                    slave servers.
    <a href="./TTree.html#TTree:Process" title="Long64_t TTree::Process(const char* filename,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0) or overloads">Process</a>():      called for each event, in this function you decide what
                    to read and fill your histograms.
    SlaveTerminate: called at the end of the loop on the tree, when on PROOF
                    called only on the slave servers.
    Terminate():    called at the end of the loop on the tree,
                    a convenient place to draw/fit your histograms.

  If the Tree (Chain) has an associated EventList, the loop is on the nentries
  of the EventList, starting at firstentry, otherwise the loop is on the
  specified Tree entries.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:Project" href="src/TTree.cxx.html#ySJJiB">Project</a>(<span class="keyword">const</span> <span class="keyword">char</span>* hname, <span class="keyword">const</span> <span class="keyword">char</span>* varexp, <span class="keyword">const</span> <span class="keyword">char</span>* selection = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)</span><br />
<div class="funccomm"><pre> Make a projection of a tree using selections.

 Depending on the value of varexp (described in <a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>) a 1-D, 2-D, etc.,
 projection of the tree will be filled in histogram hname.
 Note that the dimension of hname must match with the dimension of varexp.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TSQLResult.html">TSQLResult</a>* <a class="funcname" name="TTree:Query" href="src/TTree.cxx.html#baJZ9D">Query</a>(<span class="keyword">const</span> <span class="keyword">char</span>* varexp = <span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span>* selection = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)</span><br />
<div class="funccomm"><pre> Loop over entries and return a <a href="./TSQLResult.html">TSQLResult</a> object containing entries following selection.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:ReadFile" href="src/TTree.cxx.html#HLzcjD">ReadFile</a>(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">const</span> <span class="keyword">char</span>* branchDescriptor = <span class="string">""</span>, <span class="keyword">char</span> delimiter = <span class="string">' '</span>)</span><br />
<div class="funccomm"><pre> Create or simply read branches from filename.

 if branchDescriptor = <span class="string">""</span> (default), it is assumed that the Tree descriptor
    is given in the first line of the file with a syntax like
     A/D:Table[2]/F:Ntracks/I:astring/C
  otherwise branchDescriptor must be specified with the above syntax.
  -If the type of the first variable is not specified, it is assumed to be <span class="string">"/F"</span>
  -if the type of any other variable is not specified, the type of the previous
    variable is assumed. eg
      x:y:z      (all variables are assumed of type <span class="string">"F"</span>
      x/D:y:z    (all variables are of type <span class="string">"D"</span>
      x:y/D:z    (x is type <span class="string">"F"</span>, y and z of type <span class="string">"D"</span>
  -If the type is a string of characters. This will read
  subsequent characters until a whitespace is found (whitespace
  characters are considered to be blank, newline and tab).

  delimiter allows for the use of another delimiter besides whitespace.
    This provides support for direct import of common data file formats
    like csv.  If delimiter != <span class="string">' '</span> and branchDescriptor == <span class="string">""</span>, then the
    branch description is taken from the first line in the file, but
    delimiter is used for the branch names tokenization rather than <span class="string">':'</span>.
    Note however that if the values in the first line do not use the
    /[type] syntax, all variables are assumed to be of type <span class="string">"F"</span>.
    If the filename ends with extensions .csv or .CSV and a delimiter is
    not specified (besides <span class="string">' '</span>), the delimiter is automatically set to <span class="string">','</span>.

 Lines in the input file starting with <span class="string">"#"</span> are ignored.
 This function will read and ignore any whitespace characters
 (this includes blank spaces and the newline and tab characters).
 Handles newlines specified with '\n', '\r', or <span class="string">"\r\n"</span>.

 A <a href="./TBranch.html">TBranch</a> object is created for each variable in the expression.
 The total number of rows read from the file is returned.

 FILLING a <a href="./TTree.html">TTree</a> WITH MULTIPLE INPUT TEXT FILES

 To fill a <a href="./TTree.html">TTree</a> with multiple input text files, proceed as indicated above
 for the first input file and omit the second argument for subsequent calls
    T.<a href="./TTree.html#TTree:ReadFile" title="Long64_t TTree::ReadFile(const char* filename,const char* branchDescriptor=&quot;&quot;,char delimiter=' ')">ReadFile</a>(<span class="string">"file1.dat"</span>,<span class="string">"branch descriptor"</span>);
    T.<a href="./TTree.html#TTree:ReadFile" title="Long64_t TTree::ReadFile(const char* filename,const char* branchDescriptor=&quot;&quot;,char delimiter=' ')">ReadFile</a>(<span class="string">"file2.dat"</span>);
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">char</span> <a class="funcname" name="TTree:GetNewlineValue" href="src/TTree.cxx.html#i2YpSB">GetNewlineValue</a>(<a href="./ListOfTypes.html#istream">istream</a>&amp; inputStream)</span><br />
<div class="funccomm"><pre> Determine which newline this file is using.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:ReadStream" href="src/TTree.cxx.html#lpOiND">ReadStream</a>(<a href="./ListOfTypes.html#istream">istream</a>&amp; inputStream, <span class="keyword">const</span> <span class="keyword">char</span>* branchDescriptor = <span class="string">""</span>, <span class="keyword">char</span> delimiter = <span class="string">' '</span>)</span><br />
<div class="funccomm"><pre> Create or simply read branches from an input stream.

 See reference information for <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:ReadFile" title="Long64_t TTree::ReadFile(const char* filename,const char* branchDescriptor=&quot;&quot;,char delimiter=' ')">ReadFile</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:RecursiveRemove" href="src/TTree.cxx.html#Jh2vGB">RecursiveRemove</a>(<a href="./TObject.html">TObject</a>* obj)</span><br />
<div class="funccomm"><pre> Make sure that obj (which is being deleted or will soon be) is no
 longer referenced by this <a href="./TTree.html">TTree</a>.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:Refresh" href="src/TTree.cxx.html#u_PuZB">Refresh</a>()</span><br />
<div class="funccomm"><pre>  <a href="./TTree.html#TTree:Refresh" title="void TTree::Refresh()">Refresh</a> contents of this tree and its branches from the current status on disk.

  One can call this function in case the tree file is being
  updated by another process.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:RemoveFriend" href="src/TTree.cxx.html#E2BL">RemoveFriend</a>(<a href="./TTree.html">TTree</a>* )</span><br />
<div class="funccomm"><pre> Remove a friend from the list of friends.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:Reset" href="src/TTree.cxx.html#R94YLD">Reset</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre> <a href="./TTree.html#TTree:Reset" title="void TTree::Reset(Option_t* option=&quot;&quot;)">Reset</a> baskets, buffers and entries count in all branches and leaves.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:ResetAfterMerge" href="src/TTree.cxx.html#rAw1dE">ResetAfterMerge</a>(<a href="./TFileMergeInfo.html">TFileMergeInfo</a>* )</span><br />
<div class="funccomm"><pre> Resets the state of this <a href="./TTree.html">TTree</a> after a merge (keep the customization but
 forget the data).
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:ResetBranchAddress" href="src/TTree.cxx.html#qcpoaB">ResetBranchAddress</a>(<a href="./TBranch.html">TBranch</a>* )</span><br />
<div class="funccomm"><pre> Tell all of our branches to set their addresses to zero.

 Note: If any of our branches own any objects, they are deleted.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:ResetBranchAddresses" href="src/TTree.cxx.html#GcPtHD">ResetBranchAddresses</a>()</span><br />
<div class="funccomm"><pre> Tell all of our branches to drop their current objects and allocate new ones.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:Scan" href="src/TTree.cxx.html#En7fj">Scan</a>(<span class="keyword">const</span> <span class="keyword">char</span>* varexp = <span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span>* selection = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)</span><br />
<div class="funccomm"><pre> Loop over tree entries and print entries passing selection.

 If varexp is 0 (or <span class="string">""</span>) then print only first 8 columns.
 If varexp = <span class="string">"*"</span> print all columns.
 Otherwise a columns selection can be made using <span class="string">"var1:var2:var3"</span>.
 See <a href="./TTreePlayer.html">TTreePlayer</a>::<a href="./TTreePlayer.html#TTreePlayer:Scan" title="Long64_t TTreePlayer::Scan(const char* varexp,const char* selection,Option_t* option,Long64_t nentries,Long64_t firstentry)">Scan</a> for more information

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Bool_t">Bool_t</a> <a class="funcname" name="TTree:SetAlias" href="src/TTree.cxx.html#fCWTbC">SetAlias</a>(<span class="keyword">const</span> <span class="keyword">char</span>* aliasName, <span class="keyword">const</span> <span class="keyword">char</span>* aliasFormula)</span><br />
<div class="funccomm"><pre> Set a tree variable alias.

  Set an alias for an expression/formula based on the tree 'variables'.

  The content of 'aliasName' can be used in <a href="./TTreeFormula.html">TTreeFormula</a> (i.e. <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>,
  <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Scan" title="Long64_t TTree::Scan(const char* varexp=&quot;&quot;,const char* selection=&quot;&quot;,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0)">Scan</a>, <a href="./TTreeViewer.html">TTreeViewer</a>) and will be evaluated as the content of
  'aliasFormula'.
  If the content of 'aliasFormula' only contains symbol names, periods and
  array index specification (for example event.fTracks[3]), then
  the content of 'aliasName' can be used as the start of symbol.

  If the alias 'aliasName' already existed, it is replaced by the new
  value.

  When being used, the alias can be preceded by an eventual 'Friend Alias'
  (see <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:GetFriendAlias" title="const char* TTree::GetFriendAlias(TTree* )">GetFriendAlias</a>)

  Return <a href="./ListOfTypes.html#bool">true</a> if it was added properly.

  For example:
     tree-&gt;<a href="./TTree.html#TTree:SetAlias" title="Bool_t TTree::SetAlias(const char* aliasName,const char* aliasFormula)">SetAlias</a>(<span class="string">"x1"</span>,<span class="string">"(tdc1[1]-tdc1[0])/49"</span>);
     tree-&gt;<a href="./TTree.html#TTree:SetAlias" title="Bool_t TTree::SetAlias(const char* aliasName,const char* aliasFormula)">SetAlias</a>(<span class="string">"y1"</span>,<span class="string">"(tdc1[3]-tdc1[2])/47"</span>);
     tree-&gt;<a href="./TTree.html#TTree:SetAlias" title="Bool_t TTree::SetAlias(const char* aliasName,const char* aliasFormula)">SetAlias</a>(<span class="string">"x2"</span>,<span class="string">"(tdc2[1]-tdc2[0])/49"</span>);
     tree-&gt;<a href="./TTree.html#TTree:SetAlias" title="Bool_t TTree::SetAlias(const char* aliasName,const char* aliasFormula)">SetAlias</a>(<span class="string">"y2"</span>,<span class="string">"(tdc2[3]-tdc2[2])/47"</span>);
     tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"y2-y1:x2-x1"</span>);

     tree-&gt;<a href="./TTree.html#TTree:SetAlias" title="Bool_t TTree::SetAlias(const char* aliasName,const char* aliasFormula)">SetAlias</a>(<span class="string">"theGoodTrack"</span>,<span class="string">"event.fTracks[3]"</span>);
     tree-&gt;<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"theGoodTrack.fPx"</span>); // same as <span class="string">"event.fTracks[3].fPx"</span>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetAutoFlush" href="src/TTree.cxx.html#wrUFEB">SetAutoFlush</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> autof = 30000000)</span><br />
<div class="funccomm"><pre> This function may be called at the start of a program to change
 the default value for <a href="./TTree.html#TTree:fAutoFlush" title="Long64_t TTree::fAutoFlush">fAutoFlush</a>.

     CASE 1 : autof &gt; 0

 autof is the number of consecutive entries after which <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a> will
 flush all branch buffers to disk.

     CASE 2 : autof &lt; 0

 When filling the Tree the branch buffers will be flushed to disk when
 more than autof bytes have been written to the file. At the first <a href="./TTree.html#TTree:FlushBaskets" title="Int_t TTree::FlushBaskets()">FlushBaskets</a>
 <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a> will replace <a href="./TTree.html#TTree:fAutoFlush" title="Long64_t TTree::fAutoFlush">fAutoFlush</a> by the current value of <a href="./TTree.html#TTree:fEntries" title="Long64_t TTree::fEntries">fEntries</a>.

 Calling this function with autof&lt;0 is interesting when it is hard to estimate
 the size of one entry. This value is also independent of the Tree.

 The Tree is initialized with <a href="./TTree.html#TTree:fAutoFlush" title="Long64_t TTree::fAutoFlush">fAutoFlush</a>=-30000000, ie that, by default,
 the first AutoFlush will be done when 30 MBytes of data are written to the file.

     CASE 3 : autof = 0

 The AutoFlush mechanism is disabled.

 Flushing the buffers at regular intervals optimize the location of
 consecutive entries on the disk by creating clusters of baskets.

 A cluster of baskets is a set of baskets that contains all
 the data for a (consecutive) set of entries and that is stored
 consecutively on the disk.   When reading all the branches, this
 is the minimum set of baskets that the <a href="./TTreeCache.html">TTreeCache</a> will read.


</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetAutoSave" href="src/TTree.cxx.html#c4wH9">SetAutoSave</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> autos = 300000000)</span><br />
<div class="funccomm"><pre>This function may be called at the start of a program to change
the default value for <a href="./TTree.html#TTree:fAutoSave" title="Long64_t TTree::fAutoSave">fAutoSave</a>(300000000, ie 300 MBytes).
When filling the Tree the branch buffers as well as the Tree header
will be flushed to disk when more than <a href="./TTree.html#TTree:fAutoSave" title="Long64_t TTree::fAutoSave">fAutoSave</a> bytes have been written to the file.
In case of a program crash, it will be possible to recover the data in the Tree
up to the last <a href="./TTree.html#TTree:AutoSave" title="Long64_t TTree::AutoSave(Option_t* option=&quot;&quot;)">AutoSave</a> point.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetBasketSize" href="src/TTree.cxx.html#lUKTLB">SetBasketSize</a>(<span class="keyword">const</span> <span class="keyword">char</span>* bname, <a href="./ListOfTypes.html#Int_t">Int_t</a> buffsize = 16000)</span><br />
<div class="funccomm"><pre> Set a branch's basket size.

 bname is the name of a branch.
 if bname=<span class="string">"*"</span>, apply to all branches.
 if bname=<span class="string">"xxx*"</span>, apply to all branches with name starting with xxx
 see <a href="./TRegexp.html">TRegexp</a> for wildcarding options
 buffsize = branc basket size

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:SetBranchAddress%2" href="src/TTree.cxx.html#uSIsj">SetBranchAddress</a>(<span class="keyword">const</span> <span class="keyword">char</span>* bname, <span class="keyword">void</span>** add, <a href="./TBranch.html">TBranch</a>** ptr = 0)</span><br />
<div class="funccomm"><pre> Change branch address, dealing with clone trees properly.
 See <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:CheckBranchAddressType" title="Int_t TTree::CheckBranchAddressType(TBranch* branch,TClass* ptrClass,EDataType datatype,Bool_t ptr)">CheckBranchAddressType</a> for the semantic of the return value.

 Note: See the comments in <a href="./TBranchElement.html">TBranchElement</a>::<a href="./TBranchElement.html#TBranchElement:SetAddress" title="void TBranchElement::SetAddress(void* addobj)">SetAddress</a>() for the
       meaning of the addr parameter.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:SetBranchAddress" href="src/TTree.cxx.html#pBIqKC">SetBranchAddress</a>(<span class="keyword">const</span> <span class="keyword">char</span>* bname, <span class="keyword">void</span>* add, <a href="./TClass.html">TClass</a>* realClass, EDataType datatype, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> isptr)</span><br />
<div class="funccomm"><pre> Verify the validity of the type of addr before calling <a href="./TTree.html#TTree:SetBranchAddress" title="Int_t TTree::SetBranchAddress(const char* bname,void* add,TClass* realClass,EDataType datatype,Bool_t isptr) or overloads">SetBranchAddress</a>.
 See <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:CheckBranchAddressType" title="Int_t TTree::CheckBranchAddressType(TBranch* branch,TClass* ptrClass,EDataType datatype,Bool_t ptr)">CheckBranchAddressType</a> for the semantic of the return value.

 Note: See the comments in <a href="./TBranchElement.html">TBranchElement</a>::<a href="./TBranchElement.html#TBranchElement:SetAddress" title="void TBranchElement::SetAddress(void* addobj)">SetAddress</a>() for the
       meaning of the addr parameter.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:SetBranchAddress%1" href="src/TTree.cxx.html#vjmNQD">SetBranchAddress</a>(<span class="keyword">const</span> <span class="keyword">char</span>* bname, <span class="keyword">void</span>* add, <a href="./TBranch.html">TBranch</a>** ptr, <a href="./TClass.html">TClass</a>* realClass, EDataType datatype, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> isptr)</span><br />
<div class="funccomm"><pre> Verify the validity of the type of addr before calling <a href="./TTree.html#TTree:SetBranchAddress" title="Int_t TTree::SetBranchAddress(const char* bname,void* add,TClass* realClass,EDataType datatype,Bool_t isptr) or overloads">SetBranchAddress</a>.
 See <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:CheckBranchAddressType" title="Int_t TTree::CheckBranchAddressType(TBranch* branch,TClass* ptrClass,EDataType datatype,Bool_t ptr)">CheckBranchAddressType</a> for the semantic of the return value.

 Note: See the comments in <a href="./TBranchElement.html">TBranchElement</a>::<a href="./TBranchElement.html#TBranchElement:SetAddress" title="void TBranchElement::SetAddress(void* addobj)">SetAddress</a>() for the
       meaning of the addr parameter.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:SetBranchAddressImp" href="src/TTree.cxx.html#w2UEPE">SetBranchAddressImp</a>(<a href="./TBranch.html">TBranch</a>* branch, <span class="keyword">void</span>* addr, <a href="./TBranch.html">TBranch</a>** ptr)</span><br />
<div class="funccomm"><pre> Change branch address, dealing with clone trees properly.
 See <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:CheckBranchAddressType" title="Int_t TTree::CheckBranchAddressType(TBranch* branch,TClass* ptrClass,EDataType datatype,Bool_t ptr)">CheckBranchAddressType</a> for the semantic of the return value.

 Note: See the comments in <a href="./TBranchElement.html">TBranchElement</a>::<a href="./TBranchElement.html#TBranchElement:SetAddress" title="void TBranchElement::SetAddress(void* addobj)">SetAddress</a>() for the
       meaning of the addr parameter.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetBranchStatus" href="src/TTree.cxx.html#ZG86DD">SetBranchStatus</a>(<span class="keyword">const</span> <span class="keyword">char</span>* bname, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> status = 1, <a href="./ListOfTypes.html#UInt_t">UInt_t</a>* found = 0)</span><br />
<div class="funccomm"><pre> Set branch status to <a href="./TTree.html#TTree:Process" title="Long64_t TTree::Process(const char* filename,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0) or overloads">Process</a> or DoNotProcess.

  When reading a Tree, by default, all branches are read.
  One can speed up considerably the analysis phase by activating
  only the branches that hold variables involved in a query.

     bname is the name of a branch.
     if bname=<span class="string">"*"</span>, apply to all branches.
     if bname=<span class="string">"xxx*"</span>, apply to all branches with name starting with xxx
     see <a href="./TRegexp.html">TRegexp</a> for wildcarding options
      status = 1  branch will be processed
             = 0  branch will not be processed
    Example:
  Assume a tree T with sub-branches a,b,c,d,e,f,g,etc..
  when doing T.<a href="./TTree.html#TTree:GetEntry" title="Int_t TTree::GetEntry(Long64_t entry=0,Int_t getall=0)">GetEntry</a>(i) all branches are read for entry i.
  to read only the branches c and e, one can do
    T.<a href="./TTree.html#TTree:SetBranchStatus" title="void TTree::SetBranchStatus(const char* bname,Bool_t status=1,UInt_t* found=0)">SetBranchStatus</a>(<span class="string">"*"</span>,0); //disable all branches
    T.<a href="./TTree.html#TTree:SetBranchStatus" title="void TTree::SetBranchStatus(const char* bname,Bool_t status=1,UInt_t* found=0)">SetBranchStatus</a>(<span class="string">"c"</span>,1);
    T.setBranchStatus(<span class="string">"e"</span>,1);
    T.<a href="./TTree.html#TTree:GetEntry" title="Int_t TTree::GetEntry(Long64_t entry=0,Int_t getall=0)">GetEntry</a>(i);

  bname is interpreted as a wildcarded <a href="./TRegexp.html">TRegexp</a> (see <a href="./TRegexp.html">TRegexp</a>::<a href="./TRegexp.html#TRegexp:MakeWildcard" title="const char* TRegexp::MakeWildcard(const char* re)">MakeWildcard</a>).
  Thus, <span class="string">"a*b"</span> or <span class="string">"a.*b"</span> matches branches starting with <span class="string">"a"</span> and ending with
  <span class="string">"b"</span>, but not any other branch with an <span class="string">"a"</span> followed at some point by a
  <span class="string">"b"</span>. For this second behavior, use <span class="string">"*a*b*"</span>. Note that TRegExp does not
  support <span class="string">'|'</span>, and so you cannot select, e.g. track and shower branches
  with <span class="string">"track|shower"</span>.

  WARNING! WARNING! WARNING!
  <a href="./TTree.html#TTree:SetBranchStatus" title="void TTree::SetBranchStatus(const char* bname,Bool_t status=1,UInt_t* found=0)">SetBranchStatus</a> is matching the branch based on match of the branch
  'name' and not on the branch hierarchy! In order to be able to
  selectively enable a top level object that is 'split' you need to make
  sure the name of the top level branch is prefixed to the sub-branches'
  name (by adding a dot (<span class="string">'.'</span>) at the end of the <a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a> creation and use the
  corresponding bname.

  I.e If your Tree has been created in split mode with a parent branch <span class="string">"parent."</span>
  (note the trailing dot).
     T.<a href="./TTree.html#TTree:SetBranchStatus" title="void TTree::SetBranchStatus(const char* bname,Bool_t status=1,UInt_t* found=0)">SetBranchStatus</a>(<span class="string">"parent"</span>,1);
  will not activate the sub-branches of <span class="string">"parent"</span>. You should do:
     T.<a href="./TTree.html#TTree:SetBranchStatus" title="void TTree::SetBranchStatus(const char* bname,Bool_t status=1,UInt_t* found=0)">SetBranchStatus</a>(<span class="string">"parent*"</span>,1);

  Without the trailing dot in the branch creation you have no choice but to
  call <a href="./TTree.html#TTree:SetBranchStatus" title="void TTree::SetBranchStatus(const char* bname,Bool_t status=1,UInt_t* found=0)">SetBranchStatus</a> explicitly for each of the sub branches.


  An alternative to this function is to read directly and only
  the interesting branches. Example:
    <a href="./TBranch.html">TBranch</a> *brc = T.<a href="./TTree.html#TTree:GetBranch" title="TBranch* TTree::GetBranch(const char* name)">GetBranch</a>(<span class="string">"c"</span>);
    <a href="./TBranch.html">TBranch</a> *bre = T.<a href="./TTree.html#TTree:GetBranch" title="TBranch* TTree::GetBranch(const char* name)">GetBranch</a>(<span class="string">"e"</span>);
    brc-&gt;<a href="./TTree.html#TTree:GetEntry" title="Int_t TTree::GetEntry(Long64_t entry=0,Int_t getall=0)">GetEntry</a>(i);
    bre-&gt;<a href="./TTree.html#TTree:GetEntry" title="Int_t TTree::GetEntry(Long64_t entry=0,Int_t getall=0)">GetEntry</a>(i);

  If found is not 0, the number of branch(es) found matching the regular
  expression is returned in *found AND the error message 'unknown branch'
  is suppressed.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetBranchStyle" href="src/TTree.cxx.html#SpFr6D">SetBranchStyle</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> style = 1)</span><br />
<div class="funccomm"><pre> Set the current branch style.  (static function)

 style = 0 old <a href="./TTree.html#TTree:Branch" title="Int_t TTree::Branch(TCollection* list,Int_t bufsize=32000,Int_t splitlevel=99,const char* name=&quot;&quot;) or overloads">Branch</a>
 style = 1 new <a href="./TTree.html#TTree:Bronch" title="TBranch* TTree::Bronch(const char* name,const char* classname,void* addobj,Int_t bufsize=32000,Int_t splitlevel=99)">Bronch</a>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetCacheSize" href="src/TTree.cxx.html#BXGWnE">SetCacheSize</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> cachesize = -1)</span><br />
<div class="funccomm"><pre> Set maximum size of the file cache .
 if cachesize = 0 the existing cache (if any) is deleted.
 if cachesize = -1 (default) it is set to the AutoFlush value when writing
    the Tree (default is 30 MBytes).
 WARNING: Currently only ONE <a href="./TTree.html">TTree</a> object can be 'cached' per <a href="./TFile.html">TFile</a> object.
 This call disable the cache for the other <a href="./TTree.html">TTree</a> objects read from the same
 <a href="./TFile.html">TFile</a> object as this <a href="./TTree.html">TTree</a> (The <a href="./TTree.html#TTree:SetCacheSize" title="void TTree::SetCacheSize(Long64_t cachesize=-1)">SetCacheSize</a> called __last__ wins).
 To cache multiple <a href="./TTree.html">TTree</a> objects in the same <a href="./ROOT.html">ROOT</a> file, you must create
 one <a href="./TFile.html">TFile</a> object per <a href="./TTree.html">TTree</a> object.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetCacheEntryRange" href="src/TTree.cxx.html#VD0m8D">SetCacheEntryRange</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> first, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> last)</span><br />
<div class="funccomm"><pre>interface to <a href="./TTreeCache.html">TTreeCache</a> to set the cache entry range
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetCacheLearnEntries" href="src/TTree.cxx.html#SPMPyB">SetCacheLearnEntries</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> n = 10)</span><br />
<div class="funccomm"><pre>interface to <a href="./TTreeCache.html">TTreeCache</a> to set the number of entries for the learning phase
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetCircular" href="src/TTree.cxx.html#YYUGL">SetCircular</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> maxEntries)</span><br />
<div class="funccomm"><pre> Enable/Disable circularity for this tree.

 if maxEntries &gt; 0 a maximum of maxEntries is kept in one buffer/basket
 per branch in memory.
   Note that when this function is called (maxEntries&gt;0) the Tree
   must be empty or having only one basket per branch.
 if maxEntries &lt;= 0 the tree circularity is disabled.

 NOTE 1:
  Circular Trees are interesting in online real time environments
  to store the results of the last maxEntries events.
 NOTE 2:
  Calling <a href="./TTree.html#TTree:SetCircular" title="void TTree::SetCircular(Long64_t maxEntries)">SetCircular</a> with maxEntries &lt;= 0 is necessary before
  merging circular Trees that have been saved on files.
 NOTE 3:
  <a href="./TTree.html#TTree:SetCircular" title="void TTree::SetCircular(Long64_t maxEntries)">SetCircular</a> with maxEntries &lt;= 0 is automatically called
  by <a href="./TChain.html">TChain</a>::<a href="./TChain.html#TChain:Merge" title="Long64_t TChain::Merge(const char* name,Option_t* option=&quot;&quot;) or overloads">Merge</a>
 NOTE 4:
  A circular Tree can still be saved in a file. When read back,
  it is still a circular Tree and can be filled again.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetDebug" href="src/TTree.cxx.html#OqYsO">SetDebug</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> level = 1, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> min = 0, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> max = 9999999)</span><br />
<div class="funccomm"><pre> Set the debug level and the debug range.

 For entries in the debug range, the functions <a href="./TBranchElement.html">TBranchElement</a>::<a href="./TBranchElement.html#TBranchElement:Fill" title="Int_t TBranchElement::Fill()">Fill</a>
 and <a href="./TBranchElement.html">TBranchElement</a>::<a href="./TBranchElement.html#TBranchElement:GetEntry" title="Int_t TBranchElement::GetEntry(Long64_t entry=0,Int_t getall=0)">GetEntry</a> will print the number of bytes filled
 or read for each branch.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetDefaultEntryOffsetLen" href="src/TTree.cxx.html#r6._qD">SetDefaultEntryOffsetLen</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> newdefault, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> updateExisting = <a href="./ListOfTypes.html#Bool_t">kFALSE</a>)</span><br />
<div class="funccomm"><pre> Update the default value for the branch's fEntryOffsetLen.
 If updateExisting is <a href="./ListOfTypes.html#bool">true</a>, also update all the existing branches.
 If newdefault is less than 10, the new default value will be 10.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetDirectory" href="src/TTree.cxx.html#hE2lDE">SetDirectory</a>(<a href="./TDirectory.html">TDirectory</a>* <a href="./TString.html">dir</a>)</span><br />
<div class="funccomm"><pre> Change the tree's directory.

 Remove reference to this tree from current directory and
 add reference to new directory <a href="./TString.html">dir</a>.  The <a href="./TString.html">dir</a> parameter can
 be 0 in which case the tree does not belong to any directory.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:SetEntries" href="src/TTree.cxx.html#yjIkF">SetEntries</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> n = -1)</span><br />
<div class="funccomm"><pre> Change number of entries in the tree.

 If n &gt;= 0, set number of entries in the tree = n.

 If n &lt; 0, set number of entries in the tree to match the
 number of entries in each branch. (default for n is -1)

 This function should be called only when one fills each branch
 independently via <a href="./TBranch.html">TBranch</a>::<a href="./TBranch.html#TBranch:Fill" title="Int_t TBranch::Fill()">Fill</a> without calling <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a>.
 Calling <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:SetEntries" title="Long64_t TTree::SetEntries(Long64_t n=-1)">SetEntries</a>() make sense only if the number of entries
 in each branch is identical, a warning is issued otherwise.
 The function returns the number of entries.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetEntryList" href="src/TTree.cxx.html#vM96PE">SetEntryList</a>(<a href="./TEntryList.html">TEntryList</a>* list, <a href="./ListOfTypes.html#Option_t">Option_t</a>* opt = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre>Set an EntryList
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetEventList" href="src/TTree.cxx.html#CKRRDB">SetEventList</a>(<a href="./TEventList.html">TEventList</a>* list)</span><br />
<div class="funccomm"><pre>This function transfroms the given <a href="./TEventList.html">TEventList</a> into a <a href="./TEntryList.html">TEntryList</a>
The new <a href="./TEntryList.html">TEntryList</a> is owned by the <a href="./TTree.html">TTree</a> and gets deleted when the tree
is deleted. This <a href="./TEntryList.html">TEntryList</a> can be returned by <a href="./TTree.html#TTree:GetEntryList" title="TEntryList* TTree::GetEntryList()">GetEntryList</a>() function.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetEstimate" href="src/TTree.cxx.html#DyfnPE">SetEstimate</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 10000)</span><br />
<div class="funccomm"><pre> Set number of entries to estimate variable limits.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetFileNumber" href="src/TTree.cxx.html#sUO.OC">SetFileNumber</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> number = 0)</span><br />
<div class="funccomm"><pre> Set <a href="./TTree.html#TTree:fFileNumber" title="Int_t TTree::fFileNumber">fFileNumber</a> to number.
 <a href="./TTree.html#TTree:fFileNumber" title="Int_t TTree::fFileNumber">fFileNumber</a> is used by <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a> to set the file name
 for a new file to be created when the current file exceeds fgTreeMaxSize.
    (see <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:ChangeFile" title="TFile* TTree::ChangeFile(TFile* file)">ChangeFile</a>)
 if <a href="./TTree.html#TTree:fFileNumber" title="Int_t TTree::fFileNumber">fFileNumber</a>=10, the new file name will have a suffix <span class="string">"_11"</span>,
 ie, <a href="./TTree.html#TTree:fFileNumber" title="Int_t TTree::fFileNumber">fFileNumber</a> is incremented before setting the file name
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetMakeClass" href="src/TTree.cxx.html#a3R2o">SetMakeClass</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> make)</span><br />
<div class="funccomm"><pre> Set all the branches in this <a href="./TTree.html">TTree</a> to be in decomposed object mode
 (also known as <a href="./TTree.html#TTree:MakeClass" title="Int_t TTree::MakeClass(const char* classname=0,Option_t* option=&quot;&quot;)">MakeClass</a> mode).
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetMaxTreeSize" href="src/TTree.cxx.html#Szc5yC">SetMaxTreeSize</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> maxsize = 1900000000)</span><br />
<div class="funccomm"><pre> Set the maximum size in bytes of a Tree file (static function).
 The default size is 100000000000LL, ie 100 Gigabytes.

 In <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Fill" title="Int_t TTree::Fill()">Fill</a>, when the file has a size &gt; <a href="./TTree.html#TTree:fgMaxTreeSize" title="Long64_t TTree::fgMaxTreeSize">fgMaxTreeSize</a>,
 the function closes the current file and starts writing into
 a new file with a name of the style <span class="string">"file_1.root"</span> if the original
 requested file name was <span class="string">"file.root"</span>.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetName" href="src/TTree.cxx.html#SOx9NE">SetName</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span><br />
<div class="funccomm"><pre> Change the name of this tree.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetObject" href="src/TTree.cxx.html#MwAm2">SetObject</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* title)</span><br />
<div class="funccomm"><pre> Change the name and title of this tree.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetParallelUnzip" href="src/TTree.cxx.html#aCxk.B">SetParallelUnzip</a>(<a href="./ListOfTypes.html#Bool_t">Bool_t</a> opt = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, <a href="./ListOfTypes.html#Float_t">Float_t</a> RelSize = -1)</span><br />
<div class="funccomm"><pre>enable or disable parallel unzipping of Tree buffers
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetTreeIndex" href="src/TTree.cxx.html#H3ofAE">SetTreeIndex</a>(<a href="./TVirtualIndex.html">TVirtualIndex</a>* index)</span><br />
<div class="funccomm"><pre> The current TreeIndex is replaced by the new index.
 Note that this function does not delete the previous index.
 This gives the possibility to play with more than one index, e.g.,
 <a href="./TVirtualIndex.html">TVirtualIndex</a>* oldIndex = tree.<a href="./TTree.html#TTree:GetTreeIndex" title="TVirtualIndex* TTree::GetTreeIndex()">GetTreeIndex</a>();
 tree.<a href="./TTree.html#TTree:SetTreeIndex" title="void TTree::SetTreeIndex(TVirtualIndex* index)">SetTreeIndex</a>(newIndex);
 tree.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>();
 tree.<a href="./TTree.html#TTree:SetTreeIndex" title="void TTree::SetTreeIndex(TVirtualIndex* index)">SetTreeIndex</a>(oldIndex);
 tree.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(); etc
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetWeight" href="src/TTree.cxx.html#XnsFJE">SetWeight</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> w = 1, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre> Set tree weight.

 The weight is used by <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> to automatically weight each
 selected entry in the resulting histogram.

 For example the equivalent of:

      T.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"x"</span>, <span class="string">"w"</span>)

 is:

      T.<a href="./TTree.html#TTree:SetWeight" title="void TTree::SetWeight(Double_t w=1,Option_t* option=&quot;&quot;)">SetWeight</a>(w);
      T.<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(<span class="string">"x"</span>);

 This function is redefined by <a href="./TChain.html">TChain</a>::<a href="./TChain.html#TChain:SetWeight" title="void TChain::SetWeight(Double_t w=1,Option_t* option=&quot;&quot;)">SetWeight</a>. In case of a
 <a href="./TChain.html">TChain</a>, an option <span class="string">"global"</span> may be specified to set the same weight
 for all trees in the <a href="./TChain.html">TChain</a> instead of the default behaviour
 using the weights of each tree in the chain (see <a href="./TChain.html">TChain</a>::<a href="./TChain.html#TChain:SetWeight" title="void TChain::SetWeight(Double_t w=1,Option_t* option=&quot;&quot;)">SetWeight</a>).
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:Show" href="src/TTree.cxx.html#LEHt6D">Show</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> entry = -1, <a href="./ListOfTypes.html#Int_t">Int_t</a> lenmax = 20)</span><br />
<div class="funccomm"><pre> <a href="./TTree.html#TTree:Print" title="void TTree::Print(Option_t* option=&quot;&quot;)">Print</a> values of all active leaves for entry.

 if entry==-1, print current entry (default)
 if a leaf is an array, a maximum of lenmax elements is printed.

</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:StartViewer" href="src/TTree.cxx.html#qaVKDD">StartViewer</a>()</span><br />
<div class="funccomm"><pre> Start the <a href="./TTreeViewer.html">TTreeViewer</a> on this tree.

  ww is the width of the canvas in pixels
  wh is the height of the canvas in pixels
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:StopCacheLearningPhase" href="src/TTree.cxx.html#IHZR">StopCacheLearningPhase</a>()</span><br />
<div class="funccomm"><pre> stop the cache learning phase
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:Streamer" href="src/TTree.cxx.html#NffUDC">Streamer</a>(<a href="./TBuffer.html">TBuffer</a>&amp; b)</span><br />
<div class="funccomm"><pre> Stream a class object.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:UnbinnedFit" href="src/TTree.cxx.html#Jeu.UD">UnbinnedFit</a>(<span class="keyword">const</span> <span class="keyword">char</span>* funcname, <span class="keyword">const</span> <span class="keyword">char</span>* varexp, <span class="keyword">const</span> <span class="keyword">char</span>* selection = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> nentries = 1000000000, <a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry = 0)</span><br />
<div class="funccomm"><pre> Unbinned fit of one or more variable(s) from a tree.

  funcname is a <a href="./TF1.html">TF1</a> function.

  See <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a> for explanations of the other parameters.

   <a href="./TTree.html#TTree:Fit" title="Int_t TTree::Fit(const char* funcname,const char* varexp,const char* selection=&quot;&quot;,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0)">Fit</a> the variable varexp using the function funcname using the
   selection cuts given by selection.

   The list of fit options is given in parameter option.
      option = <span class="string">"Q"</span> Quiet mode (minimum printing)
             = <span class="string">"V"</span> Verbose mode (default is between Q and V)
             = <span class="string">"E"</span> Perform better Errors estimation using Minos technique
             = <span class="string">"M"</span> More. Improve fit results

   You can specify boundary limits for some or all parameters via
        func-&gt;SetParLimits(p_number, parmin, parmax);
   if parmin&gt;=parmax, the parameter is fixed
   Note that you are not forced to fix the limits for all parameters.
   For example, if you fit a function with 6 parameters, you can do:
     func-&gt;SetParameters(0,3.1,1.e-6,0.1,-8,100);
     func-&gt;SetParLimits(4,-10,-4);
     func-&gt;SetParLimits(5, 1,1);
   With this setup, parameters 0-&gt;3 can vary freely
   Parameter 4 has boundaries [-10,-4] with initial value -8
   Parameter 5 is fixed to 100.

   For the fit to be meaningful, the function must be self-normalized.

   i.e. It must have the same integral regardless of the parameter
   settings.  Otherwise the fit will effectively just maximize the
   area.

   It is mandatory to have a normalization variable
   which is fixed for the fit.  e.g.

     <a href="./TF1.html">TF1</a>* f1 = new <a href="./TF1.html">TF1</a>(<span class="string">"f1"</span>, <span class="string">"gaus(0)/sqrt(2*3.14159)/[2]"</span>, 0, 5);
     f1-&gt;SetParameters(1, 3.1, 0.01);
     f1-&gt;SetParLimits(0, 1, 1); // fix the normalization parameter to 1
     data-&gt;<a href="./TTree.html#TTree:UnbinnedFit" title="Int_t TTree::UnbinnedFit(const char* funcname,const char* varexp,const char* selection=&quot;&quot;,Option_t* option=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0)">UnbinnedFit</a>(<span class="string">"f1"</span>, <span class="string">"jpsimass"</span>, <span class="string">"jpsipt&gt;3.0"</span>);


   1, 2 and 3 Dimensional fits are supported.
   See also <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:Fit" title="Int_t TTree::Fit(const char* funcname,const char* varexp,const char* selection=&quot;&quot;,Option_t* option=&quot;&quot;,Option_t* goption=&quot;&quot;,Long64_t nentries=1000000000,Long64_t firstentry=0)">Fit</a>

    Return status

   The function return the status of the fit in the following form
     fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult
   The fitResult is 0 is the fit is OK.
   The fitResult is negative in case of an error not connected with the fit.
   The number of entries used in the fit can be obtained via
     mytree.<a href="./TTree.html#TTree:GetSelectedRows" title="Long64_t TTree::GetSelectedRows()">GetSelectedRows</a>();
   If the number of selected entries is null the function returns -1
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:UseCurrentStyle" href="src/TTree.cxx.html#ayXWjD">UseCurrentStyle</a>()</span><br />
<div class="funccomm"><pre> Replace current attributes by current style.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:Write%1" href="src/TTree.cxx.html#wUWl4">Write</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> option = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 0) const</span><br />
<div class="funccomm"><pre> <a href="./TTree.html#TTree:Write" title="Int_t TTree::Write(const char* name=0,Int_t option=0,Int_t bufsize=0) or overloads">Write</a> this object to the current directory. For more see <a href="./TObject.html">TObject</a>::<a href="./TObject.html#TObject:Write" title="Int_t TObject::Write(const char* name=0,Int_t option=0,Int_t bufsize=0) or overloads">Write</a>
 <a href="./TTree.html#TTree:Write" title="Int_t TTree::Write(const char* name=0,Int_t option=0,Int_t bufsize=0) or overloads">Write</a> calls <a href="./TTree.html">TTree</a>::<a href="./TTree.html#TTree:FlushBaskets" title="Int_t TTree::FlushBaskets()">FlushBaskets</a> before writing the tree.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:Write" href="src/TTree.cxx.html#FlVi_D">Write</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> option = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 0)</span><br />
<div class="funccomm"><pre> <a href="./TTree.html#TTree:Write" title="Int_t TTree::Write(const char* name=0,Int_t option=0,Int_t bufsize=0) or overloads">Write</a> this object to the current directory. For more see <a href="./TObject.html">TObject</a>::<a href="./TObject.html#TObject:Write" title="Int_t TObject::Write(const char* name=0,Int_t option=0,Int_t bufsize=0) or overloads">Write</a>
 If option &amp; kFlushBasket, call FlushBasket before writing the tree.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="TTree:TTree" href="src/TTree.h.html#T8taxD">TTree</a>(<span class="keyword">const</span> <a href="./TTree.html">TTree</a>&amp; tt)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./TTree.html">TTree</a>&amp; <a class="funcname" name="TTree:operator_" href="src/TTree.h.html#YiSRVC">operator=</a>(<span class="keyword">const</span> <a href="./TTree.html">TTree</a>&amp; tt)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:AddTotBytes" href="src/TTree.h.html#NZAfOB">AddTotBytes</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> tot)</span><br />

<div class="code"><code class="inlinecode">{ <a href="./TTree.html#TTree:fTotBytes" title="Long64_t TTree::fTotBytes">fTotBytes</a> += tot; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:AddZipBytes" href="src/TTree.h.html#RhzBwE">AddZipBytes</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> zip)</span><br />

<div class="code"><code class="inlinecode">{ <a href="./TTree.html#TTree:fZipBytes" title="Long64_t TTree::fZipBytes">fZipBytes</a> += zip; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:Branch" href="src/TTree.h.html#jf4zoD">Branch</a>(<a href="./TCollection.html">TCollection</a>* list, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel = 99, <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">""</span>)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:Branch%1" href="src/TTree.h.html#aIUroC">Branch</a>(<a href="./TList.html">TList</a>* list, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel = 99)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:Branch%2" href="src/TTree.h.html#ZVjYkE">Branch</a>(<span class="keyword">const</span> <span class="keyword">char</span>* folder, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000, <a href="./ListOfTypes.html#Int_t">Int_t</a> splitlevel = 99)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">return</span> <a class="funcname" name="TTree:Branch%3" href="src/TTree.h.html#mznnjB">Branch</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">void</span>* address, <span class="keyword">const</span> <span class="keyword">char</span>* leaflist, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 32000)</span><br />
<div class="funccomm"><pre> Overload to avoid confusion between this signature and the template instance.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:Debug" href="src/TTree.h.html#cI2EoC">Debug</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fDebug" title="Int_t TTree::fDebug">fDebug</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:Draw" href="src/TTree.h.html#aXd4PD">Draw</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* opt)</span><br />

<div class="code"><code class="inlinecode">{ <a href="./TTree.html#TTree:Draw" title="void TTree::Draw(Option_t* opt) or overloads">Draw</a>(opt, <span class="string">""</span>, <span class="string">""</span>, 1000000000, 0); }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetAutoFlush" href="src/TTree.h.html#ggHdOB">GetAutoFlush</a>() const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./TTree.html#TTree:fAutoFlush" title="Long64_t TTree::fAutoFlush">fAutoFlush</a>;}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetAutoSave" href="src/TTree.h.html#rKTsfB">GetAutoSave</a>() const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./TTree.html#TTree:fAutoSave" title="Long64_t TTree::fAutoSave">fAutoSave</a>;}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TBranchRef.html">TBranchRef</a>     * <a class="funcname" name="TTree:GetBranchRef" href="src/TTree.h.html#pwsid">GetBranchRef</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fBranchRef" title="TBranchRef* TTree::fBranchRef">fBranchRef</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetCacheSize" href="src/TTree.h.html#NBR2i">GetCacheSize</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fCacheSize" title="Long64_t TTree::fCacheSize">fCacheSize</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname">TClusterIterator <a class="funcname" name="TTree:GetClusterIterator" href="src/TTree.h.html#W0GON">GetClusterIterator</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> firstentry)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetChainEntryNumber" href="src/TTree.h.html#nxy8wB">GetChainEntryNumber</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> entry) const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> entry; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetChainOffset" href="src/TTree.h.html#IvaLkE">GetChainOffset</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fChainOffset" title="Long64_t TTree::fChainOffset">fChainOffset</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:GetDefaultEntryOffsetLen" href="src/TTree.h.html#hvQNjB">GetDefaultEntryOffsetLen</a>() const</span><br />

<div class="code"><code class="inlinecode">{<span class="keyword">return</span> <a href="./TTree.html#TTree:fDefaultEntryOffsetLen" title="Int_t TTree::fDefaultEntryOffsetLen">fDefaultEntryOffsetLen</a>;}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetDebugMax" href="src/TTree.h.html#pfU_J">GetDebugMax</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fDebugMax" title="Long64_t TTree::fDebugMax">fDebugMax</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetDebugMin" href="src/TTree.h.html#FMoej">GetDebugMin</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fDebugMin" title="Long64_t TTree::fDebugMin">fDebugMin</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TDirectory.html">TDirectory</a>             * <a class="funcname" name="TTree:GetDirectory" href="src/TTree.h.html#Ry4.3C">GetDirectory</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fDirectory" title="TDirectory* TTree::fDirectory">fDirectory</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetEntries" href="src/TTree.h.html#RIMPdD">GetEntries</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fEntries" title="Long64_t TTree::fEntries">fEntries</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetEntriesFast" href="src/TTree.h.html#ny83pC">GetEntriesFast</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fEntries" title="Long64_t TTree::fEntries">fEntries</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetEstimate" href="src/TTree.h.html#bkmNXD">GetEstimate</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fEstimate" title="Long64_t TTree::fEstimate">fEstimate</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:GetEvent" href="src/TTree.h.html#zqicoD">GetEvent</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> entry = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> getall = 0)</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:GetEntry" title="Int_t TTree::GetEntry(Long64_t entry=0,Int_t getall=0)">GetEntry</a>(entry, getall); }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TEventList.html">TEventList</a>             * <a class="funcname" name="TTree:GetEventList" href="src/TTree.h.html#C9smmD">GetEventList</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fEventList" title="TEventList* TTree::fEventList">fEventList</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:GetFileNumber" href="src/TTree.h.html#qHzWDE">GetFileNumber</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fFileNumber" title="Int_t TTree::fFileNumber">fFileNumber</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TH1.html">TH1</a>                    * <a class="funcname" name="TTree:GetHistogram" href="src/TTree.h.html#XBX9VC">GetHistogram</a>()</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:GetPlayer" title="TVirtualTreePlayer* TTree::GetPlayer()">GetPlayer</a>()-><a href="./TVirtualTreePlayer.html#TVirtualTreePlayer:GetHistogram" title="TH1* TVirtualTreePlayer::GetHistogram()">GetHistogram</a>(); }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a>          * <a class="funcname" name="TTree:GetIndex" href="src/TTree.h.html#nCnj7D">GetIndex</a>()</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> &amp;<a href="./TTree.html#TTree:fIndex" title="TArrayI TTree::fIndex">fIndex</a>.<a href="./TArrayI.html#TArrayI:fArray" title="Int_t* TArrayI::fArray">fArray</a>[0]; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a>       * <a class="funcname" name="TTree:GetIndexValues" href="src/TTree.h.html#ycQvt">GetIndexValues</a>()</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> &amp;<a href="./TTree.html#TTree:fIndexValues" title="TArrayD TTree::fIndexValues">fIndexValues</a>.<a href="./TArrayD.html#TArrayD:fArray" title="Double_t* TArrayD::fArray">fArray</a>[0]; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TList.html">TList</a>          * <a class="funcname" name="TTree:GetListOfClones" href="src/TTree.h.html#fnJILB">GetListOfClones</a>()</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fClones" title="TList* TTree::fClones">fClones</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TObjArray.html">TObjArray</a>      * <a class="funcname" name="TTree:GetListOfBranches" href="src/TTree.h.html#QzhoBB">GetListOfBranches</a>()</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> &amp;<a href="./TTree.html#TTree:fBranches" title="TObjArray TTree::fBranches">fBranches</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TObjArray.html">TObjArray</a>      * <a class="funcname" name="TTree:GetListOfLeaves" href="src/TTree.h.html#FHrdWB">GetListOfLeaves</a>()</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> &amp;<a href="./TTree.html#TTree:fLeaves" title="TObjArray TTree::fLeaves">fLeaves</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TList.html">TList</a>          * <a class="funcname" name="TTree:GetListOfFriends" href="src/TTree.h.html#xZtduB">GetListOfFriends</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fFriends" title="TList* TTree::fFriends">fFriends</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TList.html">TList</a>          * <a class="funcname" name="TTree:GetListOfAliases" href="src/TTree.h.html#iMrrnC">GetListOfAliases</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fAliases" title="TList* TTree::fAliases">fAliases</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:GetMakeClass" href="src/TTree.h.html#Pah_jE">GetMakeClass</a>() const</span><br />
<div class="funccomm"><pre> <a href="./TTree.html#TTree:GetMakeClass" title="Int_t TTree::GetMakeClass()">GetMakeClass</a> is left non-virtual for efficiency reason.
 Making it virtual affects the performance of the I/O
</pre></div>

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fMakeClass" title="Int_t TTree::fMakeClass">fMakeClass</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetMaxEntryLoop" href="src/TTree.h.html#ZvfJS">GetMaxEntryLoop</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fMaxEntryLoop" title="Long64_t TTree::fMaxEntryLoop">fMaxEntryLoop</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetMaxVirtualSize" href="src/TTree.h.html#Vg7O3C">GetMaxVirtualSize</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fMaxVirtualSize" title="Long64_t TTree::fMaxVirtualSize">fMaxVirtualSize</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:GetNbranches" href="src/TTree.h.html#wAYZoD">GetNbranches</a>()</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fBranches" title="TObjArray TTree::fBranches">fBranches</a>.<a href="./TObjArray.html#TObjArray:GetEntriesFast" title="Int_t TObjArray::GetEntriesFast()">GetEntriesFast</a>(); }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TObject.html">TObject</a>                * <a class="funcname" name="TTree:GetNotify" href="src/TTree.h.html#iuQimD">GetNotify</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fNotify" title="TObject* TTree::fNotify">fNotify</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:GetPacketSize" href="src/TTree.h.html#wpA.tE">GetPacketSize</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fPacketSize" title="Int_t TTree::fPacketSize">fPacketSize</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetReadEntry" href="src/TTree.h.html#T6OtSD">GetReadEntry</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fReadEntry" title="Long64_t TTree::fReadEntry">fReadEntry</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetReadEvent" href="src/TTree.h.html#WwQZhD">GetReadEvent</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fReadEntry" title="Long64_t TTree::fReadEntry">fReadEntry</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:GetScanField" href="src/TTree.h.html#bojy8C">GetScanField</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fScanField" title="Int_t TTree::fScanField">fScanField</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TTreeFormula.html">TTreeFormula</a>           * <a class="funcname" name="TTree:GetSelect" href="src/TTree.h.html#kJZpQ">GetSelect</a>()</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:GetPlayer" title="TVirtualTreePlayer* TTree::GetPlayer()">GetPlayer</a>()-><a href="./TVirtualTreePlayer.html#TVirtualTreePlayer:GetSelect" title="TTreeFormula* TVirtualTreePlayer::GetSelect()">GetSelect</a>(); }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetSelectedRows" href="src/TTree.h.html#gYcwgE">GetSelectedRows</a>()</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:GetPlayer" title="TVirtualTreePlayer* TTree::GetPlayer()">GetPlayer</a>()-><a href="./TVirtualTreePlayer.html#TVirtualTreePlayer:GetSelectedRows" title="Long64_t TVirtualTreePlayer::GetSelectedRows()">GetSelectedRows</a>(); }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:GetTimerInterval" href="src/TTree.h.html#HLPKqD">GetTimerInterval</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fTimerInterval" title="Int_t TTree::fTimerInterval">fTimerInterval</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetTotBytes" href="src/TTree.h.html#OlvTK">GetTotBytes</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fTotBytes" title="Long64_t TTree::fTotBytes">fTotBytes</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TTree.html">TTree</a>          * <a class="funcname" name="TTree:GetTree" href="src/TTree.h.html#voDoAB">GetTree</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<a href="./TTree.html">TTree</a>*&gt;(<span class="keyword">this</span>); }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TVirtualIndex.html">TVirtualIndex</a>  * <a class="funcname" name="TTree:GetTreeIndex" href="src/TTree.h.html#x2mB4E">GetTreeIndex</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fTreeIndex" title="TVirtualIndex* TTree::fTreeIndex">fTreeIndex</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:GetTreeNumber" href="src/TTree.h.html#VdcHcC">GetTreeNumber</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> 0; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="TTree:GetUpdate" href="src/TTree.h.html#zbeg5D">GetUpdate</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fUpdate" title="Int_t TTree::fUpdate">fUpdate</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TTreeFormula.html">TTreeFormula</a>           * <a class="funcname" name="TTree:GetVar" href="src/TTree.h.html#iyRXYC">GetVar</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> i)</span><br />
<div class="funccomm"><pre> See <a href="./TSelectorDraw.html">TSelectorDraw</a>::<a href="./TSelectorDraw.html#TSelectorDraw:GetVar" title="TTreeFormula* TSelectorDraw::GetVar(Int_t i)">GetVar</a>
</pre></div>

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:GetPlayer" title="TVirtualTreePlayer* TTree::GetPlayer()">GetPlayer</a>()-><a href="./TVirtualTreePlayer.html#TVirtualTreePlayer:GetVar" title="TTreeFormula* TVirtualTreePlayer::GetVar(Int_t )">GetVar</a>(i); }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TTreeFormula.html">TTreeFormula</a>           * <a class="funcname" name="TTree:GetVar1" href="src/TTree.h.html#vwozhD">GetVar1</a>()</span><br />
<div class="funccomm"><pre> See <a href="./TSelectorDraw.html">TSelectorDraw</a>::<a href="./TSelectorDraw.html#TSelectorDraw:GetVar" title="TTreeFormula* TSelectorDraw::GetVar(Int_t i)">GetVar</a>
</pre></div>

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:GetPlayer" title="TVirtualTreePlayer* TTree::GetPlayer()">GetPlayer</a>()-><a href="./TVirtualTreePlayer.html#TVirtualTreePlayer:GetVar1" title="TTreeFormula* TVirtualTreePlayer::GetVar1()">GetVar1</a>(); }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TTreeFormula.html">TTreeFormula</a>           * <a class="funcname" name="TTree:GetVar2" href="src/TTree.h.html#zrtuIE">GetVar2</a>()</span><br />
<div class="funccomm"><pre> See <a href="./TSelectorDraw.html">TSelectorDraw</a>::<a href="./TSelectorDraw.html#TSelectorDraw:GetVar" title="TTreeFormula* TSelectorDraw::GetVar(Int_t i)">GetVar</a>
</pre></div>

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:GetPlayer" title="TVirtualTreePlayer* TTree::GetPlayer()">GetPlayer</a>()-><a href="./TVirtualTreePlayer.html#TVirtualTreePlayer:GetVar2" title="TTreeFormula* TVirtualTreePlayer::GetVar2()">GetVar2</a>(); }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TTreeFormula.html">TTreeFormula</a>           * <a class="funcname" name="TTree:GetVar3" href="src/TTree.h.html#XOLRwE">GetVar3</a>()</span><br />
<div class="funccomm"><pre> See <a href="./TSelectorDraw.html">TSelectorDraw</a>::<a href="./TSelectorDraw.html#TSelectorDraw:GetVar" title="TTreeFormula* TSelectorDraw::GetVar(Int_t i)">GetVar</a>
</pre></div>

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:GetPlayer" title="TVirtualTreePlayer* TTree::GetPlayer()">GetPlayer</a>()-><a href="./TVirtualTreePlayer.html#TVirtualTreePlayer:GetVar3" title="TTreeFormula* TVirtualTreePlayer::GetVar3()">GetVar3</a>(); }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./TTreeFormula.html">TTreeFormula</a>           * <a class="funcname" name="TTree:GetVar4" href="src/TTree.h.html#TTGWd">GetVar4</a>()</span><br />
<div class="funccomm"><pre> See <a href="./TSelectorDraw.html">TSelectorDraw</a>::<a href="./TSelectorDraw.html#TSelectorDraw:GetVar" title="TTreeFormula* TSelectorDraw::GetVar(Int_t i)">GetVar</a>
</pre></div>

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:GetPlayer" title="TVirtualTreePlayer* TTree::GetPlayer()">GetPlayer</a>()-><a href="./TVirtualTreePlayer.html#TVirtualTreePlayer:GetVar4" title="TTreeFormula* TVirtualTreePlayer::GetVar4()">GetVar4</a>(); }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a>       * <a class="funcname" name="TTree:GetVal" href="src/TTree.h.html#FfvtlC">GetVal</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> i)</span><br />
<div class="funccomm"><pre> See <a href="./TSelectorDraw.html">TSelectorDraw</a>::<a href="./TSelectorDraw.html#TSelectorDraw:GetVal" title="Double_t* TSelectorDraw::GetVal(Int_t i)">GetVal</a>
</pre></div>

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:GetPlayer" title="TVirtualTreePlayer* TTree::GetPlayer()">GetPlayer</a>()-><a href="./TVirtualTreePlayer.html#TVirtualTreePlayer:GetVal" title="Double_t* TVirtualTreePlayer::GetVal(Int_t )">GetVal</a>(i); }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a>       * <a class="funcname" name="TTree:GetV1" href="src/TTree.h.html#m.LGeE">GetV1</a>()</span><br />
<div class="funccomm"><pre> See <a href="./TSelectorDraw.html">TSelectorDraw</a>::<a href="./TSelectorDraw.html#TSelectorDraw:GetVal" title="Double_t* TSelectorDraw::GetVal(Int_t i)">GetVal</a>
</pre></div>

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:GetPlayer" title="TVirtualTreePlayer* TTree::GetPlayer()">GetPlayer</a>()-><a href="./TVirtualTreePlayer.html#TVirtualTreePlayer:GetV1" title="Double_t* TVirtualTreePlayer::GetV1()">GetV1</a>(); }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a>       * <a class="funcname" name="TTree:GetV2" href="src/TTree.h.html#aWTGeE">GetV2</a>()</span><br />
<div class="funccomm"><pre> See <a href="./TSelectorDraw.html">TSelectorDraw</a>::<a href="./TSelectorDraw.html#TSelectorDraw:GetVal" title="Double_t* TSelectorDraw::GetVal(Int_t i)">GetVal</a>
</pre></div>

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:GetPlayer" title="TVirtualTreePlayer* TTree::GetPlayer()">GetPlayer</a>()-><a href="./TVirtualTreePlayer.html#TVirtualTreePlayer:GetV2" title="Double_t* TVirtualTreePlayer::GetV2()">GetV2</a>(); }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a>       * <a class="funcname" name="TTree:GetV3" href="src/TTree.h.html#e5QGeE">GetV3</a>()</span><br />
<div class="funccomm"><pre> See <a href="./TSelectorDraw.html">TSelectorDraw</a>::<a href="./TSelectorDraw.html#TSelectorDraw:GetVal" title="Double_t* TSelectorDraw::GetVal(Int_t i)">GetVal</a>
</pre></div>

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:GetPlayer" title="TVirtualTreePlayer* TTree::GetPlayer()">GetPlayer</a>()-><a href="./TVirtualTreePlayer.html#TVirtualTreePlayer:GetV3" title="Double_t* TVirtualTreePlayer::GetV3()">GetV3</a>(); }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a>       * <a class="funcname" name="TTree:GetV4" href="src/TTree.h.html#SQYGeE">GetV4</a>()</span><br />
<div class="funccomm"><pre> See <a href="./TSelectorDraw.html">TSelectorDraw</a>::<a href="./TSelectorDraw.html#TSelectorDraw:GetVal" title="Double_t* TSelectorDraw::GetVal(Int_t i)">GetVal</a>
</pre></div>

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:GetPlayer" title="TVirtualTreePlayer* TTree::GetPlayer()">GetPlayer</a>()-><a href="./TVirtualTreePlayer.html#TVirtualTreePlayer:GetV4" title="Double_t* TVirtualTreePlayer::GetV4()">GetV4</a>(); }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a>       * <a class="funcname" name="TTree:GetW" href="src/TTree.h.html#sSdzRD">GetW</a>()</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:GetPlayer" title="TVirtualTreePlayer* TTree::GetPlayer()">GetPlayer</a>()-><a href="./TVirtualTreePlayer.html#TVirtualTreePlayer:GetW" title="Double_t* TVirtualTreePlayer::GetW()">GetW</a>(); }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Double_t">Double_t</a> <a class="funcname" name="TTree:GetWeight" href="src/TTree.h.html#D1vUy">GetWeight</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fWeight" title="Double_t TTree::fWeight">fWeight</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Long64_t">Long64_t</a> <a class="funcname" name="TTree:GetZipBytes" href="src/TTree.h.html#F0T7K">GetZipBytes</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./TTree.html#TTree:fZipBytes" title="Long64_t TTree::fZipBytes">fZipBytes</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:IncrementTotalBuffers" href="src/TTree.h.html#sbPrQE">IncrementTotalBuffers</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nbytes)</span><br />

<div class="code"><code class="inlinecode">{ <a href="./TTree.html#TTree:fTotalBuffers" title="Long64_t TTree::fTotalBuffers">fTotalBuffers</a> += nbytes; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Bool_t">Bool_t</a> <a class="funcname" name="TTree:IsFolder" href="src/TTree.h.html#nujqW">IsFolder</a>() const</span><br />

<div class="code"><code class="inlinecode">{ <span class="keyword">return</span> <a href="./ListOfTypes.html#Bool_t">kTRUE</a>; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetChainOffset" href="src/TTree.h.html#LcK7XD">SetChainOffset</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> offset = 0)</span><br />

<div class="code"><code class="inlinecode">{ <a href="./TTree.html#TTree:fChainOffset" title="Long64_t TTree::fChainOffset">fChainOffset</a>=offset; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetMaxEntryLoop" href="src/TTree.h.html#FpqhbE">SetMaxEntryLoop</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> maxev = 1000000000)</span><br />

<div class="code"><code class="inlinecode">{ <a href="./TTree.html#TTree:fMaxEntryLoop" title="Long64_t TTree::fMaxEntryLoop">fMaxEntryLoop</a> = maxev; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetMaxVirtualSize" href="src/TTree.h.html#e1Cc_C">SetMaxVirtualSize</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> size = 0)</span><br />

<div class="code"><code class="inlinecode">{ <a href="./TTree.html#TTree:fMaxVirtualSize" title="Long64_t TTree::fMaxVirtualSize">fMaxVirtualSize</a> = size; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetNotify" href="src/TTree.h.html#vENKVB">SetNotify</a>(<a href="./TObject.html">TObject</a>* obj)</span><br />

<div class="code"><code class="inlinecode">{ <a href="./TTree.html#TTree:fNotify" title="TObject* TTree::fNotify">fNotify</a> = obj; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetScanField" href="src/TTree.h.html#eSXRSE">SetScanField</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> n = 50)</span><br />

<div class="code"><code class="inlinecode">{ <a href="./TTree.html#TTree:fScanField" title="Int_t TTree::fScanField">fScanField</a> = n; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetTimerInterval" href="src/TTree.h.html#FRXqC">SetTimerInterval</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> msec = 333)</span><br />

<div class="code"><code class="inlinecode">{ <a href="./TTree.html#TTree:fTimerInterval" title="Int_t TTree::fTimerInterval">fTimerInterval</a>=msec; }</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="TTree:SetUpdate" href="src/TTree.h.html#LAF53C">SetUpdate</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> freq = 0)</span><br />

<div class="code"><code class="inlinecode">{ <a href="./TTree.html#TTree:fUpdate" title="Int_t TTree::fUpdate">fUpdate</a> = freq; }</code></div>
<div style="clear:both;"></div>
</div>

<br />
<!--SIGNATURE-->
<div id="footer">
<em>&raquo; Author: <a href="http://consult.cern.ch/xwho/people?Rene+Brun"> Rene Brun   12/01/96</a> </em><em>&raquo; Copyright   (C) 1995-2000, Rene Brun and Fons Rademakers.               *</em><br />
<em>&raquo; Last changed: root/tree:$Id: TTree.h 41101 2011-10-03 16:23:48Z pcanal $ </em><em>&raquo; Last generated: 2011-11-03 20:23</em><br />
<em>This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>.</em>
</div>
</div>
</body>
</html>
